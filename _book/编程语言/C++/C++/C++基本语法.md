---
title: CPlusPlus基本语法
date: 2024-03-13 14:22:52
updated: 2024-11-15 21:39:03
categories:
  - 编程语言
  - CCPlusPlus
  - CPlusPlus
tags:
  - C语言
permalink: /posts/CPlusPlus基本语法/
---
## 一、C++简介
C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。
C++ 被认为是一种**中级**语言，它综合了高级语言和低级语言的特点。
C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。
C++ 是 C 的一个**超集**，事实上，任何合法的 C 程序都是合法的 C++ 程序。

**注意：**使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。

### 面向对象程序设计

C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：
- **封装（Encapsulation）**：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。
- **继承（Inheritance）**：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。
- **多态（Polymorphism）**：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。
- **抽象（Abstraction）**：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。
### 标准库

标准的 C++ 由三个重要部分组成：
- **核心语言**，提供了所有构件块，包括变量、数据类型和常量，等等。
- **C++ 标准库**，提供了大量的函数，用于操作文件、字符串等。
- **标准模板库（STL）**，提供了大量的方法，用于操作数据结构等。

## 二、C++基本语法
### C++ 程序结构

让我们看一段简单的代码，可以输出单词 _Hello World_。
```c++
#include <iostream>
using namespace std;
// main() 是程序开始执行的地方
int main() {
	cout << "Hello World"; // 输出 Hello World
	return 0;
}
```
- C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 `<iostream>`。
- 下一行 **using namespace std;** 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。
- 下一行 **// main() 是程序开始执行的地方** 是一个单行注释。单行注释以 // 开头，在行末结束。
- 下一行 **int main()** 是主函数，程序从这里开始执行。
- 下一行 **cout << "Hello World";** 会在屏幕上显示消息 "Hello World"。
- 下一行 **return 0;** 终止 main( )函数，并向调用进程返回值 0。

### C++注释
C++ 注释一般有两种：
- `//`：一般用于单行注释。
- `/* ... */`：一般用于多行注释。

### C++数据类型
C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。
下表列出了七种基本的 C++ 数据类型：

|类型|关键字|
|---|---|
|布尔型|bool|
|字符型|char|
|整型|int|
|浮点型|float|
|双浮点型|double|
|无类型|void|
|宽字符型|wchar_t|

其实 wchar_t 是这样来的：

```c++
typedef short int wchar_t;
```
所以 wchar_t 实际上的空间是和 short int 一样。
一些基本类型可以使用**一个或多个**类型修饰符进行修饰：
- signed
- unsigned
- short
- long
### typedef 声明
您可以使用 **typedef** 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：
```c++
typedef type newname; 
```

例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：
```c++
typedef int feet;
```

现在，下面的声明是完全合法的，它创建了一个整型变量 distance：
```c++
feet distance;
```

### 枚举类型
*枚举类型(enumeration)*是C++中的一种**派生数据类型**，它是由用户定义的若干枚举常量的集合。
如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓"枚举"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。
创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：
```c++
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;
```

如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始。
例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"。
```c++
enum color { red, green, blue } c;
c = blue;
```

默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。
例如，在下面的枚举中，**green** 的值为 5。
```c++
enum color { red, green=5, blue };
```
在这里，**blue** 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。

### 类型转换

类型转换是将一个数据类型的值转换为另一种数据类型的值。
C++ 中有四种类型转换：**静态转换**、**动态转换**、**常量转换**和**重新解释转换**。

#### 静态转换（Static Cast）

静态转换是将一种数据类型的值**强制转换**为另一种数据类型的值。
静态转换通常用于*比较类型相似的对象之间的转换*，例如将 int 类型转换为 float 类型。
静态转换*不进行任何运行时类型检查*，因此可能会导致运行时错误。

**实例**
```c++
int i = 10; 
float f = static_cast<float>(i); // 静态将int类型转换为float类型
```

#### 动态转换（Dynamic Cast）

动态转换通常用于将*一个基类指针或引用转换为派生类指针或引用*。动态转换在运行时*进行类型检查*，如果不能进行转换则返回空指针或引发异常。

**实例**
```c++
class Base {};
class Derived : public Base {};
Base* ptr_base = new Derived; Derived*
ptr_derived = dynamic_cast<Derived*>(ptr_base); // 将基类指针转换为派生类指针
```

#### 常量转换（Const Cast）

常量转换用于**将 const 类型的对象转换为非 const 类型的对象**。
常量转换**只能**用于转换掉 const 属性，不能改变对象的类型。

**实例**
```c++
const int i = 10;
int& r = const_cast<int&>(i); // 常量转换，将const int转换为int
```

#### 重新解释转换（Reinterpret Cast）

重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常**用于在不同的数据类型之间进行转换**。
重新解释转换*不进行任何类型检查*，因此可能会导致未定义的行为。

**实例**
```c++
int i = 10;
float f = reinterpret_cast<float&>(i); // 重新解释将int类型转换为float类型
```

## 三、C++变量类型
C++ 也允许定义各种其他类型的变量，比如**枚举、指针、数组、引用、数据结构、类**等等，这将会在后续的章节中进行讲解。

1. 整数类型（Integer Types）：
    - `int`：用于表示整数，通常占用4个字节。
    - `short`：用于表示短整数，通常占用2个字节。
    - `long`：用于表示长整数，通常占用4个字节。
    - `long long`：用于表示更长的整数，通常占用8个字节。

1. 浮点类型（Floating-Point Types）：
    - `float`：用于表示单精度浮点数，通常占用4个字节。
    - `double`：用于表示双精度浮点数，通常占用8个字节。
    - `long double`：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。

2. 字符类型（Character Types）：
    - `char`：用于表示字符，通常占用1个字节。
    - `wchar_t`：用于表示宽字符，通常占用2或4个字节。
    - `char16_t`：用于表示16位Unicode字符，占用2个字节。
    - `char32_t`：用于表示32位Unicode字符，占用4个字节。

1. 布尔类型（Boolean Type）：
    - `bool`：用于表示布尔值，只能取`true`或`false`。

1. 枚举类型（Enumeration Types）：
    - `enum`：用于定义一组命名的整数常量。

1. 指针类型（Pointer Types）：
    - `type*`：用于表示指向类型为`type`的对象的指针。

1. 数组类型（Array Types）：
    - `type[]`或`type[size]`：用于表示具有相同类型的元素组成的数组。

1. 结构体类型（Structure Types）：
    - `struct`：用于定义包含多个不同类型成员的结构。

1. 类类型（Class Types）：
    - `class`：用于定义具有属性和方法的自定义类型。

1. 共用体类型（Union Types）：
    - `union`：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。

> 在 C++ 中，类型的长度（即占用的字节数）取决于编译器和计算机架构，然而，C++ 标准规定了不同整数类型的最小范围，而不是具体的字节数，这是为了确保代码在不同的系统上都能正确运行。
> 请注意，以上类型的范围只是 C++ 标准规定的最小要求，实际上，许多系统上这些类型可能占用更多的字节，例如，很多现代计算机上 int 通常占用 4 字节，而 long 可能占用 8 字节。

### 变量类型作用域

一般来说有三个地方可以定义变量：
- 在函数或一个代码块内部声明的变量，称为**局部变量**。
- 在函数参数的定义中声明的变量，称为**形式参数**。
- 在所有函数外部声明的变量，称为**全局变量**。

作用域是程序的一个区域，变量的作用域可以分为以下几种：

- **局部作用域**：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。
    
- **全局作用域**：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。
    
- **块作用域**：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
    
- **类作用域**：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。

**注意：** 如果在内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量。

## 四、C++ 常量

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。

常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

### 整数常量

整数常量可以是十进制、八进制或十六进制的常量。
前缀指定基数：
- 0x 或 0X 表示十六进制
- 0 表示八进制
- 不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合：
- U 表示无符号整数（unsigned）
- L 表示长整数（long）。
后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

## 五、C++循环判断语句
C++循环判断语法与C语言相同

## 六、C++运算符

运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：
- 算术运算符
- 关系运算符
- 逻辑运算符
- 位运算符
- 赋值运算符
- 杂项运算符

### 算术运算符

下表显示了 C++ 支持的算术运算符。
假设变量 A 的值为 10，变量 B 的值为 20，则：

|运算符|描述|实例|
|---|---|---|
|+|把两个操作数相加|A + B 将得到 30|
|-|从第一个操作数中减去第二个操作数|A - B 将得到 -10|
|*|把两个操作数相乘|A * B 将得到 200|
|/|分子除以分母|B / A 将得到 2|
|%|取模运算符，整除后的余数|B % A 将得到 0|
|++|[自增运算符](https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html "C++ 中的自增运算符")，整数值增加 1|A++ 将得到 11|
|--|[自减运算符](https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html "C++ 中的自减运算符")，整数值减少 1|A-- 将得到 9|

### 关系运算符

下表显示了 C++ 支持的关系运算符。
假设变量 A 的值为 10，变量 B 的值为 20，则：

|运算符|描述|实例|
|---|---|---|
|==|检查两个操作数的值是否相等，如果相等则条件为真。|(A == B) 不为真。|
|!=|检查两个操作数的值是否相等，如果不相等则条件为真。|(A != B) 为真。|
|>|检查左操作数的值是否大于右操作数的值，如果是则条件为真。|(A > B) 不为真。|
|<|检查左操作数的值是否小于右操作数的值，如果是则条件为真。|(A < B) 为真。|
|>=|检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。|(A >= B) 不为真。|
|<=|检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。|(A <= B) 为真。|

### 逻辑运算符

下表显示了 C++ 支持的关系逻辑运算符。
假设变量 A 的值为 1，变量 B 的值为 0，则：

| 运算符 | 描述                                                  | 实例                |
| --- | --------------------------------------------------- | ----------------- |
| &&  | 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。                   | (A && B) 为 false。 |
| \|  | 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。              | (A \| B) 为 true。  |
| !   | 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 | !(A && B) 为 true。 |

### 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

|p|q|p & q|p \| q|p ^ q|
|---|---|---|---|---|
|0|0|0|0|0|
|0|1|0|1|1|
|1|1|1|1|0|
|1|0|0|1|1|
- &：按位与操作
- |：按位或操作
- ^：按位异或

### 赋值运算符

下表列出了 C++ 支持的赋值运算符：

|运算符|描述|实例|
|---|---|---|
|=|简单的赋值运算符，把右边操作数的值赋给左边操作数|C = A + B 将把 A + B 的值赋给 C|
|+=|加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数|C += A 相当于 C = C + A|
|-=|减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数|C -= A 相当于 C = C - A|
|*=|乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数|C *= A 相当于 C = C * A|
|/=|除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数|C /= A 相当于 C = C / A|
|%=|求模且赋值运算符，求两个操作数的模赋值给左边操作数|C %= A 相当于 C = C % A|
|<<=|左移且赋值运算符|C <<= 2 等同于 C = C << 2|
|>>=|右移且赋值运算符|C >>= 2 等同于 C = C >> 2|
|&=|按位与且赋值运算符|C &= 2 等同于 C = C & 2|
|^=|按位异或且赋值运算符|C ^= 2 等同于 C = C ^ 2|
|\|=|按位或且赋值运算符|C \|= 2 等同于 C = C \| 2|

